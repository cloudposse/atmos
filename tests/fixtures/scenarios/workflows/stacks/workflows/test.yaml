workflows:
  pass:
    description: |
      Run a command that will pass.
    steps:
      - command: terraform plan mock -s nonprod

  fail:
    description: |
      Run a command that will fail.
    steps:
      - command: terraform plan mock -s idontexist

  shell-pass:
    description: |
      Run a shell command that will pass.
    steps:
      - command: echo "This should pass"
        type: shell

  shell-failure:
    description: |
      Run a shell command that will fail.
    steps:
      - command: |
          echo "This should fail"
          exit 1
        type: shell

  shell-command-not-found:
    description: |
      Run a shell command that doesn't exist.
    steps:
      - command: nonexistentcommand
        type: shell

  no-steps:
    description: |
      A workflow with no steps.
    steps: []

  invalid-step-type:
    description: |
      A workflow with an invalid step type.
    steps:
      - command: echo "This should fail"
        type: invalid

  fail-with-stack:
    description: |
      Run a command that will fail with a stack parameter.
    stack: prod
    steps:
      - command: terraform plan idontexist

  shell-with-path:
    description: |
      Run a shell command that requires PATH to be set.
    steps:
      - command: env | grep PATH
        type: shell

  # Test cases for multi-component operations with quoted arguments
  # These test the issue where strings.Fields() incorrectly splits quoted arguments

  # This workflow tests the --query flag with a quoted expression
  # The query contains spaces and special characters that should be preserved
  multi-component-query:
    description: |
      Test multi-component operation with --query flag containing quoted expression.
      This reproduces the issue where strings.Fields() splits the quoted query.
    steps:
      # This command should be parsed as a single query argument:
      #   ["terraform", "plan", "--query", ".settings.enabled == true", "-s", "nonprod"]
      # But strings.Fields() incorrectly splits the quoted query into multiple tokens:
      #   ["terraform", "plan", "--query", "'.settings.enabled", "==", "true'", "-s", "nonprod"]
      # which causes the CLI to interpret "'.settings.enabled" as a component argument.
      - command: terraform plan --query '.settings.enabled == true' -s nonprod

  # This workflow tests the --components flag with comma-separated values
  multi-component-list:
    description: |
      Test multi-component operation with --components flag.
    steps:
      - command: terraform plan --components mock -s nonprod

  # This workflow tests the --all flag
  multi-component-all:
    description: |
      Test multi-component operation with --all flag.
    steps:
      - command: terraform plan --all -s nonprod

  # Shell command that echoes back arguments to verify parsing
  shell-echo-args:
    description: |
      Echo back arguments to verify shell parsing of quoted strings.
    steps:
      - command: echo "argument with spaces" 'single quoted' "double quoted"
        type: shell

  # Test double-quoted query expression
  multi-component-query-double-quotes:
    description: |
      Test multi-component with double-quoted query expression.
    steps:
      - command: terraform plan --query ".metadata.component == \"mock\"" -s nonprod

  # Test cases for -var flag with quoted values
  # This reproduces the issue reported by users where -var="key=value" is incorrectly parsed
  # Fixed in PR #1961

  # Test -var with double quotes (the exact pattern from user report)
  terraform-var-double-quotes:
    description: |
      Test terraform -var flag with double-quoted value.
      This reproduces the issue where strings.Fields() keeps quotes as literal characters,
      causing Terraform to see the variable name as "enabled instead of enabled.
    steps:
      # The command should pass -var=enabled=false to terraform
      # But with strings.Fields(), it passes -var="enabled=false" (with literal quotes)
      - command: terraform plan mock -var="enabled=false" -s nonprod

  # Test -var with single quotes
  terraform-var-single-quotes:
    description: |
      Test terraform -var flag with single-quoted value.
    steps:
      - command: terraform plan mock -var='enabled=false' -s nonprod

  # Test multiple -var flags with different quote styles
  terraform-var-multiple:
    description: |
      Test multiple -var flags with various quote styles.
    steps:
      - command: terraform plan mock -var="enabled=false" -var='foo=bar' -s nonprod

  # Test -var with value containing spaces (must be quoted)
  terraform-var-with-spaces:
    description: |
      Test terraform -var flag with value containing spaces.
    steps:
      - command: terraform plan mock -var="message=hello world" -s nonprod

  # Test -var with equals sign in value
  terraform-var-equals-in-value:
    description: |
      Test terraform -var flag with equals sign in the value.
    steps:
      - command: terraform plan mock -var="message=key=value" -s nonprod

  # Test shell command to verify quote parsing
  shell-var-echo:
    description: |
      Shell command to verify quote parsing produces correct arguments.
    steps:
      - command: echo -var="enabled=false" -var='foo=bar'
        type: shell

  # Test cases for double-hyphen (--) separator parsing
  # This reproduces GitHub issue #1967 where commands with -- separator
  # were incorrectly parsed, causing stack value corruption.
  #
  # The POSIX convention is that -- separates command options from positional arguments.
  # Everything after -- should be passed through to terraform without being parsed by atmos.

  # Test double-hyphen with stack in command
  # This is the exact pattern from the bug report
  double-hyphen-with-stack:
    description: |
      Test command with -- separator and --stack flag.
      Reproduces issue #1967 where stack value gets corrupted.
    steps:
      # The command includes --stack and then -- followed by terraform flags
      - command: terraform plan mock --stack nonprod -- -consolidate-warnings=false

  # Test double-hyphen with workflow-level stack override
  double-hyphen-workflow-stack:
    description: |
      Test double-hyphen with workflow-level stack.
      Stack from workflow should be inserted before --.
    stack: nonprod
    steps:
      - command: terraform plan mock -- -consolidate-warnings=false

  # Test double-hyphen with step-level stack override
  double-hyphen-step-stack:
    description: |
      Test double-hyphen with step-level stack.
      Stack from step should be inserted before --.
    steps:
      - command: terraform plan mock -- -consolidate-warnings=false
        stack: nonprod

  # Test double-hyphen with both command stack and workflow stack
  # Workflow stack should override command stack
  double-hyphen-stack-precedence:
    description: |
      Test stack precedence with double-hyphen.
      Workflow stack should override inline stack.
    stack: nonprod
    steps:
      # This has --stack wrongstack but workflow says nonprod
      - command: terraform plan mock --stack wrongstack -- -consolidate-warnings=false

  # Test double-hyphen with multiple terraform flags after separator
  double-hyphen-multiple-flags:
    description: |
      Test multiple terraform flags after -- separator.
    steps:
      - command: terraform plan mock -s nonprod -- -var="foo=bar" -var="baz=qux"

  # Test shell command to verify parsing of -- separator
  shell-double-hyphen-echo:
    description: |
      Shell command to verify -- separator parsing.
    steps:
      - command: echo "before --" -- "after --"
        type: shell

  # Test cases for environment variable support
  # These test the new env map feature at workflow and step levels

  # Test workflow-level env vars
  env-workflow-level:
    description: |
      Test workflow-level environment variables.
    env:
      MY_WORKFLOW_VAR: workflow-value
    steps:
      - command: env | grep MY_WORKFLOW_VAR
        type: shell

  # Test step-level env vars
  env-step-level:
    description: |
      Test step-level environment variables.
    steps:
      - command: env | grep MY_STEP_VAR
        type: shell
        env:
          MY_STEP_VAR: step-value

  # Test env var precedence (step overrides workflow)
  env-precedence:
    description: |
      Test that step env overrides workflow env.
    env:
      MY_VAR: workflow-value
    steps:
      - command: test "$MY_VAR" = "step-value"
        type: shell
        env:
          MY_VAR: step-value

  # Test env var merge (different keys from workflow and step)
  env-merge:
    description: |
      Test that workflow and step env vars are merged.
    env:
      WORKFLOW_VAR: from-workflow
    steps:
      - command: |
          test "$WORKFLOW_VAR" = "from-workflow" && \
          test "$STEP_VAR" = "from-step"
        type: shell
        env:
          STEP_VAR: from-step

  # Test env vars with inheritance and override (the user's example)
  env-inheritance-example:
    description: |
      Test the user's example: FOO inherited, BAZ overridden.
      Expected output: bar - baz
    env:
      FOO: bar
      BAZ: foo
    steps:
      - command: echo "$FOO - $BAZ"
        type: shell
        env:
          BAZ: baz

  # Test environment variable scoping
  # Demonstrates that:
  # - Workflow env applies to all steps
  # - Step env only applies to that specific step
  # - Step env does NOT persist to subsequent steps
  # - Shell exports do NOT persist to subsequent steps (each step runs in isolation)
  env-scoping:
    description: |
      Test environment variable scoping behavior.
      Demonstrates that step-level env and shell exports are scoped to individual steps.
    env:
      FOO: workflow
    steps:
      # Step 1: Should see workflow-level FOO
      - command: test "$FOO" = "workflow"
        type: shell

      # Step 2: Override FOO at step level
      - command: test "$FOO" = "stepEnv"
        type: shell
        env:
          FOO: stepEnv

      # Step 3: Step env should NOT persist - back to workflow value
      - command: test "$FOO" = "workflow"
        type: shell

      # Step 4: Export FOO in shell (this only affects the current step's process)
      - command: export FOO=exported && test "$FOO" = "exported"
        type: shell

      # Step 5: Shell export should NOT persist - back to workflow value
      - command: test "$FOO" = "workflow"
        type: shell
