package workdir

import (
	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	errUtils "github.com/cloudposse/atmos/errors"
	cfg "github.com/cloudposse/atmos/pkg/config"
	"github.com/cloudposse/atmos/pkg/flags"
	"github.com/cloudposse/atmos/pkg/perf"
	"github.com/cloudposse/atmos/pkg/schema"
	"github.com/cloudposse/atmos/pkg/ui"
	"github.com/cloudposse/atmos/pkg/ui/theme"
)

var cleanParser *flags.StandardParser

var cleanCmd = &cobra.Command{
	Use:   "clean [component]",
	Short: "Clean workdir(s)",
	Long: `Remove component working directories.

Use --all to clean all workdirs, or specify a component and stack to clean a specific workdir.
Use --expired with --ttl to clean only workdirs that haven't been accessed within the TTL.
Workdirs are ephemeral and can be regenerated by running 'atmos terraform init'.`,
	Example: `  # Clean a specific workdir
  atmos terraform workdir clean vpc --stack dev

  # Clean all workdirs
  atmos terraform workdir clean --all

  # Clean expired workdirs (not accessed in 7 days)
  atmos terraform workdir clean --expired --ttl=7d

  # Dry run - show what would be cleaned
  atmos terraform workdir clean --expired --ttl=24h --dry-run`,
	Args: cobra.MaximumNArgs(1),
	RunE: func(cmd *cobra.Command, args []string) error {
		defer perf.Track(atmosConfigPtr, "workdir.clean.RunE")()

		v := viper.GetViper()
		// Bind flags to viper at runtime to ensure flag values are available.
		if err := cleanParser.BindFlagsToViper(cmd, v); err != nil {
			return err
		}
		all := v.GetBool("all")
		expired := v.GetBool("expired")
		ttl := v.GetString("ttl")
		dryRun := v.GetBool("dry-run")
		stack := v.GetString("stack")

		// Validate arguments.
		if expired {
			// --expired mode: requires --ttl, ignores --all and component.
			if ttl == "" {
				return errUtils.Build(errUtils.ErrWorkdirClean).
					WithExplanation("TTL is required when using --expired").
					WithHint("Specify a TTL like --ttl=7d or --ttl=24h").
					Err()
			}
			if all || len(args) > 0 {
				return errUtils.Build(errUtils.ErrWorkdirClean).
					WithExplanation("Cannot use --all or component with --expired").
					WithHint("Use --expired --ttl=<duration> alone to clean expired workdirs").
					Err()
			}
		} else {
			// Non-expired mode: standard validation.
			if all && len(args) > 0 {
				return errUtils.Build(errUtils.ErrWorkdirClean).
					WithExplanation("Cannot specify both --all and a component").
					WithHint("Use --all alone to clean all workdirs, or specify a component and stack").
					Err()
			}

			if !all && len(args) == 0 {
				return errUtils.Build(errUtils.ErrWorkdirClean).
					WithExplanation("Either --all, --expired, or a component is required").
					WithHint("Use --all to clean all workdirs, --expired --ttl to clean stale workdirs, or specify a component with --stack").
					Err()
			}

			if !all && len(args) > 0 && stack == "" {
				return errUtils.Build(errUtils.ErrWorkdirClean).
					WithExplanation("Stack is required when cleaning a specific workdir").
					WithHint("Use --stack to specify the stack").
					Err()
			}
		}

		// Initialize config with global flags (--base-path, --config, etc.).
		configInfo := buildConfigAndStacksInfo(cmd, v)
		atmosConfig, err := cfg.InitCliConfig(configInfo, false)
		if err != nil {
			return errUtils.Build(errUtils.ErrWorkdirClean).
				WithCause(err).
				WithExplanation("Failed to load atmos configuration").
				Err()
		}

		// Clean workdirs based on mode.
		if expired {
			return cleanExpiredWorkdirs(&atmosConfig, ttl, dryRun)
		}
		if all {
			return cleanAllWorkdirs(&atmosConfig)
		}

		component := args[0]
		return cleanSpecificWorkdir(&atmosConfig, component, stack)
	},
}

func cleanAllWorkdirs(atmosConfig *schema.AtmosConfiguration) error {
	defer perf.Track(atmosConfig, "workdir.cleanAllWorkdirs")()

	if err := workdirManager.CleanAllWorkdirs(atmosConfig); err != nil {
		return err
	}

	ui.Writef("%s All workdirs cleaned\n", theme.Styles.Checkmark.String())
	return nil
}

func cleanSpecificWorkdir(atmosConfig *schema.AtmosConfiguration, component, stack string) error {
	defer perf.Track(atmosConfig, "workdir.cleanSpecificWorkdir")()

	if err := workdirManager.CleanWorkdir(atmosConfig, component, stack); err != nil {
		return err
	}

	ui.Writef("%s Workdir cleaned for %s in %s\n", theme.Styles.Checkmark.String(), component, stack)
	return nil
}

func cleanExpiredWorkdirs(atmosConfig *schema.AtmosConfiguration, ttl string, dryRun bool) error {
	defer perf.Track(atmosConfig, "workdir.cleanExpiredWorkdirs")()

	// Use the workdir manager's CleanExpiredWorkdirs.
	return workdirManager.CleanExpiredWorkdirs(atmosConfig, ttl, dryRun)
}

func init() {
	cleanCmd.DisableFlagParsing = false

	// Create parser with functional options.
	cleanParser = flags.NewStandardParser(
		flags.WithStackFlag(),
		flags.WithBoolFlag("all", "a", false, "Clean all workdirs"),
		flags.WithBoolFlag("expired", "e", false, "Clean only expired workdirs (requires --ttl)"),
		flags.WithStringFlag("ttl", "t", "", "TTL for expired cleanup (e.g., 7d, 24h, weekly)"),
		flags.WithBoolFlag("dry-run", "n", false, "Show what would be cleaned without deleting"),
		flags.WithEnvVars("all", "ATMOS_WORKDIR_CLEAN_ALL"),
		flags.WithEnvVars("expired", "ATMOS_WORKDIR_CLEAN_EXPIRED"),
		flags.WithEnvVars("ttl", "ATMOS_WORKDIR_TTL"),
		flags.WithEnvVars("dry-run", "ATMOS_WORKDIR_DRY_RUN"),
	)

	// Register flags with the command.
	cleanParser.RegisterFlags(cleanCmd)

	// Bind flags to Viper.
	if err := cleanParser.BindToViper(viper.GetViper()); err != nil {
		panic(err)
	}
}
