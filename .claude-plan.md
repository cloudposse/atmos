# Auto-Prompt Implementation for Backend Commands

## Summary

Based on analysis of the terraform commands (plan, apply, destroy), here's how auto-prompting works in Atmos and how to implement it for backend commands.

## Current Architecture

### How Terraform Commands Handle Auto-Prompting

The terraform commands (plan, apply, destroy) use a **centralized approach** where prompting is NOT handled in the command itself, but in the **shared processing pipeline**:

1. **Commands do NOT use positional args validation**
   - They do NOT use `cobra.ExactArgs(1)` or similar
   - They accept all args: `args []string` with no validation
   - Args are passed to `terraformRunWithOptions()` which delegates to `ProcessCommandLineArgs()`

2. **Prompting happens in `internal/exec/processArgsAndFlags()`**
   - This legacy function parses args manually
   - It handles component/stack extraction from args
   - **BUT**: It does NOT currently trigger auto-prompts for missing component/stack

3. **The StandardParser is NOT used for component/stack prompting**
   - The terraform commands use StandardParser for flags like `--stack`, `--identity`
   - But component arg is extracted manually in `processArgsAndFlags()`
   - Stack flag is read via Viper in `ProcessCommandLineArgs()`

### Where Prompting DOES Work

The StandardParser's `handleInteractivePrompts()` supports 3 use cases:

1. **Missing required flags** - via `WithCompletionPrompt()`
2. **Optional value flags** - via `WithOptionalValuePrompt()` (like `--identity`)
3. **Missing positional args** - via `WithPositionalArgPrompt()`

**BUT**: Terraform commands don't use positional args at all. They use the legacy `processArgsAndFlags()` instead.

## The Pattern You SHOULD Use for Backend Commands

Backend commands are **different from terraform plan/apply/destroy** because they are NOT part of the legacy execution pipeline. They are **new-style commands** that should follow modern patterns.

### Option 1: Use StandardParser with Positional Args (RECOMMENDED)

This is the **correct modern pattern** for backend commands:

```go
// In cmd/terraform/backend/create.go
var createParser *flags.StandardParser

var createCmd = &cobra.Command{
    Use:   "create [component]",
    Args:  cobra.NoArgs,  // Let StandardParser handle validation
    RunE: func(cmd *cobra.Command, args []string) error {
        v := viper.GetViper()

        // Bind flags to Viper
        if err := createParser.BindFlagsToViper(cmd, v); err != nil {
            return err
        }

        // Parse with StandardParser (includes interactive prompts)
        result, err := createParser.Parse(args)
        if err != nil {
            return err
        }

        // Get component from positional args
        var component string
        if len(result.PositionalArgs) > 0 {
            component = result.PositionalArgs[0]
        }

        // Get stack from flags
        stack := v.GetString("stack")

        return ExecuteProvisionCommand(cmd, []string{component}, createParser, "backend.create")
    },
}

func init() {
    // Define positional args with completion AND prompting
    argsBuilder := flags.NewPositionalArgsBuilder()
    argsBuilder.AddArg("component", "Component name", true)  // required=true

    specs, validator, usage := argsBuilder.Build()

    // Create parser with stack flag AND positional arg prompts
    createParser = flags.NewStandardParser(
        flags.WithStringFlag("stack", "s", "", "Stack name"),
        flags.WithStringFlag("identity", "i", "", "Identity to use for auth"),

        // Enable prompting for missing component (Use Case 3: positional args)
        flags.WithPositionalArgPrompt("component", "Choose a component", componentCompletion),

        // Enable prompting for missing stack flag (Use Case 1: required flags)
        flags.WithCompletionPrompt("stack", "Choose a stack", stackCompletion),

        flags.WithEnvVars("stack", "ATMOS_STACK"),
        flags.WithEnvVars("identity", "ATMOS_IDENTITY"),
    )

    // Set positional args definition
    createParser.SetPositionalArgs(specs, validator, usage)

    // Register flags
    createParser.RegisterFlags(createCmd)

    // Bind to Viper
    if err := createParser.BindToViper(viper.GetViper()); err != nil {
        panic(err)
    }
}
```

**Flow:**
1. User runs: `atmos terraform backend create` (no component, no stack)
2. StandardParser's `Parse()` is called
3. `handleInteractivePrompts()` triggers:
   - First prompts for missing `--stack` flag (Use Case 1)
   - Then prompts for missing `component` positional arg (Use Case 3)
4. User selects interactively
5. Command proceeds with selected values

### Option 2: Manual Prompting (NOT RECOMMENDED)

You COULD manually call the prompting functions, but this is **NOT the pattern used by other commands**:

```go
// ANTI-PATTERN - Don't do this
RunE: func(cmd *cobra.Command, args []string) error {
    // Manually check and prompt
    if len(args) == 0 {
        component, err := flags.PromptForPositionalArg("component", "Choose component", componentCompletion, cmd, args)
        if err != nil {
            return err
        }
        args = []string{component}
    }

    stack := v.GetString("stack")
    if stack == "" {
        stack, err := flags.PromptForMissingRequired("stack", "Choose stack", stackCompletion, cmd, args)
        if err != nil {
            return err
        }
        v.Set("stack", stack)
    }

    return ExecuteProvisionCommand(cmd, args, createParser, "backend.create")
}
```

**Why this is wrong:**
- Duplicates logic already in StandardParser
- Doesn't follow the command registry pattern
- Harder to test
- Inconsistent with other commands

## The Issue with Backend Commands

Currently, backend commands:
1. Use `cobra.ExactArgs(1)` which errors BEFORE StandardParser runs
2. Call `ParseCommonFlags()` which returns `ErrRequiredFlagNotProvided` when stack is missing

**Fix:**
1. Remove `cobra.ExactArgs(1)` validation
2. Use `flags.Parse()` instead of just `ParseCommonFlags()`
3. Add `WithPositionalArgPrompt()` and `WithCompletionPrompt()` to the parser
4. Let StandardParser handle validation AND prompting

## Recommended Implementation Steps

1. **Update `cmd/terraform/backend/create.go`:**
   - Remove `Args: cobra.ExactArgs(1)`
   - Change to `Args: cobra.NoArgs` (let StandardParser validate)
   - Define positional args using `PositionalArgsBuilder`
   - Add `WithPositionalArgPrompt("component", ...)` to parser
   - Add `WithCompletionPrompt("stack", ...)` to parser
   - Call `createParser.Parse(args)` in RunE
   - Extract component from `result.PositionalArgs[0]`

2. **Update `cmd/terraform/backend/update.go`:** Same changes

3. **Update `cmd/terraform/backend/delete.go`:** Same changes

4. **Update `cmd/terraform/backend/describe.go`:**
   - Same pattern but component is optional
   - Use `required=false` in AddArg

5. **Update `backend_helpers.go`:**
   - `ParseCommonFlags()` should NOT return error for missing stack
   - Let StandardParser handle validation
   - OR: Create `ParseCommonFlagsWithPrompting()` that calls `parser.Parse()`

## Key Differences: Backend Commands vs. Terraform Commands

| Aspect | Terraform plan/apply/destroy | Backend create/delete |
|--------|------------------------------|----------------------|
| **Execution** | Legacy `ProcessCommandLineArgs()` | Direct execution |
| **Component** | Extracted in `processArgsAndFlags()` | Positional arg |
| **Stack** | Flag via Viper | Flag via Viper |
| **Prompting** | NOT implemented (legacy code) | Should use StandardParser |
| **Pattern** | Old (pre-StandardParser) | New (modern) |

## Answer to Your Questions

1. **How do other terraform commands implement auto-prompting?**
   - They DON'T. The legacy terraform commands (plan/apply/destroy) use `processArgsAndFlags()` which doesn't support prompting yet.
   - Auto-prompting is a **new feature** that exists in StandardParser but hasn't been applied to legacy commands.

2. **What is the correct pattern using the flag handler infrastructure?**
   - Use `StandardParser` with `WithPositionalArgPrompt()` and `WithCompletionPrompt()`
   - Call `parser.Parse(args)` in RunE
   - Let StandardParser handle both validation AND prompting

3. **Is there a standard way via command registry / flag handler?**
   - YES: The StandardParser pattern (Option 1 above)
   - See `cmd/theme/show.go` for a reference implementation with positional arg prompting

## Reference Implementations

- **Positional arg prompting:** `cmd/theme/show.go`
- **Optional value flag prompting:** Auth commands with `--identity` flag
- **Required flag prompting:** Look for `WithCompletionPrompt()` usage

## Next Steps

If you want to implement auto-prompting for backend commands, use **Option 1** above. This is the modern, recommended approach that:
- Follows the command registry pattern
- Uses StandardParser correctly
- Is testable
- Is consistent with future Atmos architecture
