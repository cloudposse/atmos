---
slug: stack-manifest-name-override
title: Multi-Format Stack Configurations with Explicit Naming
authors:
  - osterman
tags:
  - feature
date: 2025-12-03T00:00:00.000Z
---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

You can now specify explicit stack names in both YAML and HCL stack manifests. HCL stacks use a labeled block syntax (`stack "name" { }`), while YAML stacks use a `name` field. This is especially useful when migrating from other tools like Terragrunt, or when your infrastructure doesn't follow a strict naming convention.

<!--truncate-->

## What's New

Stack manifests now support explicit stack naming in both formats:

- **YAML**: Add a top-level `name` field
- **HCL**: Use a labeled `stack` block: `stack "my-name" { }`

Both approaches take precedence over `name_template` and `name_pattern` configured in `atmos.yaml`, giving you imperative control over stack naming when you need it.

## The Problem

Atmos typically derives stack names from either:
- **`name_template`** - A Go template that computes the name from context variables
- **`name_pattern`** - A token-based pattern like `{tenant}-{environment}-{stage}`
- **Default** - The basename of the stack file (zero-config)

These declarative approaches work well for greenfield projects with consistent naming conventions. However, they can be challenging when:

- Migrating legacy infrastructure that predates your naming conventions
- Adopting infrastructure from acquisitions with different naming schemes
- Migrating from tools like Terragrunt where stack organization differs
- Working with infrastructure that simply doesn't fit a pattern

## The Solution

Add an explicit name to any stack manifest to set its logical name.

### YAML Format

Use a top-level `name` field:

```yaml
# stacks/legacy-prod.yaml
name: "my-legacy-prod-stack"

import:
  - catalog/base

components:
  terraform:
    vpc:
      vars:
        cidr: "10.0.0.0/16"
```

### HCL Format

Use a labeled `stack` block:

```hcl
# stacks/legacy-prod.hcl
stack "my-legacy-prod-stack" {
  import = ["catalog/base"]

  components {
    terraform {
      vpc {
        vars {
          cidr = "10.0.0.0/16"
        }
      }
    }
  }
}
```

With either configuration, the stack is identified as `my-legacy-prod-stack` regardless of the filename or any naming patterns configured in `atmos.yaml`. The Terraform workspace will also use this name.

:::tip HCL without label
A `stack { }` block without a label is also valid - in that case, the stack name will be derived from `name_template`, `name_pattern`, or the filename as usual.
:::

## Precedence Order

Stack names are now resolved in this order:

1. **`name`** (highest) - Explicit name from stack manifest
2. **`name_template`** - Go template from `atmos.yaml`
3. **`name_pattern`** - Token pattern from `atmos.yaml`
4. **Default** - Basename of the stack file

This means you can still use `name_template` or `name_pattern` for most stacks while selectively overriding specific stacks that don't fit the pattern.

## Multiple Stacks Per File

Both HCL and YAML formats support defining multiple stacks in a single file.

### HCL: Multiple Stack Blocks

Define multiple labeled `stack` blocks in a single HCL file:

```hcl
# stacks/environments.hcl
stack "dev" {
  import = ["catalog/base"]

  vars {
    environment = "dev"
    stage       = "development"
  }

  components {
    terraform {
      vpc {
        vars {
          cidr = "10.10.0.0/16"
        }
      }
    }
  }
}

stack "staging" {
  import = ["catalog/base"]

  vars {
    environment = "staging"
    stage       = "staging"
  }

  components {
    terraform {
      vpc {
        vars {
          cidr = "10.20.0.0/16"
        }
      }
    }
  }
}
```

### YAML: Multi-Document Format

Use the YAML multi-document separator (`---`) to define multiple stacks:

```yaml
# stacks/environments.yaml
name: dev
import:
  - catalog/base

vars:
  environment: dev
  stage: development

components:
  terraform:
    vpc:
      vars:
        cidr: "10.10.0.0/16"
---
name: staging
import:
  - catalog/base

vars:
  environment: staging
  stage: staging

components:
  terraform:
    vpc:
      vars:
        cidr: "10.20.0.0/16"
```

Both examples create two stacks (`dev` and `staging`) from a single file, making it easier to manage related environments together.

## Use Cases

### Migrating from Terragrunt

When migrating from Terragrunt, your existing state files are tied to specific workspace names that may not match Atmos naming conventions:

<Tabs>
  <TabItem value="yaml" label="YAML" default>

```yaml
# stacks/us-east-1/prod/vpc.yaml
name: "prod-us-east-1-vpc"  # Matches existing Terraform workspace

import:
  - catalog/vpc

components:
  terraform:
    vpc:
      vars:
        cidr: "10.0.0.0/16"
```

  </TabItem>
  <TabItem value="hcl" label="HCL">

```hcl
# stacks/us-east-1/prod/vpc.hcl
stack "prod-us-east-1-vpc" {  # Matches existing Terraform workspace
  import = ["catalog/vpc"]

  components {
    terraform {
      vpc {
        vars {
          cidr = "10.0.0.0/16"
        }
      }
    }
  }
}
```

  </TabItem>
</Tabs>

### Legacy Infrastructure

For infrastructure that predates your naming standards:

```yaml
# stacks/old-datacenter.yaml
name: "dc1-legacy-infra"  # Historical name that must be preserved

components:
  terraform:
    network:
      vars:
        vpc_id: "vpc-abc123"
```

### Acquisitions

When integrating acquired infrastructure:

```yaml
# stacks/acme-corp-prod.yaml
name: "acme-production"  # Keep their original naming

import:
  - catalog/base

components:
  terraform:
    vpc:
      metadata:
        component: vpc
```

## How It Works

The explicit stack name (from the YAML `name` field or HCL block label) is extracted during stack processing and used wherever the logical stack name is needed:

- **Stack identification** - `atmos describe stacks` shows the custom name
- **Stack selection** - Use `-s my-legacy-prod-stack` on the command line
- **Terraform workspace** - Workspace name derives from the stack name
- **Dependencies** - Reference stacks by their logical name in `depends_on`

## Comparison with Component metadata.name

This feature is analogous to `metadata.name` for components, which allows renaming component instances. Just as `metadata.name` lets you control how a component is identified, the stack-level `name` field lets you control how a stack is identified.

| Level | Field | Purpose |
|-------|-------|---------|
| Component | `metadata.name` | Override component instance name |
| Stack | `name` | Override logical stack name |

## Related Documentation

- [Stack Names](/stacks/name)
- [Stack Configuration](/stacks)
- [Terraform Workspaces](/components/terraform/workspaces)

## Get Started

Add an explicit name to any stack manifest that needs one:
- **YAML**: Add a `name` field
- **HCL**: Use a labeled `stack "name" { }` block

This feature is fully backward compatible - stacks without explicit names continue to use `name_template`, `name_pattern`, or the filename as before.
