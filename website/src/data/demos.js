/**
 * Demo video configuration for the Atmos Demos Gallery.
 *
 * Videos are organized into categories and displayed in a YouTube-style grid.
 * Categories and demos are built dynamically from manifest.json which contains
 * gallery metadata (category, title, order) along with video URLs and durations.
 *
 * Manifest data is imported from manifest.json which contains:
 * - Gallery metadata (category, title, order) from scenes.yaml
 * - Stream thumbnail URLs (auto-generated by Cloudflare Stream)
 * - Actual video durations (calculated from MP4 files)
 * - Video UIDs for playback
 */

import manifest from './manifest.json';

// Category definitions (display order and metadata only)
// Demos are populated dynamically from manifest based on category field
const categoryDefinitions = [
  { id: 'terraform', title: 'Terraform Commands', description: 'Execute Terraform operations across your infrastructure' },
  { id: 'list', title: 'List Commands', description: 'Explore and discover your infrastructure' },
  { id: 'workflows', title: 'Workflows & Automation', description: 'Automate multi-step infrastructure operations' },
  { id: 'dx', title: 'Developer Experience', description: 'Tools and features for a great developer experience' },
  { id: 'auth', title: 'Authentication', description: 'Secure credential management for cloud providers' },
  { id: 'config', title: 'Configuration & Validation', description: 'Advanced configuration features and validation' },
  { id: 'flagship', title: 'End-to-End Workflows', description: 'Complete workflows showcasing Atmos capabilities' },
];

// Build a lookup map from manifest for quick access
const manifestScenes = {};
for (const scene of manifest.scenes || []) {
  manifestScenes[scene.name] = scene;
}

// Helper to format duration in seconds to display string
function formatDuration(seconds) {
  if (!seconds || seconds <= 0) return null;
  const rounded = Math.round(seconds);
  if (rounded < 60) {
    return `${rounded}s`;
  }
  const mins = Math.floor(rounded / 60);
  const secs = rounded % 60;
  return secs > 0 ? `${mins}m ${secs}s` : `${mins}m`;
}

// Helper to get duration from manifest
function getManifestDuration(demoId) {
  const scene = manifestScenes[demoId];
  if (scene?.formats?.mp4?.duration) {
    return formatDuration(scene.formats.mp4.duration);
  }
  return null;
}

// Helper to check if a scene has video (not a placeholder)
function hasVideo(demoId) {
  const scene = manifestScenes[demoId];
  return scene?.formats?.mp4?.uid != null;
}

// Build categories dynamically from manifest
export const demoCategories = categoryDefinitions
  .map(cat => ({
    ...cat,
    demos: Object.values(manifestScenes)
      .filter(scene => scene.category === cat.id)
      .sort((a, b) => (a.order || 999) - (b.order || 999))
      .map(scene => ({
        id: scene.name,
        title: scene.title || scene.name,
        description: scene.description || '',
        isPlaceholder: !hasVideo(scene.name),
        get duration() {
          return getManifestDuration(scene.name);
        },
      }))
  }))
  .filter(cat => cat.demos.length > 0);

// Base URL for demo assets (Cloudflare R2 fallback)
export const DEMO_ASSETS_BASE_URL = 'https://demos.atmos.tools';

// Stream subdomain from manifest
export const STREAM_SUBDOMAIN = manifest.subdomain || '';

// Helper to get asset URLs for a demo
// Uses Stream thumbnail when available, falls back to R2 PNG
export function getDemoAssetUrls(demoId) {
  const scene = manifestScenes[demoId];
  const mp4Format = scene?.formats?.mp4;

  // Check if scene has any formats (not a placeholder)
  const hasFormats = scene?.formats && Object.keys(scene.formats).length > 0;

  // Use Stream thumbnail if available, R2 fallback for published, null for placeholders
  const thumbnail = mp4Format?.thumbnail
    || (hasFormats ? `${DEMO_ASSETS_BASE_URL}/${demoId}.png` : null);

  // Use Stream URL if available
  const mp4Url = mp4Format?.url || (hasFormats ? `${DEMO_ASSETS_BASE_URL}/${demoId}.mp4` : null);

  return {
    gif: hasFormats ? `${DEMO_ASSETS_BASE_URL}/${demoId}.gif` : null,
    png: thumbnail,
    mp4: mp4Url,
    thumbnail: thumbnail,
    streamUid: mp4Format?.uid || null,
  };
}

// Get all demos as a flat list
export function getAllDemos() {
  return demoCategories.flatMap(category =>
    category.demos.map(demo => ({
      ...demo,
      duration: demo.duration, // Trigger getter
      categoryId: category.id,
      categoryTitle: category.title,
    }))
  );
}

// Get demo by ID
export function getDemoById(id) {
  for (const category of demoCategories) {
    const demo = category.demos.find(d => d.id === id);
    if (demo) {
      return {
        ...demo,
        duration: demo.duration, // Trigger getter
        categoryId: category.id,
        categoryTitle: category.title,
      };
    }
  }
  return null;
}

// Get manifest data for a demo
export function getManifestData(demoId) {
  return manifestScenes[demoId] || null;
}

// Get demos by tag (e.g., 'featured')
export function getDemosByTag(tag) {
  return Object.values(manifestScenes)
    .filter(scene => scene.tags?.includes(tag) && hasVideo(scene.name))
    .map(scene => {
      const category = categoryDefinitions.find(c => c.id === scene.category);
      return {
        id: scene.name,
        title: scene.title || scene.name,
        description: scene.description || '',
        categoryId: scene.category,
        categoryTitle: category?.title || scene.category,
        get duration() {
          return getManifestDuration(scene.name);
        },
      };
    });
}

// Featured demos for the landing page carousel
export const FEATURED_DEMOS = getDemosByTag('featured');
