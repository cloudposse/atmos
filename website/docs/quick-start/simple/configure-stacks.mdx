---
title: Use Your Component in a Stack
sidebar_position: 4
sidebar_label: 4. Configure with Stacks
---
import File from '@site/src/components/File'
import KeyPoints from '@site/src/components/KeyPoints'
import Intro from '@site/src/components/Intro'
import EmbedFile from '@site/src/components/EmbedFile'

<Intro>
[Atmos Stacks](/core-concepts/stacks) are the configuration for your components. It's how you can combine multiple reusable, stateful
components into your "Stack" that you depend on.
</Intro>

If you think of your "components" as applications, then Stacks are simply which components you depend on and the settings that you want
to pass to them. If you make your components highly reusable, it usually means they will need to accept a lot of configuration.

**This is what makes Atmos so powerful:** you can import and inherit configurations in a logical way to keep your configurations DRY and consistent.

<KeyPoints>
- How to specify the configuration for your Terraform "root modules" using Atmos Stacks
- How to organize Atmos Stacks into a Service Catalog
- How to use imports and inheritance for DRY configurations
- How Atmos identifies components using context variables and naming patterns
</KeyPoints>

Stack configurations are merely all the settings for your components. They can be organized in any way you like, but we recommend a hierarchical layout. We share some [different ways to organize your stacks in the Catalog](/core-concepts/stacks/catalogs), but for this example, we will use a simple layout.

## Create Catalog for Reusable Configurations

Atmos supports the concept of a [Service Catalog](/core-concepts/stacks/catalogs), which is where you can define all
of your default configurations.

All the common default settings for each Atmos component should be in a separate file in the `stacks/catalog` directory.
The file then gets imported into the parent Atmos stacks. This makes the stack configurations DRY by reusing the component's config that is common for all environments.

Refer to [Stack Imports](/core-concepts/stacks/imports) for more details on Atmos imports.

These Atmos component manifests will be imported into the top-level Atmos stacks. The default variables (in the `vars` sections)
can be overridden in the derived Atmos components by using [Atmos Component Inheritance](/core-concepts/stacks/inheritance).

## Atmos Top-level Stacks

When executing the [CLI commands](/cheatsheets/commands), Atmos does not use the stack file names and their filesystem locations to search for the stack where the component is defined. Instead, Atmos uses the context variables (`namespace`, `tenant`, `environment`, `stage`) to search for the stack. The stack config file names (stack manifest names) can be anything, and they can be in any folder in any sub-folder in the `stacks` directory.

For example, when executing the `atmos terraform apply vpc -s plat-ue2-dev`
command, the Atmos stack `plat-ue2-dev` is specified by the `-s` flag. By looking at `name_pattern: "{tenant}-{environment}-{stage}"`
(see [Configure CLI](/quick-start/advanced/configure-cli)) and processing the tokens, Atmos knows that the first part of the stack name is `tenant`, the second
part is `environment`, and the third part is `stage`. Then Atmos searches for the top-level stack manifest (in the `stacks` directory)
where `tenant: plat`, `environment: ue2` and `stage: dev` are defined (inline or via imports).

Atmos top-level stacks can be configured using a Basic Layout or a Hierarchical Layout.

The Basic Layout can be used when you have a very simple configuration using just a few accounts and regions.
The Hierarchical Layout should be used when you have a very complex organization, for example, with many AWS Organizational Units (which Atmos
refers to as tenants) and dozens of AWS accounts and regions.

### Basic Layout

A basic form of stack organization is to follow the pattern of naming where each `$environment-$stage.yaml` is a file. This works well until you have so many environments and stages.

For example, `$stage` might be `prod` which would result in `stacks/deploy/prod.yaml`

In our example, the filesystem layout for the stacks is using a Basic Layout with `dev`, `staging` and `prod` and
would look like this:

<File title="infra-live/" icon="fa-solid fa-folder">
```console
├── atmos.yaml
├── components/
│   └── terraform/
│       └── myapp/
│           ├── README.md
│           ├── main.tf
│           ├── outputs.tf
│           ├── variables.tf
│           └── versions.tf
│ 
│   # Centralized stacks configuration
└── stacks/
    ├── catalog/
    │   └── myapp.yaml
    └── deploy/
        ├── dev.yaml
        ├── prod.yaml
        └── staging.yaml
```
</File>

## Create Stack Configurations for Deployment

Although in this Quick Start guide, we use just a single Terraform component, in a real-world scenario, you might have dozens of components. Rest assured, the process is the same for all components.

Create the following filesystem layout (which will be the final layout for this Simple Quick Start guide):

When Atmos processes this stack config, it will import and deep-merge all the variables defined in the imported files and inline. All imports are processed in the order they are defined.


<EmbedFile filePath="examples/demo-stacks/stacks/catalog/myapp.yaml" />

<EmbedFile filePath="examples/demo-stacks/stacks/deploy/dev.yaml" />

<EmbedFile filePath="examples/demo-stacks/stacks/deploy/staging.yaml" />

<EmbedFile filePath="examples/demo-stacks/stacks/deploy/prod.yaml" />

