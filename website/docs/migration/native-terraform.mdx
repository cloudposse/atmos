---
title: Migrating from Native Terraform
sidebar_position: 3
sidebar_label: From Native Terraform
description: How to migrate from vanilla Terraform to Atmos
id: native-terraform
---
import File from '@site/src/components/File'
import Intro from '@site/src/components/Intro'
import Terminal from '@site/src/components/Terminal'

<Intro>
You're already 90% there. Your Terraform code doesn't need to change. Atmos gives you a documented, conventional way to manage your infrastructure‚Äîwhether you're using Makefiles, shell scripts, or just raw Terraform commands.
</Intro>

## Why This Guide?

Let's be honest: nobody uses "pure" Terraform. You're probably already using:
- **Makefiles** to wrap common commands
- **Shell scripts** to set variables or loop through environments
- **GitHub Actions/Jenkins** with custom bash scripting
- **Directory structures** to separate dev/staging/prod
- **`.tfvars` files** scattered everywhere

Tool fatigue is real. Instead of duct-taping 25 different tools together, Atmos gives you one documented approach.

## Crawl, Walk, Run

**Crawl**: Get running in 20 minutes (this guide)
**Walk**: Explore DRY configs and remote state
**Run**: Advanced features when you need them (workflows, validation, component libraries)

You don't need to learn everything on day one. Get value in 20 minutes, not 20 hours.

---

## Crawl: Get Running in 20 Minutes

### What You're Going To Do

1. Install Atmos
2. Create a minimal `atmos.yaml`
3. Create one stack YAML file
4. Run `atmos terraform plan`

That's it. You'll be using Atmos.

### Step 1: Install Atmos

<Terminal>
```bash
# macOS
brew install atmos

# Linux/Windows - see installation docs
```
</Terminal>

### Step 2: Create Minimal atmos.yaml

Assuming your Terraform code is in `terraform/` or `modules/`:

<File title="atmos.yaml">
```yaml
components:
  terraform:
    base_path: "components/terraform"  # Where your Terraform root modules live

stacks:
  base_path: "stacks"                  # Where your stack configs will go
  name_pattern: "{stage}"              # Simple naming: dev, staging, prod
```
</File>

:::tip
If your Terraform code is already in a `terraform/` directory, just set `base_path: "terraform"`.
:::

### Step 3: Move Your Terraform Code

If your Terraform is in scattered directories, consolidate it:

**Before:**
```
terraform/
  dev/
    main.tf
    vpc.tfvars
  prod/
    main.tf
    vpc.tfvars
```

**After:**
```
components/terraform/vpc/
  main.tf
  variables.tf
  outputs.tf
```

Your Terraform code stays **exactly the same**. You're just organizing it.

### Step 4: Create Your First Stack

Create a stack YAML file for one environment:

<File title="stacks/dev.yaml">
```yaml
components:
  terraform:
    vpc:
      vars:
        cidr_block: "10.0.0.0/16"
        environment: dev
        enable_dns_hostnames: true
```
</File>

If you were using a `.tfvars` file before, just convert it to YAML under `vars:`.

**Before (vpc.tfvars):**
```hcl
cidr_block           = "10.0.0.0/16"
environment          = "dev"
enable_dns_hostnames = true
```

**After (stacks/dev.yaml):**
```yaml
components:
  terraform:
    vpc:
      vars:
        cidr_block: "10.0.0.0/16"
        environment: dev
        enable_dns_hostnames: true
```

### Step 5: Run Atmos

<Terminal>
```bash
# Instead of: cd terraform/dev && terraform plan -var-file=vpc.tfvars
atmos terraform plan vpc -s dev

# Instead of: cd terraform/dev && terraform apply -var-file=vpc.tfvars
atmos terraform apply vpc -s dev
```
</Terminal>

**Congratulations!** You're now using Atmos. üéâ

---

## What Just Happened?

### Key Differences at a Glance

| Aspect | Native Terraform | Atmos |
|--------|------------------|-------|
| **Terraform Code** | `main.tf`, `variables.tf` | ‚úÖ Same - no changes needed |
| **Configuration** | `.tfvars` files, TF_VAR_ env vars | YAML `vars:` (but .tfvars still work!) |
| **Environments** | Directories or workspaces | Stack YAML files |
| **Backend Config** | In Terraform code | Centralized in stack config |
| **Commands** | `terraform plan -var-file=...` | `atmos terraform plan <component> -s <stack>` |
| **Querying** | Bash scripts, grep | `atmos list stacks`, `atmos describe component` |

### What Stays The Same ‚úÖ

- ‚úÖ **Your Terraform code** works as-is
- ‚úÖ **Your `.tfvars` files** still work (Atmos can generate them)
- ‚úÖ **Your `TF_VAR_` environment variables** still work
- ‚úÖ **Your backend configuration** migrates cleanly

### What You Added

- ‚úÖ `atmos.yaml` - tells Atmos where your code lives
- ‚úÖ Stack YAML files - one per environment

That's it. This is the "entry fee" for all the benefits below.

---

## Walk: Immediate Value

Now that you're running Atmos, here's what you get **immediately**:

### 1. List Your Infrastructure

No more bash scripts or mental mapping:

<Terminal>
```bash
# See all your stacks
atmos list stacks

# See all components
atmos list components

# Describe a component in a stack
atmos describe component vpc -s dev
```
</Terminal>

### 2. DRY Configuration

Instead of copying `.tfvars` files, use YAML inheritance:

<File title="stacks/_defaults.yaml">
```yaml
components:
  terraform:
    vpc:
      vars:
        enable_dns_hostnames: true
        enable_dns_support: true
```
</File>

<File title="stacks/dev.yaml">
```yaml
import:
  - _defaults

components:
  terraform:
    vpc:
      vars:
        cidr_block: "10.0.0.0/16"
        environment: dev
```
</File>

<File title="stacks/prod.yaml">
```yaml
import:
  - _defaults

components:
  terraform:
    vpc:
      vars:
        cidr_block: "10.1.0.0/16"
        environment: prod
```
</File>

Shared settings live in `_defaults.yaml`. Each environment only specifies what's different.

### 3. Query Remote State

Pull outputs from other components without custom bash:

<File title="stacks/dev.yaml">
```yaml
components:
  terraform:
    eks:
      vars:
        vpc_id: '{{ (atmos.Component "vpc" .stack).outputs.vpc_id }}'
        subnet_ids: '{{ (atmos.Component "vpc" .stack).outputs.private_subnet_ids }}'
```
</File>

Or use the Terraform module:

<File title="components/terraform/eks/remote_state.tf">
```hcl
module "vpc" {
  source  = "cloudposse/stack-config/yaml//modules/remote-state"
  version = "1.5.0"

  component = "vpc"
  context   = module.this.context
}

# Use: module.vpc.outputs.vpc_id
```
</File>

### 4. Centralized Backend

Stop managing backend config in every directory:

<File title="stacks/dev.yaml">
```yaml
terraform:
  backend_type: s3
  backend:
    s3:
      bucket: my-terraform-state
      key: "terraform.tfstate"
      region: us-east-1
      dynamodb_table: terraform-lock

components:
  terraform:
    vpc:
      vars:
        cidr_block: "10.0.0.0/16"
```
</File>

Atmos auto-generates `backend.tf.json` for you.

---

## Run: When You're Ready

These advanced features are there when you need them. You don't need them now.

### Workflows (Replace Your Makefiles)

<File title="stacks/workflows/deploy.yaml">
```yaml
name: deploy-dev
steps:
  - command: terraform plan vpc -s dev
  - command: terraform apply vpc -s dev
  - command: terraform plan eks -s dev
  - command: terraform apply eks -s dev
```
</File>

<Terminal>
```bash
atmos workflow deploy-dev -f stacks/workflows/deploy.yaml
```
</Terminal>

### Validation with OPA and JSON Schema

Validate your configurations before running Terraform:

<Terminal>
```bash
atmos validate stacks
atmos validate component vpc -s dev
```
</Terminal>

### Component Inheritance

Reuse component configurations:

<File title="stacks/catalog/vpc-defaults.yaml">
```yaml
components:
  terraform:
    vpc-defaults:
      metadata:
        type: abstract  # Can't be deployed directly
      vars:
        enable_dns_hostnames: true
        enable_dns_support: true
```
</File>

<File title="stacks/dev.yaml">
```yaml
components:
  terraform:
    vpc:
      metadata:
        component: vpc
        inherits:
          - vpc-defaults
      vars:
        cidr_block: "10.0.0.0/16"
```
</File>

---

## Real Example: 20-Minute Migration

### Before (Native Terraform)

```
terraform/
  dev/
    main.tf
    variables.tf
    outputs.tf
    vpc.tfvars
    backend.tf
  staging/
    main.tf
    variables.tf
    outputs.tf
    vpc.tfvars
    backend.tf
  prod/
    main.tf
    variables.tf
    outputs.tf
    vpc.tfvars
    backend.tf
```

**Commands:**
```bash
cd terraform/dev
terraform plan -var-file=vpc.tfvars
terraform apply -var-file=vpc.tfvars
```

### After (Atmos) - 20 Minutes Later

```
atmos.yaml
components/terraform/vpc/
  main.tf          # Same code, no changes
  variables.tf     # Same code, no changes
  outputs.tf       # Same code, no changes
stacks/
  dev.yaml         # Replaces dev/vpc.tfvars + backend.tf
  staging.yaml     # Replaces staging/vpc.tfvars + backend.tf
  prod.yaml        # Replaces prod/vpc.tfvars + backend.tf
```

<File title="atmos.yaml">
```yaml
components:
  terraform:
    base_path: "components/terraform"

stacks:
  base_path: "stacks"
  name_pattern: "{stage}"
```
</File>

<File title="stacks/dev.yaml">
```yaml
terraform:
  backend_type: s3
  backend:
    s3:
      bucket: my-terraform-state
      key: "dev/vpc/terraform.tfstate"
      region: us-east-1

components:
  terraform:
    vpc:
      vars:
        cidr_block: "10.0.0.0/16"
        environment: dev
```
</File>

**Commands:**
```bash
atmos terraform plan vpc -s dev
atmos terraform apply vpc -s dev
```

---

## Why It's Worth It

### Stop Duct-Taping Tools Together

Instead of:
- Makefiles + shell scripts + GitHub Actions + custom bash + .tfvars + workspaces

You get:
- **One documented approach** with Atmos

### Real Benefits You'll Feel Immediately

- ‚úÖ **Documented convention** - Not tribal knowledge
- ‚úÖ **Reduced cognitive load** - Follow patterns, don't reinvent
- ‚úÖ **Easier onboarding** - New team members productive in 20 minutes
- ‚úÖ **Query infrastructure** - `atmos list stacks` instead of bash/grep
- ‚úÖ **DRY configs** - Inheritance without copy-paste
- ‚úÖ **Workflows** - Replace your Makefiles
- ‚úÖ **Separation of concerns** - Terraform is code, YAML is configuration

### What It Transforms

- ‚ùå **Before**: "Let me grep through directories to find where we deploy the VPC in staging"
- ‚úÖ **After**: `atmos describe component vpc -s staging`

- ‚ùå **Before**: "New developer? Here's 45 minutes of tribal knowledge about our Makefile"
- ‚úÖ **After**: "Read the stack YAML, run `atmos terraform plan`, you're good"

- ‚ùå **Before**: Custom bash scripts to pull remote state
- ‚úÖ **After**: `{{ (atmos.Component "vpc" .stack).outputs.vpc_id }}`

---

## What Atmos Won't Do

Let's be honest:

- ‚ùå **Won't magically refactor your existing Terraform** - Atmos doesn't provide automated refactoring tools
- ‚ùå **Won't fix monolithic modules** - That's still on you
- ‚ùå **Won't require you to learn everything** - Start with basics, grow as needed

**But:**

- ‚úÖ **Everything new you build will follow glorious conventions**
- ‚úÖ **You can gradually refactor existing stuff as you see fit**
- ‚úÖ **It's going to transform your day-to-day**
- ‚úÖ **You're just going to fall in love with it** ‚ù§Ô∏è

---

## Working with .tfvars Files

### Option 1: Keep Using .tfvars (Transitional)

Atmos can work with your existing `.tfvars` files while you migrate:

<File title="stacks/dev.yaml">
```yaml
components:
  terraform:
    vpc:
      command: "/usr/bin/terraform"
      vars:
        # Variables defined here
```
</File>

Atmos auto-generates `.auto.tfvars.json` from your `vars:` section.

### Option 2: Migrate to YAML (Recommended)

Just convert your `.tfvars` to YAML:

**Before (vpc.tfvars):**
```hcl
cidr_block           = "10.0.0.0/16"
enable_dns_hostnames = true
tags = {
  Environment = "dev"
  Team        = "platform"
}
```

**After (stacks/dev.yaml):**
```yaml
components:
  terraform:
    vpc:
      vars:
        cidr_block: "10.0.0.0/16"
        enable_dns_hostnames: true
        tags:
          Environment: dev
          Team: platform
```

---

## Working with TF_VAR_ Environment Variables

Atmos supports Terraform's native environment variable pattern:

<File title="stacks/dev.yaml">
```yaml
components:
  terraform:
    vpc:
      env:
        TF_VAR_region: us-east-1
        TF_VAR_environment: dev
      vars:
        cidr_block: "10.0.0.0/16"
```
</File>

When you run `atmos terraform plan vpc -s dev`, these environment variables are set automatically.

---

## Migration Checklist

- [ ] Install Atmos CLI
- [ ] Create `atmos.yaml` pointing to your Terraform code
- [ ] Reorganize Terraform code into `components/terraform/<component>/`
- [ ] Create your first stack YAML (start with dev)
- [ ] Test with `atmos terraform plan <component> -s dev`
- [ ] Create remaining stack files (staging, prod)
- [ ] (Optional) Migrate `.tfvars` to YAML
- [ ] (Optional) Set up workflows to replace Makefiles
- [ ] (Optional) Explore DRY configs with imports

---

## Next Steps

**You just did Crawl** - you're running Atmos! üéâ

**Walk**: Explore these next:
- [DRY Configuration with Imports](/core-concepts/inheritance-basics)
- [Remote State Integration](/core-concepts/share-data/remote-state)
- [Component Catalogs](/stacks/catalogs)

**Run**: When you're ready for advanced features:
- [Workflows](/workflows)
- [Validation with OPA](/validation/validating)
- [Vendoring Components](/vendoring/vendor)

---

## Common Questions

### Do I need to change my Terraform code?

**No.** Your Terraform root modules work as-is. Atmos wraps them with orchestration.

### Can I keep using .tfvars files?

**Yes.** Atmos can generate `.auto.tfvars.json` from your stack YAML, but you can also keep using existing `.tfvars` files during migration.

### Can I keep using TF_VAR_ environment variables?

**Yes.** Define them in the `env:` section of your stack YAML, and Atmos will set them when running Terraform.

### Do I need to learn everything at once?

**No.** Start with the basics (this guide). Advanced features are there when you need them.

### What if I'm using Terraform workspaces?

See the [Migrating from Terraform Workspaces](/migration/terraform-workspaces) guide.

### What if I'm using Terragrunt?

See the [Migrating from Terragrunt](/migration/terragrunt) guide.
