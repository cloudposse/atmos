---
title: Locals Patterns
sidebar_position: 1
sidebar_label: Overview
description: Design patterns for using locals to reduce repetition and build computed values
slug: /design-patterns/locals-patterns
---
import PillBox from '@site/src/components/PillBox'
import Intro from '@site/src/components/Intro'

<PillBox>Atmos Design Patterns</PillBox>

<Intro>
Locals patterns show how to use file-scoped variables to reduce repetition, build computed values, and maintain consistency within stack manifests.
</Intro>

## What Are Locals?

Locals are file-scoped variables that exist only during stack processing. Unlike `vars` (which become Terraform variables) or `settings` (which configure Atmos behavior), locals are intermediate values used to build other configuration.

**Key characteristics:**
- **File-scoped**: Locals defined in one file cannot be accessed from other files
- **Template-powered**: Use Go templates to reference other locals, settings, vars, and env
- **Not inherited**: Locals don't participate in stack inheritance
- **Stripped from output**: Locals are resolved during processing and don't appear in final component configuration

## When to Use Locals

| Scenario | Use Locals? | Alternative |
|----------|-------------|-------------|
| Build a value from other values in the same file | Yes | - |
| Share a value across files | No | Use `vars` or `settings` |
| Reduce repetition within a file | Yes | - |
| Pass configuration to Terraform | No | Use `vars` |
| Configure Atmos behavior | No | Use `settings` |

## Available Patterns

| Pattern | Purpose |
|---------|---------|
| [Computed Values](/design-patterns/locals-patterns/computed-values) | Build complex values from simpler components |
| [Tag Management](/design-patterns/locals-patterns/tag-management) | Centralize resource tagging logic |
| [Naming Conventions](/design-patterns/locals-patterns/naming-conventions) | Enforce consistent resource naming |
| [Conditional Values](/design-patterns/locals-patterns/conditional-values) | Environment-specific computed values |

## Template Context

Locals can reference values from the same file using Go template syntax:

| Reference | Description |
|-----------|-------------|
| `{{ .locals.name }}` | Another local in the same file |
| `{{ .settings.key }}` | Settings defined in the same file |
| `{{ .vars.key }}` | Vars defined in the same file |
| `{{ .env.key }}` | Env values defined in the same file (env section) |
| `{{ env "VAR" }}` | OS environment variables (via Sprig) |

## Basic Example

```yaml
settings:
  team: platform

vars:
  stage: dev

locals:
  # Simple value
  namespace: acme

  # Reference another local
  env_prefix: "{{ .locals.namespace }}-{{ .vars.stage }}"

  # Access settings
  owner: "{{ .settings.team }}"

  # Build computed value
  resource_name: "{{ .locals.env_prefix }}-app"

components:
  terraform:
    myapp:
      vars:
        name: "{{ .locals.resource_name }}"
        owner: "{{ .locals.owner }}"
```

## File-Scoped Isolation

Locals are intentionally scoped to the file where they are defined. This provides:

- **Encapsulation**: Each file manages its own intermediate values
- **No naming conflicts**: The same local name can be used in different files
- **Clear dependencies**: Easy to see what a file needs vs. what it computes

If you need values shared across files, use `vars` or `settings` instead.

## Related Patterns

- [Mixins](/design-patterns/component-catalog/mixins) - Reusable configuration fragments (use vars/settings, not locals)
- [Partial Component Configuration](/design-patterns/configuration-composition/partial-component-configuration) - Split component config across files
- [Inline Configuration](/design-patterns/inline-component-configuration) - Define components directly in stacks

## References

- [Locals](/stacks/locals) - Core concept documentation
- [Stack Templating](/templates) - Go template syntax in stacks
