---
title: Computed Values
sidebar_position: 2
sidebar_label: Computed Values
description: Build complex configuration values from simpler components using locals
id: computed-values
---
import File from '@site/src/components/File'
import PillBox from '@site/src/components/PillBox'
import Intro from '@site/src/components/Intro'

<PillBox>Atmos Design Pattern</PillBox>

<Intro>
**Computed Values** use locals to build complex configuration from simpler components. Instead of repeating compound values, define the building blocks once and compose them.
</Intro>

## Use-cases

Use **Computed Values** when:

- You need to build values from multiple sources (settings, vars, other locals)

- The same computed value is used by multiple components in the same file

- You want to make the relationship between values explicit and maintainable

- Complex string concatenation makes configuration hard to read

## Benefits

- **Single source of truth**: Change the base value, all computed values update automatically

- **Readable configuration**: Named locals explain what values represent

- **Reduced errors**: No risk of typos in repeated compound values

- **Easier refactoring**: Update the computation in one place

## Example: Environment Naming

Build environment-specific names from base components:

<File title="stacks/deploy/dev.yaml">
```yaml
vars:
  stage: dev
  region: us-east-2

locals:
  # Base components
  namespace: acme
  environment: development

  # Computed: combine namespace and environment
  env_prefix: "{{ .locals.namespace }}-{{ .locals.environment }}"

  # Computed: add region for uniqueness
  resource_prefix: "{{ .locals.env_prefix }}-{{ .vars.region }}"

  # Computed: S3 bucket names (must be globally unique)
  logs_bucket: "{{ .locals.resource_prefix }}-logs"
  artifacts_bucket: "{{ .locals.resource_prefix }}-artifacts"

components:
  terraform:
    s3-logs:
      vars:
        bucket_name: "{{ .locals.logs_bucket }}"

    s3-artifacts:
      vars:
        bucket_name: "{{ .locals.artifacts_bucket }}"

    vpc:
      vars:
        name: "{{ .locals.env_prefix }}-vpc"
```
</File>

**Result**: All resources follow consistent naming:
- `acme-development-us-east-2-logs`
- `acme-development-us-east-2-artifacts`
- `acme-development-vpc`

## Example: Dependency Chaining

Locals can reference other locals, enabling step-by-step value construction:

<File title="stacks/deploy/prod.yaml">
```yaml
settings:
  version: v2.1.0

vars:
  stage: prod
  tenant: platform

locals:
  # Step 1: Base namespace
  namespace: acme

  # Step 2: Add tenant context
  tenant_prefix: "{{ .locals.namespace }}-{{ .vars.tenant }}"

  # Step 3: Add stage
  full_prefix: "{{ .locals.tenant_prefix }}-{{ .vars.stage }}"

  # Step 4: Build specific identifiers
  cluster_name: "{{ .locals.full_prefix }}-eks"
  db_identifier: "{{ .locals.full_prefix }}-rds"

  # Step 5: Build ARN patterns
  cluster_arn_prefix: "arn:aws:eks:*:*:cluster/{{ .locals.cluster_name }}"

components:
  terraform:
    eks:
      vars:
        cluster_name: "{{ .locals.cluster_name }}"

    rds:
      vars:
        identifier: "{{ .locals.db_identifier }}"

    iam-policy:
      vars:
        policy_statements:
          - effect: Allow
            actions:
              - eks:DescribeCluster
            resources:
              - "{{ .locals.cluster_arn_prefix }}"
```
</File>

## Example: Conditional Values

Use Go template conditionals for environment-specific computed values:

<File title="stacks/deploy/staging.yaml">
```yaml
vars:
  stage: staging

locals:
  namespace: acme

  # Conditional: staging uses shorter names
  env_suffix: '{{ if eq .vars.stage "prod" }}production{{ else }}{{ .vars.stage }}{{ end }}'

  # Result: "acme-staging" for staging, "acme-production" for prod
  env_name: "{{ .locals.namespace }}-{{ .locals.env_suffix }}"

components:
  terraform:
    app:
      vars:
        environment_name: "{{ .locals.env_name }}"
```
</File>

## Example: Accessing Settings and Vars

Computed values can integrate configuration from multiple sources:

<File title="stacks/deploy/dev.yaml">
```yaml
settings:
  version: v1.2.3
  team: platform

vars:
  stage: dev
  cost_center: engineering

locals:
  namespace: acme

  # Combine settings and vars
  app_identifier: "{{ .locals.namespace }}-{{ .settings.version }}"

  # Build metadata from multiple sources
  description: "{{ .locals.namespace }} {{ .vars.stage }} managed by {{ .settings.team }}"

components:
  terraform:
    app:
      vars:
        identifier: "{{ .locals.app_identifier }}"
        description: "{{ .locals.description }}"
```
</File>

## Anti-patterns

### Avoid: Deeply nested computations

```yaml
# Hard to follow - what does final_name actually contain?
locals:
  a: foo
  b: "{{ .locals.a }}-bar"
  c: "{{ .locals.b }}-baz"
  d: "{{ .locals.c }}-qux"
  final_name: "{{ .locals.d }}-final"
```

**Better**: Use meaningful intermediate names or flatten the computation:

```yaml
locals:
  namespace: foo
  service: bar
  component: baz
  instance: qux
  # Clear what each part represents
  full_name: "{{ .locals.namespace }}-{{ .locals.service }}-{{ .locals.component }}-{{ .locals.instance }}"
```

### Avoid: Locals for simple values used once

```yaml
# Unnecessary - just put the value directly in vars
locals:
  region: us-east-2

components:
  terraform:
    vpc:
      vars:
        region: "{{ .locals.region }}"
```

**Better**: Use locals only when values are computed or reused:

```yaml
vars:
  region: us-east-2

components:
  terraform:
    vpc:
      vars:
        region: "{{ .vars.region }}"
```

## Related Patterns

- [Tag Management](/design-patterns/locals-patterns/tag-management) - Apply computed values to resource tags
- [Naming Conventions](/design-patterns/locals-patterns/naming-conventions) - Standardize naming across resources
- [Inline Configuration](/design-patterns/inline-component-configuration) - Where computed values are typically used

## References

- [Locals](/stacks/locals) - Core concept documentation
- [Stack Templating](/templates) - Go template syntax reference
