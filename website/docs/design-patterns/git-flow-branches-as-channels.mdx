---
title: Git Flow - Branches as Channels
sidebar_position: 25
sidebar_label: Git Flow - Branches as Channels
description: Git Flow Branches as Channels Atmos Design Pattern
---
import File from '@site/src/components/File'
import PillBox from '@site/src/components/PillBox'
import Intro from '@site/src/components/Intro'
import KeyPoints from '@site/src/components/KeyPoints'

<PillBox>Atmos Design Pattern</PillBox>
<Intro>
The **Git Flow: Branches as Channels** Design Pattern adapts the Git Flow branching model for infrastructure versioning. Unlike trunk-based patterns where all environments pull from the main branch, Git Flow uses multiple long-lived branches to represent different release stages, with environments tracking specific branches and promotions happening through merges.
</Intro>

## Understanding Git Flow

Git Flow is a branching model introduced by Vincent Driessen in 2010 that has become widely adopted in software development. It defines a strict branching structure designed around project releases, using multiple parallel long-lived branches.

### Conventional Git Flow Structure

In traditional Git Flow:
- **main/master**: Production-ready code
- **develop**: Integration branch for features
- **feature/\***: Individual feature development
- **release/\***: Release preparation branches

Changes flow through a defined path:
1. Features are developed in feature branches
2. Features merge into develop
3. Release branches are created from develop
4. After testing, releases merge into main and back to develop

### Git Flow for Infrastructure

When applied to infrastructure-as-code, Git Flow needs adaptation because:
- Infrastructure has **persistent state** that doesn't reset between branches
- You can't easily **test infrastructure in isolation** like application code
- **Merge conflicts** in infrastructure often have wider implications
- **Rollback** means reverting infrastructure, not just code

This pattern adapts Git Flow by using branches as deployment channels that environments subscribe to, rather than following the strict feature → develop → release → main flow.

<KeyPoints>
- How Git branches can serve as release channels for infrastructure
- Why merge-based promotion provides clear audit trails
- The trade-offs of long-lived branches for infrastructure code
- Strategies for managing branch divergence and merge conflicts
</KeyPoints>

## Use Cases

Use the **Git Flow: Branches as Channels** pattern when:

- Your team is **already familiar with Git Flow** workflows
- You want **centralized promotion control** through pull requests
- You need **clear audit trails** of what was promoted when
- Your organization requires **approval gates** for promotions
- You prefer **merge-based deployment** workflows
- You have strong **CI/CD integration** with Git events
- You want to **decouple promotion velocity** between environments

## Problem

Traditional Git Flow works well for application development but needs adaptation for infrastructure:

- **State Management**: Infrastructure has persistent state that doesn't reset between branches
- **Testing Challenges**: Can't easily test infrastructure changes in isolation
- **Merge Conflicts**: Infrastructure code often has more structural conflicts
- **Drift Potential**: Long-lived branches can diverge significantly
- **Rollback Complexity**: Reverting merges affects all environments on that branch

Despite these challenges, many teams prefer Git Flow because it provides familiar workflows and strong tooling support.

## Solution

Adapt Git Flow for infrastructure by using branches as release channels that environments subscribe to. Each branch represents a promotion stage, and changes flow through branches via merges.

### Branch Structure

```
main (or master)
  │
  ├── channels/prod        # Production channel
  │     │
  │     ├── channels/staging   # Staging channel
  │           │
  │           └── channels/dev     # Development channel
  │                 │
  │                 └── feature/*  # Feature branches
```

### Channel Branch Strategy

1. **Long-lived Channel Branches**: Create persistent branches for each environment tier
2. **Feature Branches**: Short-lived branches for individual changes
3. **Promotion via Merges**: Advance versions by merging between channel branches
4. **Environment Subscription**: Environments reference channel branches, not tags

## Implementation

### Basic Git Flow Setup

<File title="Branch Structure">
```
Repository Structure:
├── channels/
│   ├── dev         # Development channel (latest changes)
│   ├── staging     # Staging channel (pre-production)
│   └── prod        # Production channel (stable)
├── feature/        # Feature development
└── main           # Source of truth / archive
```
</File>

### Component Vendoring from Branches

With Git Flow, components are vendored from specific branches using `vendor.yaml`. Each environment vendors components from its corresponding channel branch:

<File title="vendor.yaml">
```yaml
spec:
  sources:
    # Vendor VPC from production channel
    - component: vpc
      source: "git::https://github.com/acme/infrastructure.git//components/terraform/vpc?ref=channels/prod"
      targets:
        - "components/terraform/vpc"

    # Vendor EKS from staging for testing
    - component: eks
      source: "git::https://github.com/acme/infrastructure.git//components/terraform/eks?ref=channels/staging"
      targets:
        - "components/terraform/eks"
```
</File>

### Stack Configuration

After vendoring components from the appropriate branches, stacks reference the local vendored components:

<File title="stacks/dev/us-east-1.yaml">
```yaml
components:
  terraform:
    vpc:
      metadata:
        component: vpc
        # Track development channel
        channel: dev
      settings:
        workspace_key_prefix: "dev/vpc"
      vars:
        name: "dev-use1-vpc"
        cidr_block: "10.0.0.0/16"
```
</File>

<File title="stacks/staging/us-east-1.yaml">
```yaml
components:
  terraform:
    vpc:
      metadata:
        component: vpc
        # Track staging channel
        channel: staging
      settings:
        workspace_key_prefix: "staging/vpc"
      vars:
        name: "staging-use1-vpc"
        cidr_block: "10.1.0.0/16"
```
</File>

<File title="stacks/prod/us-east-1.yaml">
```yaml
components:
  terraform:
    vpc:
      metadata:
        component: vpc
        # Track production channel
        channel: prod
      settings:
        workspace_key_prefix: "prod/vpc"
      vars:
        name: "prod-use1-vpc"
        cidr_block: "10.2.0.0/16"
```
</File>

## Rollback Strategy

Rolling back in Git Flow involves reverting merges or resetting branches:

### Option 1: Revert the Merge Commit

```bash
# Find the merge commit to revert
git log --oneline --merges channels/prod

# Create a revert branch
git checkout -b revert-deployment channels/prod
git revert -m 1 <merge-commit-hash>

# Push and create PR
git push origin revert-deployment
```

### Option 2: Reset Branch (Requires Force Push)

```bash
# Reset to previous known good state
git checkout channels/prod
git reset --hard <previous-good-commit>

# Force push (requires permissions)
git push --force-with-lease origin channels/prod
```

### Option 3: Fast-Forward to Previous State

```bash
# If the previous state is tagged
git checkout channels/prod
git merge --ff-only <previous-version-tag>
git push origin channels/prod
```

:::warning
Rolling back a branch affects all environments subscribed to that branch. Consider the impact carefully.
:::

## Benefits

The **Git Flow: Branches as Channels** pattern provides:

- **Familiar Workflow**: Leverages well-understood Git Flow concepts
- **Centralized Control**: Promotions happen through reviewed pull requests
- **Clear Audit Trail**: Git history shows what was promoted when
- **Flexible Velocity**: Different channels can move at different speeds
- **Strong Tooling**: Excellent CI/CD and GitHub/GitLab integration
- **Approval Gates**: Native support for review requirements

## Drawbacks

The pattern also has challenges:

- **Branch Divergence**: Long-lived branches naturally drift apart
- **Merge Conflicts**: Infrastructure code often has structural conflicts
- **Complex Rollbacks**: Reverting merges affects all environments on the branch
- **Testing Limitations**: Can't fully test infrastructure in isolated branches
- **State Confusion**: Branch switches don't affect Terraform state

## Best Practices

### 1. Use Feature Flags for Long-Running Changes

Combine branches with feature flags:

<File title="components/terraform/vpc/variables.tf">
```hcl
variable "enable_experimental_features" {
  description = "Enable experimental VPC features"
  type        = bool
  default     = false
}

variable "channel" {
  description = "Deployment channel (dev/staging/prod)"
  type        = string
}

locals {
  # Enable features based on channel
  enable_flow_logs = var.channel != "dev" ? true : var.enable_experimental_features
  enable_ipv6      = var.channel == "dev" ? true : false
}
```
</File>

### 2. Document Channel Policies

Maintain clear channel policies:

<File title="docs/channel-policy.md">
```markdown
# Channel Branch Policy

## Channel Definitions
- **channels/dev**: Latest development, updated continuously
- **channels/staging**: Pre-production validation, updated daily
- **channels/prod**: Production stable, updated weekly

## Promotion Rules
1. All changes must enter through channels/dev
2. Automated tests must pass before promotion
3. Staging requires soak time before prod promotion
4. Production promotions require approvals
```
</File>

## Summary

Git Flow: Branches as Channels adapts the familiar Git Flow model for infrastructure management. It provides strong control through pull requests, clear audit trails, and excellent tooling integration. While it requires discipline to manage branch divergence and handle merge conflicts, teams already comfortable with Git Flow often find this pattern intuitive and powerful. The key to success is maintaining synchronization between channels and having clear policies for promotion and rollback.

:::tip Key Takeaway
Git Flow for infrastructure works best when you have strong CI/CD practices and can manage branch divergence effectively. It's ideal for teams that want centralized control with familiar Git workflows.
:::

## Related Patterns

- [Release Tracks/Channels](./release-tracks-channels) - Configuration-based channel management
- [Strict Version Pinning](./strict-version-pinning) - Tag-based version control
- [Folder-Based Versioning](./folder-based-versioning) - File system-based versioning
- [Component Inheritance](/design-patterns/component-inheritance) - Extending components across branches
