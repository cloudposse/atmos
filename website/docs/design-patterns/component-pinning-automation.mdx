---
title: Component Pinning with Automation
sidebar_position: 25
sidebar_label: Component Pinning with Automation
description: Component Pinning with Automation Pattern - The recommended default for managing component versions
id: component-pinning-automation
---
import File from '@site/src/components/File'
import PillBox from '@site/src/components/PillBox'
import Intro from '@site/src/components/Intro'
import KeyPoints from '@site/src/components/KeyPoints'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<PillBox>Atmos Design Pattern</PillBox>

<Intro>
The **Component Pinning with Automation** pattern is the recommended default approach for managing component versions in Atmos. All environments pin to the same component version on the main branch, with automated testing and deployment pipelines controlling the rollout. This pattern decouples release from deployment using automation rather than version control strategies, promoting strong convergence while maintaining safety through comprehensive testing.
</Intro>

This pattern represents the sweet spot for most organizations—simple enough to understand and operate, yet powerful enough to handle complex deployment scenarios. By keeping all environments on the same version and using automation to control the rollout, teams can move fast with confidence while maintaining visibility into change impacts across their entire infrastructure.

:::tip Strategies Are Not Mutually Exclusive
This pattern can be combined with other approaches when needed. For example, you might use [Folder-Based Versioning](/design-patterns/folder-based-versioning) to manage breaking changes or experimental features alongside your main automation-driven workflow, allowing stable components to follow the automation pattern while high-risk changes get explicit version boundaries.
:::

<KeyPoints>
- All environments use the same component version from the main branch (trunk-based development)
- Automation controls the release process, not version control gymnastics
- Changes are immediately visible across all environments during planning
- Strong convergence reduces operational overhead and drift
- Easy rollback through automation, not version juggling
</KeyPoints>

## Pattern Overview

The Component Pinning with Automation pattern embraces simplicity: all environments reference the same component version from your main branch. Instead of managing different versions per environment through Git, you use:

1. **Automated testing pipelines** to validate changes before they reach production
2. **Progressive deployment strategies** to roll out changes incrementally
3. **Feature flags and configuration** to control behavior per environment
4. **CI/CD automation** to orchestrate the release process

This approach aligns with modern DevOps practices and trunk-based development, where the main branch is always deployable and releases are controlled through automation.

## How It Works

### Basic Structure

All your stack configurations reference the same components without version qualifiers:

<File title="stacks/dev/us-east-1.yaml">
```yaml
import:
  - catalog/vpc

components:
  terraform:
    vpc:
      metadata:
        component: vpc  # Same component for all environments
      vars:
        environment: dev
        cidr_block: "10.0.0.0/16"
        enable_nat_gateway: false  # Dev-specific configuration
```
</File>

<File title="stacks/staging/us-east-1.yaml">
```yaml
import:
  - catalog/vpc

components:
  terraform:
    vpc:
      metadata:
        component: vpc  # Same component version as dev
      vars:
        environment: staging
        cidr_block: "10.1.0.0/16"
        enable_nat_gateway: true  # Staging-specific configuration
```
</File>

<File title="stacks/prod/us-east-1.yaml">
```yaml
import:
  - catalog/vpc

components:
  terraform:
    vpc:
      metadata:
        component: vpc  # Same component version everywhere
      vars:
        environment: prod
        cidr_block: "10.2.0.0/16"
        enable_nat_gateway: true
        enable_flow_logs: true  # Prod-specific configuration
```
</File>

### Deployment Pipeline

The key to this pattern is a robust deployment pipeline that validates changes progressively:

<File title=".github/workflows/deploy.yml">
```yaml
name: Progressive Deployment

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  plan-all:
    name: Plan All Environments
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Plan Dev
        run: |
          atmos terraform plan vpc -s dev/us-east-1

      - name: Plan Staging
        run: |
          atmos terraform plan vpc -s staging/us-east-1

      - name: Plan Production
        run: |
          atmos terraform plan vpc -s prod/us-east-1

      - name: Comment PR with Changes
        if: github.event_name == 'pull_request'
        run: |
          # Post plan output to PR for visibility

  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    needs: [plan-all]
    steps:
      - name: Deploy to Dev
        run: |
          atmos terraform apply vpc -s dev/us-east-1 --auto-approve

      - name: Run Smoke Tests
        run: |
          # Validate dev deployment

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [deploy-dev]
    steps:
      - name: Deploy to Staging
        run: |
          atmos terraform apply vpc -s staging/us-east-1 --auto-approve

      - name: Run Integration Tests
        run: |
          # Comprehensive testing in staging

  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    environment: production  # Requires manual approval
    steps:
      - name: Deploy to Production
        run: |
          atmos terraform apply vpc -s prod/us-east-1 --auto-approve

      - name: Monitor Deployment
        run: |
          # Post-deployment validation
```
</File>

## Benefits

### 1. Strong Convergence

All environments converge to the same version quickly, reducing drift and making it easier to reason about your infrastructure:

- **No version skew**: Dev accurately reflects what will happen in production
- **Immediate feedback**: Changes are visible across all environments during planning
- **Reduced surprises**: What works in dev will work in production (configuration permitting)

### 2. Simplified Operations

Without complex version management, operations become straightforward:

- **Single source of truth**: The main branch represents the desired state
- **No version tracking**: No need to manage version pins, tracks, or promotions
- **Clear rollback**: Revert the commit and re-run the pipeline
- **Minimal cognitive load**: Team members don't need to understand versioning strategies

### 3. Fast Feedback Loops

Changes are immediately visible across all environments:

```bash
# On a feature branch, see impact everywhere
$ atmos terraform plan vpc -s dev/us-east-1
$ atmos terraform plan vpc -s staging/us-east-1
$ atmos terraform plan vpc -s prod/us-east-1

# All plans show the same changes (modulo configuration)
```

### 4. Trunk-Based Development

Aligns perfectly with trunk-based development practices:

- Short-lived feature branches
- Frequent integration to main
- Main branch always deployable
- Progressive deployment through environments

## Implementation Guide

### Step 1: Set Up Component Structure

Organize components without version directories:

```
components/
├── terraform/
│   ├── vpc/             # Single version of VPC component
│   ├── eks/             # Single version of EKS component
│   └── rds/             # Single version of RDS component
```

### Step 2: Configure Automation

Set up comprehensive CI/CD pipelines with:

1. **Validation on PR**:
   - Terraform validation
   - Security scanning
   - Policy checks (OPA, Sentinel)
   - Plan output for all environments

2. **Progressive Deployment**:
   - Automatic deployment to dev
   - Automated testing gates
   - Manual approval for production
   - Rollback procedures

3. **Monitoring and Alerting**:
   - Deployment metrics
   - Error tracking
   - Performance monitoring
   - Automated rollback triggers

### Step 3: Implement Safety Controls

Use configuration and feature flags for safety:

<File title="components/terraform/app/main.tf">
```hcl
variable "enable_new_feature" {
  description = "Enable the new feature"
  type        = bool
  default     = false
}

resource "aws_lambda_function" "app" {
  # Core configuration

  environment {
    variables = {
      FEATURE_FLAG_NEW_UI = var.enable_new_feature
    }
  }
}
```
</File>

<File title="stacks/dev/us-east-1.yaml">
```yaml
components:
  terraform:
    app:
      vars:
        enable_new_feature: true  # Test in dev first
```
</File>

### Step 4: Handle Breaking Changes

For breaking changes, use temporary compatibility layers:

<File title="components/terraform/vpc/main.tf">
```hcl
# Support both old and new variable names during transition
variable "enable_nat" {
  description = "DEPRECATED: Use enable_nat_gateway instead"
  type        = bool
  default     = null
}

variable "enable_nat_gateway" {
  description = "Enable NAT Gateway"
  type        = bool
  default     = false
}

locals {
  # Use new variable if set, fall back to old variable
  nat_gateway_enabled = coalesce(
    var.enable_nat_gateway,
    var.enable_nat,
    false
  )
}
```
</File>

## Advanced Patterns

### Blue-Green Deployments

Use Atmos component instances for blue-green deployments:

<File title="stacks/prod/us-east-1.yaml">
```yaml
components:
  terraform:
    app-blue:
      metadata:
        component: app
        inherits:
          - app-base
      vars:
        deployment_color: blue
        traffic_weight: 100

    app-green:
      metadata:
        component: app
        inherits:
          - app-base
      vars:
        deployment_color: green
        traffic_weight: 0
```
</File>

### Canary Releases

Implement canary releases through configuration:

<File title="stacks/prod/us-east-1.yaml">
```yaml
components:
  terraform:
    app:
      vars:
        canary_enabled: true
        canary_percentage: 5
        canary_version: "v2.0.0"
        stable_version: "v1.9.0"
```
</File>

### Emergency Overrides

Support emergency overrides when needed:

<File title="stacks/prod/us-east-1.yaml">
```yaml
components:
  terraform:
    critical-fix:
      metadata:
        # Temporarily use a different component version
        component: vpc-hotfix
      vars:
        # Emergency configuration
```
</File>

## Comparison with Other Patterns

<Tabs>
<TabItem value="strict-pinning" label="vs. Strict Version Pinning" default>

| Aspect | Strict Pinning | Component Pinning with Automation |
|--------|----------------|-----------------------------------|
| **Operational Overhead** | High - manage individual pins per environment | Low - single version for all environments |
| **Feedback Loops** | Weak - issues surface late | Strong - immediate visibility across environments |
| **Convergence** | Promotes divergence | Promotes convergence |
| **Reproducibility** | Strong - explicit pins | Good - via Git history |

**When to prefer Strict Pinning:** Compliance requirements demand cryptographic proof of exact versions deployed.

</TabItem>
<TabItem value="release-tracks" label="vs. Release Tracks">

| Aspect | Release Tracks | Component Pinning with Automation |
|--------|----------------|-----------------------------------|
| **Track Management** | Must manage track definitions | No track management needed |
| **Abstraction** | Additional layer of indirection | Direct and simple |
| **Gradual Rollout** | Built into track progression | Achieved via CI/CD pipeline |
| **Flexibility** | Grouped environment control | Individual pipeline control |

**When to prefer Release Tracks:** Many environments need coordinated version progression with clear promotion stages.

</TabItem>
<TabItem value="git-flow" label="vs. Git Flow">

| Aspect | Git Flow | Component Pinning with Automation |
|--------|----------|-----------------------------------|
| **Branch Management** | Complex - maintain multiple long-lived branches | Simple - trunk-based development |
| **Merge Conflicts** | Frequent conflicts between branches | No branch conflicts |
| **Integration Speed** | Slower - changes isolated in branches | Fast - frequent integration to main |
| **Deployment Model** | Branches represent environments | Automation controls deployment |

**When to prefer Git Flow:** Legacy systems where branch-per-environment is deeply embedded in processes.

</TabItem>
</Tabs>

## When to Use This Pattern

This pattern is ideal when:

✅ **You want simplicity**: Minimal concepts to understand and operate
✅ **You have good automation**: Strong CI/CD pipelines and testing
✅ **You value convergence**: Want environments to stay in sync
✅ **You practice trunk-based development**: Frequent integration to main
✅ **You can roll forward**: Culture supports fixing forward vs. rollback
✅ **You're starting fresh**: New projects without legacy constraints

## When Not to Use This Pattern

Consider alternatives when:

❌ **Strict compliance requirements**: Need cryptographic proof of deployments
❌ **No automation infrastructure**: Can't build robust pipelines
❌ **Very slow release cycles**: Months between production deployments
❌ **Multiple teams with conflicts**: Need isolation between team changes
❌ **Legacy migration**: Existing complex versioning must be maintained

## Best Practices

- **Comprehensive Testing:** Invest in thorough testing at each stage including unit tests (component-level), integration tests (cross-component), smoke tests (basic functionality), performance tests (load and scale), security scans (vulnerability assessment), and chaos testing (resilience validation).

- **Clear Rollback Procedures:** Rollback is straightforward: revert the problematic commit on the main branch and let your deployment pipeline apply the previous state across all environments. This approach maintains consistency and leverages the same automation that deployed the change originally.

- **Environment Parity:** Keep environments as similar as possible by using inheritance for shared configuration and minimizing environment-specific overrides.

  ```yaml
  # Use inheritance for consistency
  catalog:
    base-vpc:
      vars:
        enable_dns_hostnames: true
        enable_dns_support: true
        # Shared configuration

  # Then customize minimally per environment
  components:
    terraform:
      vpc:
        metadata:
          inherits:
            - base-vpc
        vars:
          # Only environment-specific overrides
  ```

## Troubleshooting

### Common Issues

**Problem**: Afraid to deploy to production
**Solution**: Increase test coverage and implement better monitoring

**Problem**: Changes break multiple environments
**Solution**: Add environment-specific validation and use feature flags

**Problem**: Rollback is difficult
**Solution**: Automate rollback procedures and practice them regularly

**Problem**: Compliance requires deployment records
**Solution**: Generate deployment artifacts from your CI/CD system

## Summary

Component Pinning with Automation represents the ideal balance for most teams—simple to understand, easy to operate, yet powerful enough for complex scenarios. By embracing trunk-based development and leveraging automation for safety, teams can move fast with confidence while maintaining visibility and control over their infrastructure.

The pattern's strength lies not in complex version management, but in robust automation and testing. This approach aligns with modern DevOps practices and scales well from small teams to large organizations.

:::tip Key Takeaway
Don't solve deployment challenges with version control gymnastics. Use automation, testing, and progressive rollout strategies to maintain safety while keeping operations simple.
:::

## See Also

- **[Folder-Based Versioning](/design-patterns/folder-based-versioning)** - Use this alongside automation when you need explicit version boundaries for breaking changes or experimental features that require extended parallel development.
- **[Release Tracks/Channels](/design-patterns/release-tracks-channels)** - Consider this alternative when managing many environments that need coordinated version progression with clear promotion stages and grouped rollout control.
