---
title: Component Pinning with Automation
sidebar_position: 25
sidebar_label: Component Pinning with Automation
description: Component Pinning with Automation Pattern - The recommended default for managing component versions
id: component-pinning-automation
---
import File from '@site/src/components/File'
import PillBox from '@site/src/components/PillBox'
import Intro from '@site/src/components/Intro'
import KeyPoints from '@site/src/components/KeyPoints'

<PillBox>Atmos Design Pattern</PillBox>
<PillBox>Recommended Default</PillBox>

<Intro>
The **Component Pinning with Automation** pattern is the recommended default approach for managing component versions in Atmos. All environments pin to the same component version on the main branch, with automated testing and deployment pipelines controlling the rollout. This pattern decouples release from deployment using automation rather than version control strategies, promoting strong convergence while maintaining safety through comprehensive testing.
</Intro>

This pattern represents the sweet spot for most organizations—simple enough to understand and operate, yet powerful enough to handle complex deployment scenarios. By keeping all environments on the same version and using automation to control the rollout, teams can move fast with confidence while maintaining visibility into change impacts across their entire infrastructure.

<KeyPoints>
- All environments use the same component version from the main branch (trunk-based development)
- Automation controls the release process, not version control gymnastics
- Changes are immediately visible across all environments during planning
- Strong convergence reduces operational overhead and drift
- Easy rollback through automation, not version juggling
</KeyPoints>

## Pattern Overview

The Component Pinning with Automation pattern embraces simplicity: all environments reference the same component version from your main branch. Instead of managing different versions per environment through Git, you use:

1. **Automated testing pipelines** to validate changes before they reach production
2. **Progressive deployment strategies** to roll out changes incrementally
3. **Feature flags and configuration** to control behavior per environment
4. **CI/CD automation** to orchestrate the release process

This approach aligns with modern DevOps practices and trunk-based development, where the main branch is always deployable and releases are controlled through automation.

## How It Works

### Basic Structure

All your stack configurations reference the same components without version qualifiers:

<File title="stacks/dev/us-east-1.yaml">
```yaml
import:
  - catalog/vpc

components:
  terraform:
    vpc:
      metadata:
        component: vpc  # Same component for all environments
      vars:
        environment: dev
        cidr_block: "10.0.0.0/16"
        enable_nat_gateway: false  # Dev-specific configuration
```
</File>

<File title="stacks/staging/us-east-1.yaml">
```yaml
import:
  - catalog/vpc

components:
  terraform:
    vpc:
      metadata:
        component: vpc  # Same component version as dev
      vars:
        environment: staging
        cidr_block: "10.1.0.0/16"
        enable_nat_gateway: true  # Staging-specific configuration
```
</File>

<File title="stacks/prod/us-east-1.yaml">
```yaml
import:
  - catalog/vpc

components:
  terraform:
    vpc:
      metadata:
        component: vpc  # Same component version everywhere
      vars:
        environment: prod
        cidr_block: "10.2.0.0/16"
        enable_nat_gateway: true
        enable_flow_logs: true  # Prod-specific configuration
```
</File>

### Deployment Pipeline

The key to this pattern is a robust deployment pipeline that validates changes progressively:

<File title=".github/workflows/deploy.yml">
```yaml
name: Progressive Deployment

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  plan-all:
    name: Plan All Environments
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Plan Dev
        run: |
          atmos terraform plan vpc -s dev/us-east-1

      - name: Plan Staging
        run: |
          atmos terraform plan vpc -s staging/us-east-1

      - name: Plan Production
        run: |
          atmos terraform plan vpc -s prod/us-east-1

      - name: Comment PR with Changes
        if: github.event_name == 'pull_request'
        run: |
          # Post plan output to PR for visibility

  deploy-dev:
    name: Deploy to Dev
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    needs: [plan-all]
    steps:
      - name: Deploy to Dev
        run: |
          atmos terraform apply vpc -s dev/us-east-1 --auto-approve

      - name: Run Smoke Tests
        run: |
          # Validate dev deployment

  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [deploy-dev]
    steps:
      - name: Deploy to Staging
        run: |
          atmos terraform apply vpc -s staging/us-east-1 --auto-approve

      - name: Run Integration Tests
        run: |
          # Comprehensive testing in staging

  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [deploy-staging]
    environment: production  # Requires manual approval
    steps:
      - name: Deploy to Production
        run: |
          atmos terraform apply vpc -s prod/us-east-1 --auto-approve

      - name: Monitor Deployment
        run: |
          # Post-deployment validation
```
</File>

## Benefits

### 1. Strong Convergence

All environments converge to the same version quickly, reducing drift and making it easier to reason about your infrastructure:

- **No version skew**: Dev accurately reflects what will happen in production
- **Immediate feedback**: Changes are visible across all environments during planning
- **Reduced surprises**: What works in dev will work in production (configuration permitting)

### 2. Simplified Operations

Without complex version management, operations become straightforward:

- **Single source of truth**: The main branch represents the desired state
- **No version tracking**: No need to manage version pins, tracks, or promotions
- **Clear rollback**: Revert the commit and re-run the pipeline
- **Minimal cognitive load**: Team members don't need to understand versioning strategies

### 3. Fast Feedback Loops

Changes are immediately visible across all environments:

```bash
# On a feature branch, see impact everywhere
$ atmos terraform plan vpc -s dev/us-east-1
$ atmos terraform plan vpc -s staging/us-east-1
$ atmos terraform plan vpc -s prod/us-east-1

# All plans show the same changes (modulo configuration)
```

### 4. Trunk-Based Development

Aligns perfectly with trunk-based development practices:

- Short-lived feature branches
- Frequent integration to main
- Main branch always deployable
- Progressive deployment through environments

## Implementation Guide

### Step 1: Set Up Component Structure

Organize components without version directories:

```
components/
├── terraform/
│   ├── vpc/             # Single version of VPC component
│   ├── eks/             # Single version of EKS component
│   └── rds/             # Single version of RDS component
```

### Step 2: Configure Automation

Set up comprehensive CI/CD pipelines with:

1. **Validation on PR**:
   - Terraform validation
   - Security scanning
   - Policy checks (OPA, Sentinel)
   - Plan output for all environments

2. **Progressive Deployment**:
   - Automatic deployment to dev
   - Automated testing gates
   - Manual approval for production
   - Rollback procedures

3. **Monitoring and Alerting**:
   - Deployment metrics
   - Error tracking
   - Performance monitoring
   - Automated rollback triggers

### Step 3: Implement Safety Controls

Use configuration and feature flags for safety:

<File title="components/terraform/app/main.tf">
```hcl
variable "enable_new_feature" {
  description = "Enable the new feature"
  type        = bool
  default     = false
}

resource "aws_lambda_function" "app" {
  # Core configuration

  environment {
    variables = {
      FEATURE_FLAG_NEW_UI = var.enable_new_feature
    }
  }
}
```
</File>

<File title="stacks/dev/us-east-1.yaml">
```yaml
components:
  terraform:
    app:
      vars:
        enable_new_feature: true  # Test in dev first
```
</File>

### Step 4: Handle Breaking Changes

For breaking changes, use temporary compatibility layers:

<File title="components/terraform/vpc/main.tf">
```hcl
# Support both old and new variable names during transition
variable "enable_nat" {
  description = "DEPRECATED: Use enable_nat_gateway instead"
  type        = bool
  default     = null
}

variable "enable_nat_gateway" {
  description = "Enable NAT Gateway"
  type        = bool
  default     = false
}

locals {
  # Use new variable if set, fall back to old variable
  nat_gateway_enabled = coalesce(
    var.enable_nat_gateway,
    var.enable_nat,
    false
  )
}
```
</File>

## Advanced Patterns

### Blue-Green Deployments

Use Atmos component instances for blue-green deployments:

<File title="stacks/prod/us-east-1.yaml">
```yaml
components:
  terraform:
    app-blue:
      metadata:
        component: app
        inherits:
          - app-base
      vars:
        deployment_color: blue
        traffic_weight: 100

    app-green:
      metadata:
        component: app
        inherits:
          - app-base
      vars:
        deployment_color: green
        traffic_weight: 0
```
</File>

### Canary Releases

Implement canary releases through configuration:

<File title="stacks/prod/us-east-1.yaml">
```yaml
components:
  terraform:
    app:
      vars:
        canary_enabled: true
        canary_percentage: 5
        canary_version: "v2.0.0"
        stable_version: "v1.9.0"
```
</File>

### Emergency Overrides

Support emergency overrides when needed:

<File title="stacks/prod/us-east-1.yaml">
```yaml
components:
  terraform:
    critical-fix:
      metadata:
        # Temporarily use a different component version
        component: vpc-hotfix
      vars:
        # Emergency configuration
```
</File>

## Comparison with Other Patterns

### vs. Strict Version Pinning

**Strict Pinning**:
- ❌ High operational overhead
- ❌ Weak feedback loops
- ❌ Promotes divergence
- ✅ Strong reproducibility

**Component Pinning with Automation**:
- ✅ Low operational overhead
- ✅ Strong feedback loops
- ✅ Promotes convergence
- ✅ Good reproducibility (via Git history)

### vs. Release Tracks

**Release Tracks**:
- ❌ Must manage track definitions
- ❌ Additional abstraction layer
- ✅ Gradual rollout built-in

**Component Pinning with Automation**:
- ✅ No track management
- ✅ Direct and simple
- ✅ Gradual rollout via pipeline

### vs. Git Flow

**Git Flow**:
- ❌ Complex branch management
- ❌ Merge conflicts between branches
- ❌ Slower integration

**Component Pinning with Automation**:
- ✅ Simple trunk-based flow
- ✅ No branch conflicts
- ✅ Fast integration

## When to Use This Pattern

This pattern is ideal when:

✅ **You want simplicity**: Minimal concepts to understand and operate
✅ **You have good automation**: Strong CI/CD pipelines and testing
✅ **You value convergence**: Want environments to stay in sync
✅ **You practice trunk-based development**: Frequent integration to main
✅ **You can roll forward**: Culture supports fixing forward vs. rollback
✅ **You're starting fresh**: New projects without legacy constraints

## When Not to Use This Pattern

Consider alternatives when:

❌ **Strict compliance requirements**: Need cryptographic proof of deployments
❌ **No automation infrastructure**: Can't build robust pipelines
❌ **Very slow release cycles**: Months between production deployments
❌ **Multiple teams with conflicts**: Need isolation between team changes
❌ **Legacy migration**: Existing complex versioning must be maintained

## Best Practices

### 1. Comprehensive Testing

Invest in thorough testing at each stage:

```yaml
# Example test stages
stages:
  - unit_tests          # Component-level tests
  - integration_tests   # Cross-component tests
  - smoke_tests        # Basic functionality
  - performance_tests  # Load and scale testing
  - security_scan     # Vulnerability assessment
  - chaos_testing    # Resilience validation
```

### 2. Clear Rollback Procedures

Document and automate rollback:

```bash
#!/bin/bash
# rollback.sh

COMMIT_TO_REVERT=$1
ENVIRONMENT=$2

# Revert the commit
git revert $COMMIT_TO_REVERT --no-edit

# Push to trigger pipeline
git push origin main

# Or manually apply previous state
atmos terraform apply component -s $ENVIRONMENT --auto-approve
```

### 3. Environment Parity

Keep environments as similar as possible:

```yaml
# Use inheritance for consistency
catalog:
  base-vpc:
    vars:
      enable_dns_hostnames: true
      enable_dns_support: true
      # Shared configuration

# Then customize minimally per environment
components:
  terraform:
    vpc:
      metadata:
        inherits:
          - base-vpc
      vars:
        # Only environment-specific overrides
```

### 4. Monitoring and Observability

Implement comprehensive monitoring:

- Deployment frequency and duration
- Success/failure rates
- Time to recovery
- Change failure rate
- Mean time between failures

### 5. Progressive Rollout Controls

Use multiple mechanisms for safe rollout:

1. **Feature Flags**: Runtime behavior control
2. **Configuration Management**: Environment-specific settings
3. **Traffic Management**: Load balancer weights
4. **Deployment Windows**: Time-based restrictions
5. **Manual Gates**: Human approval for critical environments

## Migration Guide

### From Strict Version Pinning

1. **Consolidate versions**: Identify which version each environment uses
2. **Align environments**: Progressively update lagging environments
3. **Remove version pins**: Update stack configs to use unversioned components
4. **Implement automation**: Build out CI/CD pipelines
5. **Add safety controls**: Implement feature flags and testing

### From Git Flow

1. **Merge long-lived branches**: Consolidate to main branch
2. **Update references**: Point all environments to main branch
3. **Simplify pipeline**: Remove branch-specific logic
4. **Implement protections**: Add testing and approval gates
5. **Train team**: Educate on trunk-based development

## Troubleshooting

### Common Issues

**Problem**: Afraid to deploy to production
**Solution**: Increase test coverage and implement better monitoring

**Problem**: Changes break multiple environments
**Solution**: Add environment-specific validation and use feature flags

**Problem**: Rollback is difficult
**Solution**: Automate rollback procedures and practice them regularly

**Problem**: Compliance requires deployment records
**Solution**: Generate deployment artifacts from your CI/CD system

## Summary

Component Pinning with Automation represents the ideal balance for most teams—simple to understand, easy to operate, yet powerful enough for complex scenarios. By embracing trunk-based development and leveraging automation for safety, teams can move fast with confidence while maintaining visibility and control over their infrastructure.

The pattern's strength lies not in complex version management, but in robust automation and testing. This approach aligns with modern DevOps practices and scales well from small teams to large organizations.

:::tip Key Takeaway
Don't solve deployment challenges with version control gymnastics. Use automation, testing, and progressive rollout strategies to maintain safety while keeping operations simple.
:::

## Related Patterns

- [Version Management](/design-patterns/version-management) - Overview of all version management strategies
- [Multiple Component Instances](/design-patterns/multiple-component-instances) - Running multiple versions simultaneously
- [Component Catalog](/design-patterns/component-catalog) - Organizing shared components
- [Component Inheritance](/design-patterns/component-inheritance) - Sharing configuration across environments
