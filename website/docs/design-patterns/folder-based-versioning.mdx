---
title: Folder-Based Versioning
sidebar_position: 23
sidebar_label: Folder-Based Versioning
description: Folder-Based Versioning Atmos Design Pattern
---
import File from '@site/src/components/File'
import PillBox from '@site/src/components/PillBox'
import Intro from '@site/src/components/Intro'
import KeyPoints from '@site/src/components/KeyPoints'

<PillBox>Atmos Design Pattern</PillBox>
<Intro>
The **Folder-Based Versioning** Design Pattern is a trunk-based approach that uses the repository's directory structure on the main branch to manage component versions. By creating separate folders for different versions (e.g., `vpc/v1`, `vpc/v2`), teams can safely iterate on new versions while maintaining stability for existing deployments.
</Intro>

Folder-Based Versioning makes version boundaries explicit and visible in the repository structure. As a trunk-based pattern, all version folders exist in the main branch simultaneously, allowing environments to choose their version by selecting the appropriate folder. This approach allows for long-lived divergence between versions, gradual migration paths, and clear separation of concerns. It's particularly useful for major version changes that require extended development and testing periods.

<KeyPoints>
- How folder structure provides explicit version boundaries
- Why this pattern excels for long-lived, breaking changes
- The importance of stable workspace keys when switching versions
- Strategies for managing multiple versions in parallel
</KeyPoints>

## Use Cases

Use the **Folder-Based Versioning** pattern when:

- You need **significant component rework** that will take time to stabilize
- You want **explicit version boundaries** visible in the repository
- You need to **run multiple versions side-by-side** for extended periods
- You're making **breaking changes** that require careful migration
- You want **clear separation** between stable and experimental code
- You need **gradual migration paths** for complex components

## Problem

Major component changes often require extended development periods and careful migration strategies. Traditional versioning approaches can create challenges:

- **In-place changes** destabilize existing deployments
- **Feature flags** add complexity and technical debt
- **Branch-based development** delays integration and feedback
- **Hidden versioning** makes it hard to understand what's deployed where

Folder-Based Versioning addresses these issues by making versions first-class citizens in the repository structure.

## Solution

Create separate folders for each major version of a component. Environments explicitly reference the folder containing their desired version, making version selection transparent and reversible.

### Core Principles

1. **Versions as Folders**: Each major version gets its own directory
2. **Explicit References**: Stacks explicitly choose which folder/version to use
3. **Parallel Development**: Multiple versions can evolve independently
4. **Stable State Keys**: Workspace keys remain constant across version switches
5. **Clear Deprecation**: Old versions are clearly marked and eventually removed

## Implementation

### Directory Structure

Organize components with version-specific folders:

<File title="Directory Structure">
```
components/
  terraform/
    vpc/
      v1/                   # Version 1 implementation
        main.tf
        variables.tf
        outputs.tf
        README.md
      v2/                   # Version 2 implementation
        main.tf
        variables.tf
        outputs.tf
        README.md
        MIGRATION.md        # Migration guide from v1
      v3-preview/           # Version 3 in development
        main.tf
        variables.tf
        outputs.tf
        README.md
    rds/
      standard/             # Standard RDS version
        main.tf
      aurora/               # Aurora variant
        main.tf
      v2-deprecated/        # Deprecated version
        main.tf
        DEPRECATED.md
```
</File>

### Stack Configuration

Environments reference specific version folders:

<File title="stacks/dev/us-east-1.yaml">
```yaml
components:
  terraform:
    vpc:
      metadata:
        component: vpc/v2  # Reference v2 folder for development
      settings:
        # CRITICAL: Don't include version in workspace key
        workspace_key_prefix: "dev/vpc"
      vars:
        name: "dev-use1-vpc"
        cidr_block: "10.0.0.0/16"
```
</File>

<File title="stacks/prod/us-east-1.yaml">
```yaml
components:
  terraform:
    vpc:
      metadata:
        component: vpc/v1  # Production still on stable v1
      settings:
        # Same workspace key as dev - enables migration
        workspace_key_prefix: "prod/vpc"
      vars:
        name: "prod-use1-vpc"
        cidr_block: "10.2.0.0/16"
```
</File>

### Version Naming Conventions

Choose clear, consistent naming patterns within your component folders:

<File title="components/terraform directory structure">
```
components/
  terraform/
    vpc/
      v1/                    # Semantic versioning
      v2/
      v3-preview/

    rds/
      standard/              # Feature-based versioning
      aurora/
      serverless/

    eks/
      stable/                # Release-channel versioning
      beta/
      deprecated/

    lambda/
      2023/                  # Date-based versioning
      2024/
      2025/
```
</File>

## Workspace Key Management

:::warning Requires Dynamic Backends
This pattern requires [dynamic backend generation](/core-concepts/components/terraform-backends#dynamic-terraform-backend) to be enabled. The `workspace_key_prefix` must remain stable across version changes to prevent state conflicts:

```yaml
# WRONG - Version in workspace key causes state problems
settings:
  workspace_key_prefix: "prod/vpc/v2"  # Don't do this!

# CORRECT - Stable workspace key across versions
settings:
  workspace_key_prefix: "prod/vpc"     # Version-agnostic key
```

When the workspace key includes version information, switching versions requires complex state migrations. Keep it stable!
:::

## Migration Strategies

### Gradual Migration

Roll out new versions progressively through environments:

<File title="migration-plan.yaml">
```yaml
# Week 1: Development environments
dev:
  vpc:
    metadata:
      component: vpc/v2

# Week 2: Staging environments
staging:
  vpc:
    metadata:
      component: vpc/v2

# Week 3: Production canary
prod-canary:
  vpc:
    metadata:
      component: vpc/v2

# Week 4: All production
prod:
  vpc:
    metadata:
      component: vpc/v2
```
</File>

### Blue-Green Migration

Run both versions in parallel, then switch:

<File title="stacks/prod/us-east-1.yaml">
```yaml
components:
  terraform:
    # Original VPC (blue)
    vpc:
      metadata:
        component: vpc/v1  # Original version
      settings:
        workspace_key_prefix: "prod/vpc"

    # New VPC (green) - different workspace key for parallel run
    vpc-next:
      metadata:
        component: vpc/v2  # New version
      settings:
        workspace_key_prefix: "prod/vpc-next"
```
</File>

After validation, update references and destroy the old version.

### In-Place Upgrade

For backwards-compatible changes, switch the folder reference:

```bash
# Before upgrade - verify current state
atmos terraform plan vpc --stack prod-us-east-1

# Update stack configuration to point to new version
# Edit: metadata.component from "vpc/v1" to "vpc/v2"

# Plan with new version - should show intended changes
atmos terraform plan vpc --stack prod-us-east-1

# Apply the upgrade
atmos terraform apply vpc --stack prod-us-east-1
```

## Rollback Strategy

Folder-based versioning makes rollback trivial - just switch the folder reference:

### Update Stack Configuration

```yaml
# stacks/prod/us-east-1.yaml
components:
  terraform:
    vpc:
      metadata:
        # Rollback from v2 to v1
        component: vpc/v1  # Was: vpc/v2
      settings:
        workspace_key_prefix: "prod/vpc"  # Keep stable!
```

### Validate and Apply

```bash
# Validate the rollback
atmos terraform plan vpc --stack prod-us-east-1

# Review the changes - should show reverting to v1 behavior

# Apply the rollback
atmos terraform apply vpc --stack prod-us-east-1
```

:::tip Zero-Downtime Rollback
Since the old version folder still exists unchanged, rollback is instantaneous and risk-free. The stable workspace key means no state migration is needed.
:::

### Rollback Verification

```bash
# Verify the component is using the correct version
atmos describe component vpc --stack prod-us-east-1 | grep "component:"

# Should show: component: vpc/v1
```

## Benefits

The **Folder-Based Versioning** pattern provides:

- **Explicit Boundaries**: Version differences are clear in the repository structure
- **Safe Experimentation**: New versions can be developed without affecting stable code
- **Gradual Migration**: Environments can migrate at their own pace
- **Parallel Development**: Multiple versions can evolve independently
- **Instant Rollback**: Simply change the folder reference to revert
- **Clear Deprecation Path**: Old versions are visibly marked for removal

## Drawbacks

The pattern also has limitations:

- **Repository Growth**: Multiple versions increase repository size
- **Maintenance Overhead**: Bug fixes may need to be applied to multiple versions
- **Potential Confusion**: Developers must understand which version to modify
- **Code Duplication**: Similar code exists in multiple folders
- **Cleanup Discipline**: Deprecated versions must be actively removed

## Best Practices

### 1. Version Lifecycle Management

Define clear lifecycle stages:

<File title="docs/version-lifecycle.md">
```markdown
# Component Version Lifecycle

## Stages
1. **Preview** (-preview suffix): Experimental, API unstable
2. **Beta** (-beta suffix): Feature complete, testing in progress
3. **Stable** (no suffix or -v2): Production ready
4. **Deprecated** (-deprecated suffix): Marked for removal
5. **Archived** (moved to archive/): No longer maintained

## Transitions
- Preview → Beta: After API stabilization
- Beta → Stable: After production validation
- Stable → Deprecated: When newer version is stable
- Deprecated → Archived: After all migrations complete

## Timeline
- Minimum 30 days in Beta before Stable
- Minimum 90 days Deprecated before removal
- Document migration path before deprecation
```
</File>

### 2. Version Documentation

Maintain clear documentation for each version:

```markdown
# Component Version Matrix

| Component | v1 | v2 | v3 |
|-----------|----|----|-----|
| vpc | Stable (Deprecated) | Stable (Current) | Preview |
| rds | Stable | Beta | - |
| eks | Stable | - | - |

## Version Notes
- **vpc/v1**: Deprecated as of 2024-01-01, removal planned 2024-04-01
- **vpc/v2**: Current recommended version
- **vpc/v3**: Preview features, not for production
```

### 3. Shared Code Management

Minimize duplication using shared modules:

```
components/
  terraform/
    vpc/
      main.tf                   # Imports from shared
    vpc/v2/
      main.tf                   # Imports from shared
    vpc-shared/                 # Shared code
      modules/
        subnets/
        security-groups/
        flow-logs/
```

### 4. Testing Strategy

Test all active versions using Atmos validation:

```bash
# Validate all components and their versions
atmos validate stacks
atmos validate components

# Test specific versioned components
atmos terraform validate vpc/v2 --stack dev-us-east-1
atmos terraform validate vpc/v3-preview --stack dev-us-east-1

# Run validation for all stacks
atmos validate all
```

### 5. Migration Process

Migrate components to new versions using Atmos:

```yaml
# Update stack configuration to reference new version
components:
  terraform:
    vpc:
      metadata:
        # Change from vpc/v1 to vpc/v2
        component: vpc/v2
```

Then apply the migration:

```bash
# Preview the migration changes
atmos terraform plan vpc --stack prod-us-east-1

# Apply the migration with interactive approval
atmos terraform apply vpc --stack prod-us-east-1 --auto-approve=false
```

## Migration from Other Patterns

### From Strict Pinning

1. Create versioned folders for each unique version in use
2. Update stack configurations to reference folders instead of Git refs
3. Consolidate common versions into single folders
4. Gradually converge to fewer versions

### From Release Tracks

1. Convert track folders to version folders
2. Update stack configurations to explicitly choose versions
3. Remove track abstraction layer
4. Implement direct folder references

## Summary

Folder-Based Versioning provides explicit, visible version management through repository structure. It excels when you need to maintain multiple versions in parallel, make breaking changes safely, or provide clear migration paths. While it can increase repository size and maintenance overhead, the clarity and safety it provides often outweigh these costs, especially for critical infrastructure components.

:::tip Key Takeaway
Folder-based versioning makes version boundaries explicit and migrations reversible. It's ideal for major version changes that require extended development and careful rollout strategies.
:::

## Related Patterns

- [Release Tracks/Channels](./release-tracks-channels) - Abstract version management through tracks
- [Vendoring Components](./vendoring-components) - Local copies with origin tracking
- [Strict Version Pinning](./strict-version-pinning) - Explicit version control per environment
- [Component Catalog](/design-patterns/component-catalog) - Organizing reusable components
