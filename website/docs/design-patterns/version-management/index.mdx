---
title: Version Management Patterns
sidebar_position: 1
sidebar_label: Version Management
description: Version Management Patterns in Atmos - Strategies for Managing Component Versions
id: version-management
---
import File from '@site/src/components/File'
import PillBox from '@site/src/components/PillBox'
import Intro from '@site/src/components/Intro'
import KeyPoints from '@site/src/components/KeyPoints'

<PillBox>Atmos Design Pattern</PillBox>
<Intro>
The **Version Management Patterns** are a collection of strategies for managing component versions in Atmos. These patterns address one of the most challenging problems in infrastructure-as-code: balancing **stability** (reproducibility, rollback) with **velocity** (fast iterations, safety via feedback loops).
</Intro>

Managing versions of infrastructure components requires careful consideration of trade-offs between convergence speed, operational overhead, and safety. Atmos supports multiple design patterns for managing component versions, each with distinct benefits and considerations. There's no silver bullet—choose patterns based on your organization's culture, team size, and operational maturity.

<KeyPoints>
- Understanding the fundamental tension between deployment (declaring target state) and release (applying changes)
- How different versioning strategies optimize for different goals: reproducibility, convergence, or feedback
- Why "just pin everything" often creates more problems than it solves at scale
- Practical patterns for managing versions across environments with minimal operational overhead
</KeyPoints>

## The Version Management Challenge

Traditional Terraform/IaC wisdom advocates pinning every version per environment for reproducibility. While this improves predictability, it often creates significant challenges:

### Problems with Universal Pinning

1. **Optimizes for Divergence**: Each environment drifts unless you constantly update pins
2. **Weakens Cross-Environment Feedback**: Lower environments stay pinned to old versions, so `terraform plan` doesn't reveal cross-environment impact
3. **Requires Lockstep Promotion**: If dev received 10 incremental releases, production must receive those same 10 in order
4. **Creates Operational Overhead**: At scale, you'll face PR storms from automated dependency updates
5. **Complicates Third-Party Usage**: You don't control upstream cadence; forks and patches accumulate

### The Atmos Philosophy

Atmos's default philosophy differs from strict pinning: allow **transient divergence** but drive **convergence** to common versions across environments within a reasonable window. This approach improves feedback loops and reduces fragility while maintaining the ability to pin versions when truly necessary.

## Core Concepts

Before exploring the patterns, it's important to understand key distinctions:

### Deployment vs Release

- **Deployment**: Declaring that an environment should converge to a specific version of a component (the target state)
- **Release**: Actually updating the environment to that version (the change is applied)

Some teams use Git for both deployment and release (Git-as-source-of-truth _and_ rollout trigger), while others separate these concerns (e.g., Git for deployment, CI/CD for release).

### Trunk-Based Development vs Git Flow

Most version management patterns in Atmos follow **trunk-based development**, where:
- All changes flow through a single main branch (trunk)
- Versioning happens through tags, folders, or configuration files
- Environments pull from the same branch but use different version selectors
- Short-lived feature branches merge quickly back to main

This contrasts with **Git Flow**, which uses:
- Multiple long-lived branches representing different stages
- Environments tied to specific branches
- Promotion through merges between branches
- More complex branching strategies

## Available Patterns

This guide covers two primary deployment strategies you can implement using Atmos: **Continuous Version Deployment** (trunk-based, recommended) and **Git Flow** (branch-based). Within Continuous Version Deployment, you can use different folder organization approaches.

### Recommended Strategy: [Continuous Version Deployment](/design-patterns/version-management/continuous-version-deployment)

**The recommended trunk-based deployment strategy** where environments progressively converge to whatever component path they reference in stack configurations. All environments work from the main branch, using automation and progressive rollout to control deployment safety.

This approach:

- **Promotes convergence**: All environments converge to the same version through progressive rollout, reducing drift
- **Embraces trunk-based development**: Single source of truth in the main branch
- **Enables easy previews**: You can immediately see change impacts across all dependent environments
- **Simplifies operations**: No complex version tracking or branch management
- **Supports rapid iteration**: Deploy frequently with confidence

<File title="Example: All environments converge to same component">
```yaml
# stacks/dev/us-east-1.yaml, stacks/staging/us-east-1.yaml, stacks/prod/us-east-1.yaml
components:
  terraform:
    vpc:
      metadata:
        component: vpc  # All environments converge to this component path
      vars:
        # Environment-specific configuration
```
</File>

Use feature flags, environment-specific configuration, and deployment automation to control rollout. You can organize your components using different folder structures depending on your needs.

#### Folder Organization Approaches

Within Continuous Version Deployment, choose how to organize your component folders:

##### 1. [Folder-Based Versioning](/design-patterns/version-management/folder-based-versioning)
The foundational approach—organize components in simple folders (`vpc/`, `eks/`, `rds/`). What you see is what you get, with no magic. Explicit folder structure makes divergence visible and patching any version straightforward. All subsequent approaches build on this foundation.

##### 2. [Release Tracks/Channels](/design-patterns/version-management/release-tracks-channels)
Extends folder-based versioning with named release channels (`alpha/vpc`, `beta/vpc`, `prod/vpc`). Environments subscribe to moving tracks; you promote tracks, not individual environment pins.

##### 3. [Strict Version Pinning](/design-patterns/version-management/strict-version-pinning)
Creates explicit component versions following SemVer (`vpc/1.2.3`, `vpc/2.0.0`). Works well when vendoring from external sources or managing shared component libraries within your organization.

### Alternative Strategy: [Git Flow: Branches as Channels](/design-patterns/version-management/git-flow-branches-as-channels)

**The branch-based alternative** where long-lived branches map to release channels. Environments track branches; promotions happen via merges between branches. Uses simple folder-based versioning since branches serve as the versioning mechanism.

### Complementary Technique: [Vendoring Component Versions](/design-patterns/version-management/vendoring-components)

A technique that works with any deployment strategy to automate copying component versions from multiple external sources. Maintains a manifest tracking origin and lineage, providing strong local control with predictable update windows. Can be combined with any folder organization approach.

## Quick Comparison

| Strategy                 | Development Model | Convergence | Feedback During Plan | Rollback Ease | Overhead @ Scale | Version Skipping Risk |
|--------------------------|------------------|-------------|---------------------|---------------|------------------|----------------------|
| Strict Pinning           | Trunk-based      | Low         | Weak (late)         | Strong        | High             | **High Risk**        |
| Release Tracks/Channels  | Trunk-based      | High        | Strong              | Medium        | Medium           | Lower Risk           |
| Folder-Based Versioning  | Trunk-based      | Medium      | Strong (explicit)   | Medium        | Medium           | Lower Risk           |
| Vendoring                | Trunk-based      | Medium–High | Strong (local)      | Medium        | Medium           | Lower Risk           |
| **Component Pinning**    | **Trunk-based**  | **Very High** | **Strong**        | **Easy**      | **Low**          | **Minimal Risk**     |
| Git Flow (per channel)   | Branch-based     | Medium      | Medium              | Medium        | Medium–High      | High if skipped      |

## Choosing a Pattern

The right pattern depends on your organization's needs and culture. Consider these guiding questions:

1. **Roll Forward vs. Rollback**: Does your organization truly need to optimize for rollback, or do you have a culture of rolling forward quickly with strong testing and convergence?

2. **Team Size and Scale**: How many environments do you manage? Strict pinning becomes increasingly painful as environment count grows.

3. **Release Cadence**: How frequently do you update components? High-frequency updates favor patterns with strong convergence.

4. **Third-Party Dependencies**: How much of your infrastructure relies on external modules? Heavy third-party usage may benefit from vendoring.

5. **Operational Maturity**: Do you have strong CI/CD and testing practices? Mature practices enable safer use of convergent patterns.

## Best Practices

Regardless of the pattern you choose:

### 1. Keep `workspace_key_prefix` Stable
Never include version information in the `workspace_key_prefix` setting. This ensures Terraform state remains stable when switching versions or patterns.

```yaml
# WRONG: Version in workspace key
settings:
  workspace_key_prefix: "prod/vpc/v2"

# CORRECT: Stable workspace key
settings:
  workspace_key_prefix: "prod/vpc"
```

### 2. Document Version Decisions
Maintain clear documentation about which patterns you're using for which components and why. This helps new team members understand the versioning strategy.

### 3. Test Promotion Paths
Whatever pattern you choose, regularly test the full promotion path from development to production. Don't let environments diverge for extended periods.

### 4. Monitor Divergence
Set up monitoring to track version divergence across environments. Alert when environments drift beyond acceptable thresholds.

## Combining Patterns

You don't need to use a single pattern exclusively. Common combinations include:

- **Tracks for Applications, Pinning for Platform**: Use release tracks for frequently-updated application components while strictly pinning critical platform components
- **Vendoring + Tracks**: Vendor third-party code while using release tracks for internal components
- **Folder Versioning for Major Changes**: Use folder-based versioning for breaking changes while using tracks for routine updates

## Summary

Version management in infrastructure-as-code requires careful consideration of trade-offs. While strict version pinning provides reproducibility, it often creates more problems than it solves at scale. Atmos supports multiple patterns that allow you to optimize for your specific needs—whether that's rapid convergence, strong rollback capabilities, or predictable promotion paths.

The key is to choose patterns deliberately based on your organization's culture, scale, and operational maturity. Start with simpler patterns and evolve as your needs grow. Remember that the goal isn't perfect reproducibility—it's delivering reliable infrastructure changes with appropriate safety controls and feedback loops.

:::tip Next Steps
Review each pattern in detail to understand its implementation, trade-offs, and best practices. Start with the pattern that best matches your current workflow, then iterate based on experience.
:::

## Honorable Mention: Release Artifacts (Advanced)

For teams requiring immutable deployment records, consider creating **release artifacts** separate from Git that represent exactly what was deployed to each environment. These artifacts:

- Provide an immutable audit trail independent of Git history
- Support cryptographic signing for compliance requirements
- Enable exact reproduction of any historical deployment
- Decouple deployment records from version control changes

This pattern adds significant complexity. Beyond artifact generation, you must maintain a robust system of record that maps which artifact versions are deployed to each environment and manages their progression paths. This becomes particularly challenging in organizations with complex environment topologies that don't follow simple linear promotion flows.

## Related Patterns

- [Component Inheritance](/design-patterns/component-inheritance) - Base components that serve as blueprints
- [Component Catalog](/design-patterns/component-catalog) - Centralized component library
- [Multiple Component Instances](/design-patterns/multiple-component-instances) - Deploying multiple instances of the same component
