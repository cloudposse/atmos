---
title: Configuring Components in Stacks
sidebar_position: 2
sidebar_label: Components
id: define-components
---
import Intro from '@site/src/components/Intro'
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<Intro>
Components are configured in the `components` section of stack files. Each component type (Terraform, Helmfile, Packer) has its own configuration schema, but they share common patterns for `metadata` and `settings`.
</Intro>

## Component Types

Atmos supports multiple component types, each with its own stack configuration schema:

| Type | Description | Stack Config Reference |
|------|-------------|----------------------|
| **Terraform/OpenTofu** | Provision cloud infrastructure | [Stack Configuration](/components/terraform/stack-config) |
| **Helmfile** | Deploy Helm charts to Kubernetes | [Stack Configuration](/components/helmfile#stack-configuration) |
| **Packer** | Build machine images | [Stack Configuration](/components/packer#stack-configuration) |

## Component Schema

A Component consists of the infrastructure as code business logic (e.g. a Terraform "root" module) as well as the configuration of that
component. The configuration of a component is stored in a Stack configuration.

To configure a Component in a [Stack](/learn/stacks), you define the component in the `components` section of the Stack configuration.

:::info Disambiguation

- **Terraform Component** is a simply a [Terraform Root Module](https://developer.hashicorp.com/terraform/language/modules#the-root-module)
  that consists of the resources defined in the `.tf` files in a working directory
  (e.g. [components/terraform/infra/vpc](https://github.com/cloudposse/atmos/tree/main/tests/fixtures/scenarios/complete/components/terraform/infra/vpc))

- **Component Configuration** provides configuration (variables and other settings) for a type of component (e.g. a Terraform component)
  and is defined in one or more YAML stack config files (which are called [Atmos stacks](/learn/stacks))
:::

## Common Attributes

These attributes are available across all component types:

<dl>
  <dt>`vars` (optional)</dt>
  <dd>The `vars` section is a free-form map of variables passed to the component. Use [component validation](/validation/validating) to enforce policies.</dd>

  <dt>`metadata` (optional)</dt>
  <dd>The `metadata` section extends functionality of the component. See [Metadata Attributes](#metadata-attributes) below.</dd>

  <dt>`settings`</dt>
  <dd>The `settings` block is a free-form map used to pass configuration information to [integrations](/integrations).</dd>
</dl>

## Metadata Attributes

### Types of Components

In Atmos, each component configuration defines its type through the `metadata.type` parameter. This defines how the component behaves—whether it can be used directly to provision resources or serves as a base configuration for other components.

The type of component is expressed in the `metadata.type` parameter of a given component configuration.

There are two types of components:
<dl>
  <dt>`real`</dt>
  <dd>Think of a `real` component as one that can be deployed. It's fully configured and ready to be provisioned, similar to a "concrete" class in programming. Once defined, you can use it to create resources or services directly in your infrastructure.</dd>

  <dt>`abstract`</dt>
  <dd>An `abstract` component is more like a blueprint. It can't be deployed on its own. Instead, it's a base configuration that needs to be extended or inherited by other components. This is similar to an ["abstract base classes"](https://en.wikipedia.org/wiki/Abstract_type) in programming—it defines reusable configurations, but it's not complete enough to be deployed directly.</dd>
</dl>

### Disabling Components with `metadata.enabled`

The `metadata.enabled` parameter controls whether a component is included in deployment. By default, components are enabled. Setting `metadata.enabled` to `false` skips the component entirely—no workspace is created, and no Terraform commands are executed. Disabling a component does not cause deletion. It just signals that it's no longer managed by Atmos.

:::info Note
This should not be confused with [Cloud Posse's conventions and best practices](/best-practices/terraform/) of
having modules and components define a Terraform input named `enabled`.
This is a general convention and `vars.enabled` is not a special variable. Atmos does not treat it differently from any other variable.
:::

**Example**:
```yaml
# Disable a component in a specific environment
components:
  terraform:
    vpc:
      metadata:
        type: real
        enabled: false
      vars:
        name: primary-vpc
```
Using the `metadata.enabled` flag makes it easy to ensure that only the intended components are active in each environment.

### Locking Components with `metadata.locked`

The `metadata.locked` parameter prevents changes to a component while still allowing read operations. When a component is locked, operations that would modify infrastructure (like `terraform apply`) are blocked, while read-only operations (like `terraform plan`) remain available. By default, components are unlocked. Setting `metadata.locked` to `true` prevents any change operations.

:::info Note
Locking a component does not affect the Terraform state. It's intended as a way to communicate intention and prevent accidental changes to sensitive or critical infrastructure.
:::

**Example**:
```yaml
# Lock a production database component to prevent accidental changes
components:
  terraform:
    rds:
      metadata:
        locked: true
      vars:
        name: production-database
```

Using the `metadata.locked` flag helps protect critical infrastructure from unintended modifications while still allowing teams to inspect and review the configuration.

### Versioning Components with `metadata.component`

The `metadata.component` parameter specifies which component implementation to use when provisioning infrastructure. This is how you manage component versions in Atmos—by pointing to different component folders organized by version.

By default, if `metadata.component` is not specified, Atmos uses the component's name as the path. However, you can explicitly reference different versions or implementations by setting this parameter to point to versioned component folders.

#### Continuous Version Deployment

All environments point to the same component folder and converge to the same version. Versions are rolled out to each environment with release controls like approval gates in your deployment pipeline, decoupling release from deployment. This is the recommended default approach.

<Tabs>
<TabItem value="dev" label="Development">

**Release Control**: Automatically deployed when changes merge to main. No approval required.

```yaml
# stacks/dev/us-east-1.yaml
components:
  terraform:
    vpc:
      # Points to components/terraform/vpc/
      vars:
        name: dev-vpc
```
</TabItem>

<TabItem value="staging" label="Staging">

**Release Control**: Deployment approved after successful validation in development environment.

```yaml
# stacks/staging/us-east-1.yaml
components:
  terraform:
    vpc:
      # Points to components/terraform/vpc/ (same component as dev)
      vars:
        name: staging-vpc
```
</TabItem>

<TabItem value="prod" label="Production">

**Release Control**: Deployment approved after successful validation in staging environment. Manual approval gate enforced by deployment pipeline.

```yaml
# stacks/prod/us-east-1.yaml
components:
  terraform:
    vpc:
      # Points to components/terraform/vpc/ (same component as dev and staging)
      vars:
        name: prod-vpc
```
</TabItem>
</Tabs>

#### Release Tracks/Channels

Environments subscribe to named release channels. Versions are rolled out to each environment by promoting them through channels (alpha → beta → prod) as they're validated.

<Tabs>
<TabItem value="dev" label="Development">
```yaml
# stacks/dev/us-east-1.yaml
components:
  terraform:
    vpc:
      metadata:
        component: alpha/vpc  # Subscribe to alpha track
      vars:
        name: dev-vpc
```
</TabItem>

<TabItem value="staging" label="Staging">
```yaml
# stacks/staging/us-east-1.yaml
components:
  terraform:
    vpc:
      metadata:
        component: beta/vpc  # Subscribe to beta track
      vars:
        name: staging-vpc
```
</TabItem>

<TabItem value="prod" label="Production">
```yaml
# stacks/prod/us-east-1.yaml
components:
  terraform:
    vpc:
      metadata:
        component: prod/vpc  # Subscribe to production track
      vars:
        name: prod-vpc
```
</TabItem>
</Tabs>

#### Environment-Specific Versions

Each environment has its own component folder. Versions are rolled out to each environment independently, allowing complete divergence when needed.

<Tabs>
<TabItem value="dev" label="Development">
```yaml
# stacks/dev/us-east-1.yaml
components:
  terraform:
    vpc:
      metadata:
        component: dev/vpc  # Development-specific folder
      vars:
        name: dev-vpc
```
</TabItem>

<TabItem value="staging" label="Staging">
```yaml
# stacks/staging/us-east-1.yaml
components:
  terraform:
    vpc:
      metadata:
        component: staging/vpc  # Staging-specific folder
      vars:
        name: staging-vpc
```
</TabItem>

<TabItem value="prod" label="Production">
```yaml
# stacks/prod/us-east-1.yaml
components:
  terraform:
    vpc:
      metadata:
        component: prod/vpc  # Production-specific folder
      vars:
        name: prod-vpc
```
</TabItem>
</Tabs>

#### Strict Version Pinning

Each environment pins to an explicit version folder (typically using major.minor versioning). Versions are rolled out to each environment by manually updating version pins with release controls in place.

<Tabs>
<TabItem value="dev" label="Development">

**Release Control**: Manually update version pin in stack configuration, then deploy (with automation).

```yaml
# stacks/dev/us-east-1.yaml
components:
  terraform:
    vpc:
      metadata:
        component: vpc/1.3  # Latest version in dev
      vars:
        name: dev-vpc
```
</TabItem>

<TabItem value="staging" label="Staging">

**Release Control**: Manually update version pin in stack configuration, then deploy (with automation).

```yaml
# stacks/staging/us-east-1.yaml
components:
  terraform:
    vpc:
      metadata:
        component: vpc/1.2  # Validated version in staging
      vars:
        name: staging-vpc
```
</TabItem>

<TabItem value="prod" label="Production">

**Release Control**: Manually update version pin in stack configuration, then deploy (with automation).

```yaml
# stacks/prod/us-east-1.yaml
components:
  terraform:
    vpc:
      metadata:
        component: vpc/1.2  # Stable version in production
      vars:
        name: prod-vpc
```
</TabItem>
</Tabs>

:::tip Version Management Patterns
The `metadata.component` parameter is the foundation of [Version Management Patterns](/design-patterns/version-management) in Atmos. By organizing components into folders and using `metadata.component` to reference them, you can implement various versioning strategies:

- **[Continuous Version Deployment](/design-patterns/version-management/continuous-version-deployment)** - All environments converge to same component (recommended)
- **[Release Tracks/Channels](/design-patterns/version-management/release-tracks-channels)** - Named channels for progressive rollout
- **[Folder-Based Versioning](/design-patterns/version-management/folder-based-versioning)** - Environment-specific folders
- **[Strict Version Pinning](/design-patterns/version-management/strict-version-pinning)** - SemVer-based explicit versions

See [Version Management Patterns](/design-patterns/version-management) to learn how to choose and implement the right versioning strategy for your organization.
:::
