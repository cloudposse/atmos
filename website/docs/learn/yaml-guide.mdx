---
title: YAML in Atmos
sidebar_position: 4
sidebar_label: YAML Guide
description: Understanding how Atmos uses YAML for configuration
id: yaml-guide
slug: /learn/yaml
---
import File from '@site/src/components/File'
import Intro from '@site/src/components/Intro'

<Intro>
Atmos uses YAML as its configuration language because it's human-readable, portable, and powerful enough to handle complex infrastructure configurations. YAML in Atmos has a few party tricks up its sleeve—especially around scope and merging. We like to think of them as features, not bugs. (Okay, they're definitely features.)
</Intro>

Let's clear up the most common misconceptions and show you how to use YAML effectively in Atmos.

## YAML Scope is Depth-Relative

The most important thing to understand: **there is no file-level scope in Atmos**. When you import multiple YAML files, Atmos merges them into a single, unified configuration. The scope is determined by the depth in the YAML tree, not by which file something is defined in.

Think of it like this: Atmos processes all imports and sees one big YAML document. Variables and settings at the same depth in the tree have the same scope.

<File title="stacks/globals.yaml">
```yaml
vars:
  environment: production
  region: us-east-1
```
</File>

<File title="stacks/prod.yaml">
```yaml
import:
  - globals

vars:
  namespace: myapp

components:
  terraform:
    vpc:
      vars:
        cidr_block: "10.0.0.0/16"
```
</File>

After processing, Atmos sees this as one merged configuration:

```yaml
vars:
  environment: production
  region: us-east-1
  namespace: myapp

components:
  terraform:
    vpc:
      vars:
        cidr_block: "10.0.0.0/16"
```

All three variables (`environment`, `region`, `namespace`) have the same scope—they're all at the top-level `vars` depth.

## Deep Merge: Maps Combine, Values Override

When Atmos processes imports, it **deep merges** YAML configurations.

Think of it like layering transparencies: maps blend together, but when the same key appears in multiple layers, the top layer wins. It's infrastructure inheritance, YAML style.

Here's how it works:

- **Maps (objects) merge recursively** - Keys from both maps combine
- **Later values override earlier ones** - Import order matters
- **Lists replace entirely** - No list merging, last one wins

<File title="stacks/base.yaml">
```yaml
vars:
  tags:
    ManagedBy: Atmos
    Team: Platform

components:
  terraform:
    vpc:
      vars:
        enable_dns: true
        enable_nat: false
```
</File>

<File title="stacks/dev.yaml">
```yaml
import:
  - base

vars:
  tags:
    Environment: Development  # New key, merges in
    ManagedBy: Atmos-Dev      # Same key, overrides

components:
  terraform:
    vpc:
      vars:
        enable_nat: true  # Overrides false from base
        # enable_dns: true still inherited
```
</File>

**Result after merge:**

```yaml
vars:
  tags:
    ManagedBy: Atmos-Dev      # Overridden
    Team: Platform            # Inherited
    Environment: Development  # Added

components:
  terraform:
    vpc:
      vars:
        enable_dns: true   # Inherited
        enable_nat: true   # Overridden
```

:::tip
Import order matters! Atmos processes files sequentially. Later imports override earlier ones.
:::

## Dot Notation: Flatten Deep Nesting

When you only need to set one value in a deeply nested section, you don't have to create the full hierarchy. Use **dot notation** for cleaner, more readable configuration.

**Instead of this (verbose nesting):**

<File title="stacks/dev.yaml">
```yaml
components:
  terraform:
    vpc:
      metadata:
        component: vpc-base
        inherits:
          - vpc-defaults
      settings:
        spacelift:
          workspace_enabled: true
```
</File>

**You can write this (dot notation):**

<File title="stacks/dev.yaml">
```yaml
components:
  terraform:
    vpc:
      metadata.component: vpc-base
      metadata.inherits:
        - vpc-defaults
      settings.spacelift.workspace_enabled: true
```
</File>

Both configurations are equivalent, but dot notation is more concise when you're setting single values deep in the tree.

### When to Use Dot Notation

✅ **Use dot notation when:**
- Setting single values in deeply nested structures
- You want more readable configuration
- You're only touching one or two values in a section

❌ **Use traditional nesting when:**
- Setting multiple values in the same section
- You want to see the full structure at a glance
- You're defining complex nested objects

**Example: Mix both approaches**

<File title="stacks/prod.yaml">
```yaml
components:
  terraform:
    vpc:
      # Dot notation for single deep values
      metadata.component: vpc-base
      settings.spacelift.workspace_enabled: true

      # Traditional nesting for multiple related values
      vars:
        cidr_block: "10.0.0.0/16"
        enable_dns_hostnames: true
        enable_dns_support: true
        availability_zones:
          - us-east-1a
          - us-east-1b
          - us-east-1c
```
</File>

:::tip
Dot notation works anywhere in Atmos YAML—not just in component configuration. Use it in `vars`, `settings`, `env`, or any nested section.
:::

## YAML Tags: Native Functions

Atmos extends YAML with custom tags that act like native functions. Atmos processes these during YAML parsing, before templates run.

### Common YAML Tags

**`!ENV`** - Read environment variables

```yaml
vars:
  api_token: !ENV GITHUB_TOKEN
  region: !ENV AWS_REGION
```

**`!stack`** - Reference values from other stacks

```yaml
components:
  terraform:
    app:
      vars:
        vpc_id: !stack outputs.vpc.vpc_id
```

**`!template`** - Evaluate Go templates inline

```yaml
vars:
  bucket_name: !template "{{.vars.namespace}}-{{.vars.environment}}-data"
```

YAML tags are **evaluated once during YAML parsing**. They're perfect for simple value substitution.

## YAML Tags vs Go Templates

Atmos supports both YAML tags and Go templates. When should you use each?

<dl>
  <dt>**Use YAML Tags when:**</dt>
  <dd>
    - You need simple value substitution<br/>
    - You want native YAML syntax<br/>
    - You're reading environment variables or outputs
  </dd>

  <dt>**Use Go Templates when:**</dt>
  <dd>
    - You need conditional logic or loops<br/>
    - You're doing string manipulation<br/>
    - You need access to template functions (`atmos.Component`, `terraform.output`, etc.)
  </dd>
</dl>

**Example: YAML Tag**
```yaml
vars:
  # Simple substitution
  database_password: !ENV DB_PASSWORD
```

**Example: Go Template**
```yaml
vars:
  # Complex logic
  cluster_name: '{{ if eq .vars.environment "prod" }}prod-cluster{{ else }}dev-cluster{{ end }}'
```

:::info
Atmos processes Go templates **after** YAML tags. You can combine them:
```yaml
vars:
  token: !ENV API_TOKEN
  header: '{{ printf "Bearer %s" .vars.token }}'
```
:::

## Why YAML for Configuration?

YAML is ideal for infrastructure configuration because:

✅ **Human-readable** - Easy to read, write, and review in PRs
✅ **Supports comments** - Document your configuration inline
✅ **Hierarchical** - Natural fit for nested infrastructure config
✅ **Portable** - Every language can parse it
✅ **Type-aware** - Strings, numbers, booleans, null

Compare to alternatives:

| Format | Comments | Hierarchy | Type System | Complexity |
|--------|----------|-----------|-------------|------------|
| YAML   | ✅       | ✅        | ✅          | Low        |
| JSON   | ❌       | ✅        | ✅          | Low        |
| HCL    | ✅       | ✅        | ✅          | Medium     |

YAML keeps configuration simple while HCL handles the infrastructure logic.

## YAML Gotchas & How to Avoid Them

### 1. The `NO` Problem (Or: How Norway Broke YAML)

YAML has opinions about what counts as a boolean. Strong opinions.

Unfortunately, "NO" (Norway's country code) is one of them.

```yaml
# These are NOT strings
vars:
  yes_value: yes        # Becomes boolean true
  no_value: no          # Becomes boolean false (whoops, Norway!)
  version: 1.20         # Becomes float 1.2
  zip_code: 07094       # Becomes integer 7094
```

**Fix: Quote strings explicitly**

```yaml
vars:
  yes_value: "yes"      # String "yes"
  no_value: "no"        # String "no"
  version: "1.20"       # String "1.20"
  zip_code: "07094"     # String "07094"
```

### 2. Indentation Matters

YAML uses indentation for structure. Mixing tabs/spaces causes errors.

```yaml
# WRONG - Mixed indentation
components:
  terraform:
	vpc:  # Tab here
      vars:  # Spaces here
        cidr: "10.0.0.0/16"
```

**Fix: Use 2 spaces consistently**

```yaml
# CORRECT
components:
  terraform:
    vpc:
      vars:
        cidr: "10.0.0.0/16"
```

### 3. Special Characters in Strings

Characters like `:`, `{`, `[`, `>`, `|` have special meaning. Quote them:

```yaml
# WRONG
vars:
  url: https://example.com  # Colon causes parse error

# CORRECT
vars:
  url: "https://example.com"
```

## Key Takeaways

✅ **Scope is YAML-depth relative**, not file-level
✅ **Deep merge** combines maps, overrides values
✅ **Import order matters** - last import wins
✅ **Dot notation** for cleaner single-value assignments
✅ **YAML tags** for simple substitution
✅ **Go templates** for complex logic
✅ **Quote special values** to avoid type coercion

## What's Next

Now that you understand YAML in Atmos, you're ready to start building reusable configurations:

- **[Learn about Imports](/learn/imports-basics)** - Reuse configuration across stacks
- **[Learn about Inheritance](/learn/inheritance-basics)** - Create component variations
- **[Organize your Stacks](/learn/organizing-stacks)** - Structure for scale
