---
title: atmos terraform
sidebar_label: terraform
sidebar_class_name: command
---
import Screengrab from '@site/src/components/Screengrab'
import DocCardList from '@theme/DocCardList'
import Terminal from '@site/src/components/Terminal'
import Intro from '@site/src/components/Intro'
import ActionCard from '@site/src/components/ActionCard'

<Intro>
Use these subcommands to interact with Terraform and OpenTofu.
</Intro>

<Screengrab title="atmos terraform --help" slug="atmos-terraform--help" />

Atmos supports all Terraform and OpenTofu commands and options described in
[Terraform CLI Overview](https://developer.hashicorp.com/terraform/cli/commands)
and [OpenTofu Basic CLI Features](https://opentofu.org/docs/cli/commands/).

:::note Disambiguation
The term "Terraform" is used in this documentation to refer to generic concepts such as providers, modules, stacks, the
HCL-based domain-specific language and its interpreter. Atmos works with [OpenTofu](/components/terraform).
:::

## Command Modes

Atmos Terraform commands operate in two modes:

- **Single-Component**: Execute Terraform for one component at a time with precise control
- **Multi-Component**: Execute Terraform across multiple components using filters (`--all`, `--affected`, `--components`, `--query`)

## Single-Component Usage

Use single-component commands when you want to execute Terraform operations on one component at a time.

<Terminal>
```shell
atmos terraform <command> <component> -s <stack> [options]
```
</Terminal>

The `component` argument and `--stack` flag are required to generate variables and backend config for the component in the stack.

See individual command pages for detailed options: [plan](/cli/commands/terraform/plan), [apply](/cli/commands/terraform/apply), [deploy](/cli/commands/terraform/deploy), [destroy](/cli/commands/terraform/destroy).

### Path-Based Component Resolution

Atmos supports using filesystem paths instead of component names for convenience. This allows you to navigate to a component directory and use `.` to reference it:

<Terminal>
```shell
# Navigate to component directory
cd components/terraform/vpc

# Use . to reference current directory
atmos terraform plan . -s dev
atmos terraform apply . -s dev
```
</Terminal>

This automatically resolves the path to the component name configured in your stack, eliminating the need to remember exact component names.

**Supported path formats:**
- `.` - Current directory
- `./component` - Relative path from current directory
- `../other-component` - Relative path to sibling directory
- `/absolute/path/to/component` - Absolute path

**Requirements:**
- Must be inside a component directory under the configured base path
- Must specify `--stack` flag
- Component must exist in the specified stack configuration
- **The component path must resolve to a unique component name** - If multiple components in the stack reference the same component path, you must use the unique component name instead of the path

:::warning Path Resolution Limitation
Path-based resolution only works when the component path resolves to a **single unique component** in the stack.

For example, if both `station/1` and `station/2` reference `components/terraform/weather`:
```bash
cd components/terraform/weather
atmos terraform plan . --stack dev  # Error: ambiguous - which component?
```

Instead, you must use the unique component names:
```bash
atmos terraform plan station/1 --stack dev  # Explicit and unambiguous
atmos terraform plan station/2 --stack dev  # Explicit and unambiguous
```
:::

## Multi-Component Usage

Use multi-component commands to run Terraform operations across multiple components simultaneously. You can target components by stack, selector, query, or change detection.

<Terminal>
```shell
# Execute on all components in all stacks
atmos terraform <command> --all

# Execute on all components in a specific stack
atmos terraform <command> --stack prod

# Execute on specific components
atmos terraform <command> --components vpc,eks

# Execute on affected components (based on git changes)
atmos terraform <command> --affected

# Execute on components matching a query
atmos terraform <command> --query '.vars.tags.team == "eks"'
```
</Terminal>

All multi-component flags can be combined with `--dry-run` to preview what would be executed without making changes.

See individual command pages for detailed multi-component examples and flags: [plan](/cli/commands/terraform/plan#multi-component-operations), [apply](/cli/commands/terraform/apply#multi-component-operations), [deploy](/cli/commands/terraform/deploy#multi-component-operations), [destroy](/cli/commands/terraform/destroy#multi-component-operations).

## Differences from Native Terraform

Atmos enhances the standard Terraform CLI with several conveniences:

- **Automatic initialization**: Atmos runs `terraform init` before executing other commands. Use `--skip-init` to skip this step.

- **Deploy command**: `atmos terraform deploy` executes `terraform apply -auto-approve` for automated deployments.

- **Planfile support**: The `--from-plan` and `--planfile` flags enable two-stage plan/apply workflows. See [Terraform Planfiles](/components/terraform/planfiles).

- **Terraform Cloud compatibility**: Use `--skip-planfile` with `terraform plan` when using Terraform Cloud, which doesn't support local plan files.

- **Native flag passthrough**: Use `--` to pass flags directly to Terraform:
  ```shell
  atmos terraform plan vpc -s dev -- -refresh=false
  atmos terraform apply vpc -s dev -- -lock=false
  ```

:::tip
Run `atmos terraform --help` to see all available options.
:::

<ActionCard title="Configure Terraform" ctaText="Learn More" ctaLink="/cli/configuration/components/terraform">
  Learn how to configure Terraform components in your `atmos.yaml`, including backends, workspaces, and provider generation.
</ActionCard>

## Subcommands

<DocCardList />
