---
title: Configure Locals
sidebar_label: locals
sidebar_class_name: command
description: Use the locals section to define file-scoped temporary variables that reduce repetition and improve readability.
id: locals
---
import File from '@site/src/components/File'
import Intro from '@site/src/components/Intro'
import Experimental from '@site/src/components/Experimental'

<Intro>
The `locals` section defines file-scoped temporary variables for use within templates. Unlike `vars`, `settings`, and `env`, locals do **not** inherit across file boundaries—they are resolved within a single file and can reference each other with automatic dependency resolution.
</Intro>

<Experimental />

## Use Cases

- **Reduce Repetition:** Define common values once and reference them throughout the file.
- **Build Complex Values:** Construct naming conventions, tags, or resource identifiers from simpler components.
- **Improve Readability:** Give meaningful names to computed values instead of repeating expressions.
- **Template Composition:** Build values incrementally by referencing other locals.

## How Locals Work

Locals are similar to [Terraform locals](https://developer.hashicorp.com/terraform/language/values/locals) and [Terragrunt locals](https://terragrunt.gruntwork.io/docs/reference/config-blocks-and-attributes/#locals):

1. **File-Scoped:** Locals are only available within the file where they are defined. They do not inherit across imports.
2. **Dependency Resolution:** Locals can reference other locals using `{{ .locals.name }}` syntax. Atmos automatically determines the correct resolution order.
3. **Cycle Detection:** Circular references are detected and reported with clear error messages.
4. **Template Support:** Locals support Go templates with [Sprig functions](http://masterminds.github.io/sprig/).

## Configuration Scopes

The `locals` section can be defined at multiple levels within a single file. Each scope inherits from its parent scope within that file.

### Global Level

Locals defined at the root level are available to all sections in the file:

```yaml
# stacks/orgs/acme/plat/prod/us-east-1.yaml
locals:
  namespace: acme
  environment: prod
  stage: us-east-1
  name_prefix: "{{ .locals.namespace }}-{{ .locals.environment }}"

vars:
  cluster_name: "{{ .locals.name_prefix }}-eks"
```

### Component-Type Level

Locals defined under `terraform`, `helmfile`, or `packer` inherit from global locals and are available to all components of that type:

```yaml
# stacks/orgs/acme/plat/prod/us-east-1.yaml
locals:
  namespace: acme
  environment: prod

terraform:
  locals:
    # Inherits namespace and environment from global
    backend_bucket: "{{ .locals.namespace }}-{{ .locals.environment }}-tfstate"
    backend_key_prefix: "{{ .locals.environment }}"

  backend_type: s3
  backend:
    s3:
      bucket: "{{ .locals.backend_bucket }}"
      key: "{{ .locals.backend_key_prefix }}/terraform.tfstate"
```

### Using Locals in Components

Components can reference merged locals (global + component-type) in their `vars`. When the same key is defined at multiple scopes, later scopes take precedence: component-type locals override global locals, and component-level locals override both.

```yaml
# stacks/orgs/acme/plat/prod/us-east-1.yaml
locals:
  namespace: acme
  environment: prod
  name_prefix: "{{ .locals.namespace }}-{{ .locals.environment }}"

terraform:
  locals:
    backend_bucket: "{{ .locals.namespace }}-{{ .locals.environment }}-tfstate"

components:
  terraform:
    vpc:
      vars:
        # Uses merged locals (global + terraform section)
        vpc_name: "{{ .locals.name_prefix }}-vpc"
        bucket: "{{ .locals.backend_bucket }}"

    eks:
      vars:
        # Same merged locals available to all terraform components
        cluster_name: "{{ .locals.name_prefix }}-eks"
        bucket: "{{ .locals.backend_bucket }}"
```

:::tip Component-Level Locals
Components can also define their own `locals:` section. Component-level locals inherit from global and section-level locals, and also support inheritance from base components via `metadata.inherits`. See the [describe locals command](/cli/commands/describe/locals) for inspecting component-level locals.
:::

## Scope Inheritance (Within a File)

Within a single file, locals follow this inheritance chain:

```
Global locals
    ↓
Component-type locals (terraform/helmfile/packer)
    ↓
Component-level locals (inside component definitions)
```

Each level can:
- Access locals from parent scopes
- Define new locals
- Override parent locals with new values

Component-level locals also inherit from base components via `metadata.inherits` or `component` attribute.

:::note Precedence
When the same key exists at multiple levels, the most specific scope wins. For terraform components, the full precedence chain is:

**Global → Terraform Section → Base Component → Component**

This means component-level locals override section-level, which override global locals.
:::

### Example

```yaml
locals:
  env: prod              # Global

terraform:
  locals:
    env: production      # Overrides global for terraform components
    tf_version: "1.5"

components:
  terraform:
    vpc:
      vars:
        # Uses merged locals: env = "production", tf_version = "1.5"
        name: "{{ .locals.env }}-vpc"
        terraform_version: "{{ .locals.tf_version }}"
```

## File-Scoped Isolation

**Important:** Unlike `vars`, `settings`, and `env`, locals do **not** inherit across file imports. Each file has its own isolated locals scope.

<File title="stacks/catalog/defaults.yaml">
```yaml
# These locals are ONLY available in this file
locals:
  default_region: us-east-1
  default_tags:
    ManagedBy: Atmos
```
</File>

<File title="stacks/orgs/acme/plat/prod/us-east-1.yaml">
```yaml
import:
  - catalog/defaults

# The locals from catalog/defaults are NOT available here
# You must define your own locals in this file
locals:
  namespace: acme
  environment: prod
```
</File>

This design is intentional:
- **Predictability:** Locals in a file only come from that file
- **No Hidden Dependencies:** You can understand a file without tracing imports
- **Flexibility:** Each file can define locals that make sense for its context

### Processing Order

To understand why locals are file-scoped, it helps to know how Atmos processes stack files:

1. **Per-File Processing:** Each file (including imported files) is processed independently
2. **Locals Resolution:** Within each file, locals are resolved first using only that file's context
3. **Import Merging:** After all files are processed, their sections (`vars`, `settings`, `env`, `components`) are merged according to import precedence
4. **Final Template Processing:** Templates in `vars`, `settings`, and other sections are processed with the fully merged context

Since locals are resolved in step 2 (before imports are merged), they only have access to data from their own file. By the time imports are merged in step 3, locals resolution is already complete.

```
┌─────────────────────────────────────────────────────────────────────┐
│  File: stacks/deploy/production.yaml                                │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ 1. Parse YAML                                                 │  │
│  │ 2. Resolve locals (only sees this file's settings/vars/env)  │  │
│  │ 3. Process templates in other sections                        │  │
│  └───────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────┐
│  File: stacks/catalog/defaults.yaml (imported)                      │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ 1. Parse YAML                                                 │  │
│  │ 2. Resolve locals (only sees this file's settings/vars/env)  │  │
│  │ 3. Process templates in other sections                        │  │
│  └───────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
                                    ↓
┌─────────────────────────────────────────────────────────────────────┐
│  Merge Phase                                                        │
│  ┌───────────────────────────────────────────────────────────────┐  │
│  │ Merge vars, settings, env, components from all files         │  │
│  │ (locals are NOT merged - they're already resolved per-file)  │  │
│  └───────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

This architecture ensures that locals resolution is fast, predictable, and free of cross-file dependencies

## Dependency Resolution

Locals can reference other locals, and Atmos automatically resolves them in the correct order using topological sorting:

```yaml
locals:
  # These can be defined in any order
  full_name: "{{ .locals.name_prefix }}-{{ .locals.component }}"
  name_prefix: "{{ .locals.namespace }}-{{ .locals.environment }}"
  namespace: acme
  environment: prod
  component: vpc
```

Atmos resolves these in dependency order:
1. `namespace` and `environment` (no dependencies)
2. `component` (no dependencies)
3. `name_prefix` (depends on `namespace`, `environment`)
4. `full_name` (depends on `name_prefix`, `component`)

## Circular Dependency Detection

Atmos detects circular references and provides clear error messages:

```yaml
locals:
  a: "{{ .locals.b }}"
  b: "{{ .locals.c }}"
  c: "{{ .locals.a }}"  # Creates a cycle!
```

Error output:
```
circular dependency in locals at stacks/example.yaml

Dependency cycle detected:
  a → b → c → a
```

## Accessing Other Sections

Locals can access other sections defined in the **same file**. This is useful for building computed values based on your configuration.

### Available Template Context

Within a file, locals have access to:

| Section | Syntax | Description |
|---------|--------|-------------|
| `locals` | `{{ .locals.name }}` | Other locals in the same file |
| `settings` | `{{ .settings.key }}` | Settings defined in the same file |
| `vars` | `{{ .vars.key }}` | Variables defined in the same file |
| `env` | `{{ .env.KEY }}` | Environment variables defined in the same file |

### Example: Accessing Settings

```yaml
settings:
  version: v1
  validation:
    enabled: true
    strict_mode: false

locals:
  # Access settings from the same file
  api_version: "{{ .settings.version }}"
  validation_level: '{{ if .settings.validation.strict_mode }}strict{{ else }}standard{{ end }}'

vars:
  version: "{{ .locals.api_version }}"
```

### Example: Accessing Vars

```yaml
vars:
  base_name: myapp
  environment: production

locals:
  # Access vars from the same file
  full_name: "{{ .vars.base_name }}-{{ .vars.environment }}"
  log_path: "/var/log/{{ .vars.base_name }}"
```

:::warning Same-File Access Only
Locals can only access `settings`, `vars`, and `env` defined in the **same file**. Values from imported files are not available during locals resolution because imports are processed separately.

If you need to share values across files, use `vars` or `settings` instead of `locals`. These sections properly inherit across imports.

```yaml
# ❌ This won't work - settings from imported file not available
import:
  - catalog/defaults  # Has settings.region = us-east-1

locals:
  region: "{{ .settings.region }}"  # Error: settings.region not found

# ✅ Instead, use vars which inherit across imports
import:
  - catalog/defaults  # Has vars.region = us-east-1

vars:
  computed_name: "{{ .vars.region }}-cluster"  # Works!
```
:::

## Using Templates in Locals

Locals support full Go template syntax with [Sprig functions](http://masterminds.github.io/sprig/):

```yaml
locals:
  name: myapp
  environment: production

  # String manipulation
  upper_name: "{{ .locals.name | upper }}"
  quoted_env: '{{ .locals.environment | quote }}'

  # Conditionals
  log_level: '{{ if eq .locals.environment "production" }}warn{{ else }}debug{{ end }}'

  # Complex expressions
  resource_name: "{{ .locals.name }}-{{ .locals.environment | lower | trunc 4 }}"
```

## Complex Values

Locals can contain maps and lists, not just strings:

```yaml
locals:
  namespace: acme
  environment: prod

  # Map value
  default_tags:
    Namespace: "{{ .locals.namespace }}"
    Environment: "{{ .locals.environment }}"
    ManagedBy: Atmos

  # List value
  availability_zones:
    - us-east-1a
    - us-east-1b
    - us-east-1c

  # Nested structure
  backend_config:
    bucket: "{{ .locals.namespace }}-tfstate"
    region: us-east-1
    encrypt: true

vars:
  tags: "{{ .locals.default_tags }}"
  azs: "{{ .locals.availability_zones }}"
```

## Complete Example

<File title="stacks/orgs/acme/plat/prod/us-east-1.yaml">
```yaml
# Global locals - available throughout this file
locals:
  # Base identifiers
  namespace: acme
  tenant: platform
  environment: prod
  stage: us-east-1

  # Computed values
  name_prefix: "{{ .locals.namespace }}-{{ .locals.tenant }}-{{ .locals.environment }}"
  full_name: "{{ .locals.name_prefix }}-{{ .locals.stage }}"

  # Shared tags
  default_tags:
    Namespace: "{{ .locals.namespace }}"
    Tenant: "{{ .locals.tenant }}"
    Environment: "{{ .locals.environment }}"
    Stage: "{{ .locals.stage }}"
    ManagedBy: Atmos

# Use locals in global vars
vars:
  region: "{{ .locals.stage }}"
  tags: "{{ .locals.default_tags }}"

terraform:
  # Terraform-specific locals (inherit from global)
  locals:
    backend_bucket: "{{ .locals.namespace }}-{{ .locals.environment }}-tfstate"
    vpc_name: "{{ .locals.full_name }}-vpc"
    cluster_name: "{{ .locals.full_name }}-eks"

  backend_type: s3
  backend:
    s3:
      bucket: "{{ .locals.backend_bucket }}"
      region: "{{ .locals.stage }}"
      key: terraform.tfstate

# Components use merged locals (global + terraform section)
components:
  terraform:
    vpc:
      vars:
        name: "{{ .locals.vpc_name }}"
        cidr_block: "10.0.0.0/16"
        tags:
          Name: "{{ .locals.vpc_name }}"

    eks:
      vars:
        cluster_name: "{{ .locals.cluster_name }}"
        tags:
          Name: "{{ .locals.cluster_name }}"
```
</File>

## Locals vs Vars

| Aspect | `locals` | `vars` |
|--------|----------|--------|
| **Scope** | File-scoped only | Inherits across imports |
| **Purpose** | Temporary values for DRY | Input variables for components |
| **Output** | Not passed to components | Passed to Terraform/Helmfile/Packer |
| **Dependencies** | Can reference other locals, settings, vars, env from same file | Can reference locals after they're resolved |
| **Visibility** | Internal to stack config | Visible in component execution |
| **Cross-File Access** | Cannot access imported values | Can access merged values from all imports |

Use `locals` for intermediate computations within a single file, and `vars` for values that need to be passed to your components or shared across files.

### When to Use Each

**Use `locals` when:**
- You need temporary values to reduce repetition within a single file
- You're building computed values from other data in the same file
- The values are only relevant to template processing, not component execution

**Use `vars` when:**
- Values need to be passed to Terraform/Helmfile/Packer components
- Values need to be shared across multiple files via imports
- You need to reference values from imported catalog files

## Template Processing Behavior

When a file defines locals, template processing is automatically enabled for that file. This means any `{{ ... }}` syntax in the file will be processed as Go templates.

:::warning Conflicting Template Syntax
If your YAML files contain non-Atmos template syntax (such as Helm's `{{ ... }}`), adding locals will cause those templates to be processed incorrectly. To prevent this, you can disable template processing for specific imports:

```yaml
import:
  - path: catalog/helm-values
    skip_templates_processing: true  # Preserves {{ ... }} syntax as literal text
```

This is useful when importing files that contain:
- Helm chart values with Go template syntax
- Other templating systems that use `{{ }}`
- Literal strings that happen to contain template-like patterns
:::

## Best Practices

1. **Use for Repetition:** If you find yourself repeating the same value or expression, extract it to a local.

2. **Build Incrementally:** Start with simple locals and compose them into more complex values:
   ```yaml
   locals:
     namespace: acme
     env: prod
     prefix: "{{ .locals.namespace }}-{{ .locals.env }}"  # Build on simpler locals
     bucket: "{{ .locals.prefix }}-assets"                # Build on prefix
   ```

3. **Keep Locals Close:** Define locals near where they're used. If a local is only used in one component, define it at the component level.

4. **Use Descriptive Names:** Choose names that describe what the value represents, not how it's computed.

5. **Avoid Deep Nesting:** If you have many levels of local dependencies, consider simplifying or restructuring.

6. **Remember File Scope:** Don't expect locals from imported files—define what you need in each file.

7. **Use Vars for Cross-File Sharing:** If you need values available across multiple files, put them in `vars` or `settings` instead of `locals`. These sections properly merge across imports:
   ```yaml
   # stacks/catalog/defaults.yaml
   vars:
     shared_region: us-east-1  # Available to all files that import this

   # stacks/deploy/production.yaml
   import:
     - catalog/defaults

   vars:
     # Can reference vars from imported files
     bucket_name: "assets-{{ .vars.shared_region }}"
   ```

## Related

- [Variables (vars)](/stacks/vars)
- [Environment Variables (env)](/stacks/env)
- [Settings](/stacks/settings)
- [Imports](/stacks/imports)
- [YAML Functions](/functions/yaml)
