---
title: Atmos YAML Functions
sidebar_position: 1
sidebar_label: YAML Functions
sidebar_class_name: hidden
id: index
---


import File from '@site/src/components/File'
import PillBox from '@site/src/components/PillBox'
import Intro from '@site/src/components/Intro'
import DocCardList from '@theme/DocCardList'

<PillBox>Recommended</PillBox>

<Intro>
    **YAML Functions are the recommended way to add dynamic behavior to your Atmos configurations.** They are native YAML features that work with the YAML parser, making them type-safe, predictable, and error-resistant. Unlike template functions which manipulate raw text, YAML functions operate on structured data after parsing.
</Intro>

## Why YAML Functions Are Safer

YAML functions are based on [YAML Explicit typing](https://yaml.org/spec/1.2.2/)
and user-defined [Explicit Tags](https://yaml.org/spec/1.2.2/#tags) (local data types).
Explicit tags are denoted by the exclamation point (__"!"__) symbol.

**Key advantages over template functions:**
- **Cannot break YAML syntax** - Functions execute after YAML parsing, not before
- **Type-safe** - Work with actual YAML types, not raw strings
- **No indentation issues** - The YAML structure is already established
- **Clear error messages** - Errors point to specific YAML nodes, not parsing failures
- **Predictable behavior** - Always return valid YAML data structures

Atmos detects the tags in the stack manifests and executes the corresponding functions.

:::info
YAML supports three types of data: core, defined, and user-defined.

- **Core types**: Universally supported, including floats, integers, strings, lists, and maps.
- **Defined types**: Advanced types like binary data, specified in the YAML standard but not always supported.
- **User-defined types**: Custom extensions for classes, structures, and functions. Atmos leverages user-defined types to implement its custom functions and extend YAML's capabilities.
:::

## Use-cases

 - The [__`!append`__](/functions/yaml/append) YAML function concatenates lists during stack inheritance instead of replacing them,
   providing fine-grained control over list merging behavior on a per-field basis

 - The [__`!terraform.output`__](/functions/yaml/terraform.output) YAML function allows you to
   [access component outputs (remote state) directly within Atmos stack manifests](/core-concepts/share-data/remote-state).
   Note that this requires initializing each component (`terraform/tofu init`), which initializes all Terraform/OpenTofu
   modules and downloads all Terraform/OpenTofu providers, which may significantly impact performance. Consider using `!store` or `!terraform.state` functions instead, which don't have this performance penalty.

 - The [__`!terraform.state`__](/functions/yaml/terraform.state) YAML function reads outputs **directly from the configured Terraform or OpenTofu backend**, without initializing providers or running Terraform â€” it's **very fast** and currently supports [S3 and local backends](/core-concepts/components/terraform/backends) for accessing [remote state](/core-concepts/share-data/remote-state).

 - The [__`!store`__](/functions/yaml/store) YAML function allows reading the values from a
   remote [store](/core-concepts/projects/configuration/stores) (e.g. SSM Parameter Store, Artifactory, etc.)
   into Atmos stack manifests

 - The [__`!store.get`__](/functions/yaml/store.get) YAML function allows retrieving arbitrary keys
   directly from a [store](/core-concepts/projects/configuration/stores)
   without following the Atmos stack/component/key naming convention.
   This is useful for accessing values stored by external systems
   or for retrieving global configuration that doesn't belong to a specific component

 - The [__`!include`__](/functions/yaml/include) YAML function allows downloading local or remote files from different sources,
   and assigning the file contents or individual values to the sections in Atmos stack manifests

 - The [__`!template`__](/functions/yaml/template) YAML function is designed to [evaluate and inject outputs containing maps or lists](/functions/template/atmos.Component#handling-outputs-containing-maps-or-lists)
   into the YAML document, whether generated by the [__`atmos.Component`__](/functions/template/atmos.Component) template function or any Go template.

 - The [__`!exec`__](/functions/yaml/exec) YAML function is used to execute shell scripts and assign
   the results to the sections in Atmos stack manifests

 - The [__`!env`__](/functions/yaml/env) YAML function is used to retrieve environment variables
   and assign them to the sections in Atmos stack manifests

 - The [__`!repo-root`__](/functions/yaml/repo-root) YAML function is used to retrieve the
   root directory of the Atmos repository

:::tip
You can combine [Atmos Stack Manifest Templating](/core-concepts/stacks/templates) with Atmos YAML functions within the same stack configuration.
Atmos processes templates first, followed by YAML functions, enabling you to dynamically provide parameters to the YAML functions.
:::

## Atmos sections supporting YAML functions

You can use the YAML functions in all Atmos stack manifest sections:

  - `vars`
  - `settings`
  - `env`
  - `metadata`
  - `command`
  - `component`
  - `providers`
  - `overrides`
  - `backend`
  - `backend_type`
  - `remote_state_backend`
  - `remote_state_backend_type`

## Examples

<File title="stack.yaml">
```yaml
components:
  terraform:
    component2:
      settings:
        s1: !exec echo 's1'
      env:
        ENV_VAR_1: !template '{{ (atmos.Component "component3" .stack).settings.env.ENV_VAR_1 }}'
      vars:
        # Handle the output of type list from the `atmos.Component` template function
        test_1: !template '{{ toJson (atmos.Component "component1" "plat-ue2-dev").outputs.test_list }}'

        # Handle the output of type map from the `atmos.Component` template function
        test_2: !template '{{ toJson (atmos.Component "component1" .stack).outputs.test_map }}'

        # Execute the shell script and assign the result to the `test_3` variable
        test_3: !exec echo 42

        # Execute the shell script to get the `test_label_id` output from the `component1` component in the stack `plat-ue2-dev`
        test_4: !exec atmos terraform output component1 -s plat-ue2-dev --skip-init -- -json test_label_id

        # Execute the shell script to get the `test_map` output from the `component1` component in the current stack
        test_5: !exec atmos terraform output component1 -s {{ .stack }} --skip-init -- -json test_map

        # Execute the shell script to get the `test_list` output from the `component1` component in the current stack
        test_6: !exec atmos terraform output component1 -s {{ .stack }} --skip-init -- -json test_list

        # Get the `test_label_id` output of type string from the `component1` component in the stack `plat-ue2-dev`
        test_7: !terraform.output component1 plat-ue2-dev test_label_id

        # Get the `test_label_id` output of type string from the `component1` component in the current stack
        test_8: !terraform.output component1 {{ .stack }} test_label_id

        # Get the `test_list` output of type list from the `component1` component in the current stack
        test_9: !terraform.state component1 {{ .stack }} test_list

        # Get the `test_map` output of type map from the `component1` component in the current stack
        test_10: !terraform.state component1 {{ .stack }} test_map

        # Retrieve the value of an environment variable
        api_key: !env API_KEY

        # Include a local file
        config: !include ./dev-config.yaml

        # Download a remote JSON file with .json extension and query data using YQ
        # Note: URLs without extensions are treated as text, so use URLs with appropriate extensions
        github_data: !include ./github-meta.json .api

      settings:
        # Append to an inherited list instead of replacing it
        depends_on: !append
          - additional-component-1
          - additional-component-2
```
</File>

## Native Atmos YAML Functions

Atmos natively supports the following YAML functions:

<DocCardList/>
