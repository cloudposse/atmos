---
title: "!terraform.state"
sidebar_position: 2
sidebar_label: "!terraform.state"
sidebar_class_name: command
description: The FASTEST way to retrieve Terraform outputs - reads directly from state backends without initializing Terraform or downloading providers
---
import File from '@site/src/components/File'
import Intro from '@site/src/components/Intro'
import Terminal from '@site/src/components/Terminal'

<Intro>
The `!terraform.state` YAML function is the **fastest** way to read Terraform/OpenTofu outputs ([remote state](/core-concepts/share-data/remote-state))
in Atmos stack manifests. It retrieves outputs directly from the configured [backends](/core-concepts/components/terraform/backends)
without the overhead of initializing Terraform, downloading providers, or generating configuration files - making it significantly faster than `!terraform.output`.
</Intro>

:::tip
The `!terraform.state` YAML function supports the following backend types:
- `local` ([Terraform](https://developer.hashicorp.com/terraform/language/settings/backends/local) and [OpenTofu](https://opentofu.org/docs/language/settings/backends/local))
- `s3` ([Terraform](https://developer.hashicorp.com/terraform/language/settings/backends/s3) and [OpenTofu](https://opentofu.org/docs/language/settings/backends/s3))
- `gcs` ([Terraform](https://developer.hashicorp.com/terraform/language/settings/backends/gcs) and [OpenTofu](https://opentofu.org/docs/language/settings/backends/gcs))
- `azurerm` ([Terraform](https://developer.hashicorp.com/terraform/language/settings/backends/azurerm) and [OpenTofu](https://opentofu.org/docs/language/settings/backends/azurerm))

As support for new backend types is added, this document will be updated accordingly.

Meanwhile, if you are using backends other than `local`, `s3`, `gcs`, and `azurerm`, consider the [__`!store`__](/functions/yaml/store)
or [__`!terraform.output`__](/functions/yaml/terraform.output) YAML function to read remote state
and [share data between components](/core-concepts/share-data).
:::

## Usage

The `!terraform.state` function can be called with either two or three parameters:

```yaml
  # Get the `output` of the `component` in the current stack
  !terraform.state <component> <output>

  # Get the `output` of the `component` in the provided `stack`
  !terraform.state <component> <stack> <output>

  # Get the output of the `component` by evaluating the YQ expression
  !terraform.state <component> <yq-expression>

 # Get the output of the `component` in the provided `stack` by evaluating the YQ expression
  !terraform.state <component> <stack> <yq-expression>
```

## Arguments

<dl>
  <dt>`component`</dt>
  <dd>Atmos component name</dd>

  <dt>`stack`</dt>
  <dd>(Optional) Atmos stack name</dd>

  <dt>`output` or `yq-expression`</dt>
  <dd>Terraform output or [YQ](https://mikefarah.gitbook.io/yq) expression to evaluate the output</dd>
</dl>


:::tip
You can use [Atmos Stack Manifest Templating](/core-concepts/stacks/templates) in the `!terraform.state` YAML function expressions.
Atmos processes the templates first, and then executes the `!terraform.state` function, allowing you to provide the parameters to
the function dynamically.
:::

## Deferred Evaluation During Merge

Atmos uses **deferred evaluation** when processing YAML functions during configuration merging. This prevents type conflicts that can occur when inheriting and overriding values across multiple stack layers.

### The Problem: Type Conflicts

Without deferred evaluation, mixing concrete values and YAML functions in the inheritance chain would cause errors:

```yaml
# Base catalog (catalog/vpc/defaults.yaml)
components:
  terraform:
    vpc:
      vars:
        cidr_block: "10.0.0.0/16"  # Concrete string value

# Environment override (stacks/prod/networking.yaml)
components:
  terraform:
    vpc:
      vars:
        cidr_block: !terraform.state network-config cidr_block  # YAML function - different type!
```

In this scenario, Atmos would attempt to merge a string (`"10.0.0.0/16"`) with a YAML function reference during the configuration merge process, resulting in a type mismatch.

### The Solution: Deferred Merge

Atmos now **defers the evaluation** of YAML functions (including `!terraform.state`, `!terraform.output`, `!template`, `!store.get`, `!exec`, and `!env`) until after all configuration layers have been merged. This three-phase approach eliminates type conflicts:

1. **Defer Phase** - YAML functions are identified and temporarily replaced with placeholders
2. **Merge Phase** - All configuration layers merge without type conflicts
3. **Evaluate Phase** - YAML functions are evaluated and applied to the final merged result

With deferred evaluation, the example above works seamlessly. The YAML function in the override layer is deferred during merge, then evaluated after merging completes, correctly replacing the base value.

### Benefits

- **Flexible Configuration Patterns** - Mix static values and YAML functions across inheritance layers without conflicts
- **Gradual Migration** - Migrate from static to dynamic configurations incrementally
- **Team Collaboration** - Different teams can use different approaches (static vs. templated) in their layers
- **Multi-Environment Support** - Use static values in dev/staging and YAML functions in production

## `!terraform.state` Function Execution Flow

When processing the `!terraform.state` YAML function for a component in a stack, Atmos executes the following steps:

- **Stack and Component Context Resolution**
Atmos resolves the full context for the specified component within the given stack, including all inherited and merged
configuration layers (globals, environment and component-level config).

- **Terraform State Backend Lookup and Read**
Based on the resolved context, Atmos identifies the corresponding backend for the component in the stack
and reads the state file directly from the backend. If access to the backend requires a role assumption
(e.g. `assume_role.role_arn` for the `s3` backend), Atmos assumes the role before accessing the backend state file.

- **Output Parsing and Interpolation**
The relevant output variable is extracted from the state file (using a [YQ](https://mikefarah.gitbook.io/yq/) parser).
Atmos parses and interpolates the value into the final configuration structure, replacing the `!terraform.state`
directive in the YAML stack manifest with the final value.

:::tip Performance Advantage
**`!terraform.state` is dramatically faster than `!terraform.output`** - often 10-100x faster depending on your infrastructure size.

While `!terraform.output` must:
- Initialize Terraform/OpenTofu
- Download and initialize all providers
- Generate varfiles and backend configs
- Execute terraform commands

`!terraform.state` bypasses all of this overhead by reading directly from the state backend.

Use `!terraform.state` when you need the **fastest possible** access to Terraform outputs. The functions accept the same parameters and produce identical results.

Compare the [!terraform.output Execution Flow](/functions/yaml/terraform.output#terraformoutput-function-execution-flow) with the
[!terraform.state Execution Flow](/functions/yaml/terraform.state#terraformstate-function-execution-flow) to see the dramatic difference.
:::

## Using YQ Expressions to retrieve items from complex output types

To retrieve items from complex output types such as maps and lists, or do any kind of filtering or querying,
you can utilize [YQ](https://mikefarah.gitbook.io/yq) expressions.

For example:

- Retrieve the first item from a list

```yaml
subnet_id1: !terraform.state vpc .private_subnet_ids[0]
```

- Read a key from a map

```yaml
username: !terraform.state config .config_map.username
```

For more details, review the following docs:

- [YQ Guide](https://mikefarah.gitbook.io/yq)
- [YQ Recipes](https://mikefarah.gitbook.io/yq/recipes)

## Handling YQ Expressions with Bracket Notation and Quotes

When you access map keys that contain special characters (such as hyphens) by using YQ bracket notation, you must wrap the key in double quotes like `["github-dependabot"]`. This often clashes with the surrounding quotes that protect the entire expression in YAML.

To avoid conflicting quotes, wrap the entire YQ expression in single quotes while keeping the double quotes inside the brackets:

```yaml
# Use single quotes around the expression to allow double quotes inside brackets
access_key_id: !terraform.state security '.outputs.users["github-dependabot"].access_key_id'
```

Additional examples:

```yaml
# Access map keys with special characters
api_key: !terraform.state config '.outputs.api_keys["service-account-1"]'

# Access nested maps with special characters in multiple levels
endpoint: !terraform.state services '.outputs.endpoints["my-service"]["production"]'

# Combine with stack templating
token: !terraform.state identity {{ .stack }} '.outputs.tokens["github-actions"]'

# Escape single quotes by doubling them when needed inside the expression
app_name: !terraform.state config '.outputs.apps["app''s-name"].display_name'
```

**Quote escaping rules**

- Wrap the entire YQ expression in single quotes when it contains double quotes.
- Use double quotes inside brackets for string keys in YQ expressions.
- If you need single quotes inside the expression, escape them by doubling: `''`.

:::tip
This quoting pattern works for every Atmos YAML function that accepts YQ expressions, including [!terraform.output](/functions/yaml/terraform.output) and [!include](/functions/yaml/include).
:::

## Using YQ Expressions to provide a default value

If the component for which you are reading the output has not been provisioned yet, the `!terraform.state` function
will return `null`, unless you specify a [default value](https://mikefarah.gitbook.io/yq/operators/alternative-default-value)
in the YQ expression, in which case the function will return the default value.

This will allow you to mock outputs when executing `atmos terraform plan` where there are dependencies between components,
and the dependent components are not provisioned yet.

:::note
To provide a default value, you use the `//` YQ operator.
The whole YQ expression contains spaces, and to make it a single parameter, you need to double-quote it.

YQ requires the strings in the default values to be double-quoted as well.
This means that you have to escape the double-quotes in the default values by using two double-quotes.
:::

For example:

- Specify a string default value.
  Read the `username` output from the `config` component in the current stack.
  If the `config` component has not been provisioned yet, return the default value `default-user`

```yaml
username: !terraform.state config ".username // ""default-user"""
```

- Specify a list default value.
  Read the `private_subnet_ids` output from the `vpc` component in the current stack.
  If the `vpc` component has not been provisioned yet, return the default value `["mock-subnet1", "mock-subnet2"]`

```yaml
subnet_ids: !terraform.state vpc ".private_subnet_ids // [""mock-subnet1"", ""mock-subnet2""]"
```

- Specify a map default value.
  Read the `config_map` output from the `config` component in the current stack.
  If the `config` component has not been provisioned yet, return the default value `{"api_endpoint": "localhost:3000", "user": "test"}`

```yaml
config_map: !terraform.state 'config ".config_map // {""api_endpoint"": ""localhost:3000"", ""user"": ""test""}"'
```

For more details, review the following docs:

- [YQ Alternative (Default value)](https://mikefarah.gitbook.io/yq/operators/alternative-default-value)

## Using YQ Expressions to modify values returned from the remote state

Since the `output` parameter of the `!terraform.state` function is a [YQ](https://mikefarah.gitbook.io/yq) expression,
you can use [YQ pipes](https://mikefarah.gitbook.io/yq/operators/pipe) and
[YQ operators](https://mikefarah.gitbook.io/yq/operators) (including [YQ string concatenation functions](https://mikefarah.gitbook.io/yq/operators/add#string-concatenation)
and [YQ arithmetic functions](https://mikefarah.gitbook.io/yq/operators/add))
to modify the values returned from the remote state.

For example, suppose you have an `aurora-postgres` Atmos component which has the output `master_hostname`.

To read the output without modification, you can use the following expressions:

```yaml
postgres_url: !terraform.state aurora-postgres master_hostname
```

```yaml
postgres_url: !terraform.state aurora-postgres .master_hostname
```

To prepend and append strings to the output, you can use YQ pipes and the `add` function (`+` operator):

```yaml
postgres_url: !terraform.state aurora-postgres ".master_hostname | ""jdbc:postgresql://"" + . + "":5432/events"""
```

:::note
The double quotes are required around the whole YQ expression, and around the strings inside the YQ expression,
hence the double-double quotes `""` to escape it.
:::

After the `!terraform.state` function is executed, the `postgres_url` variable will have the final value similar to:

```yaml
postgres_url: "jdbc:postgresql://aurora-postgres-cluster-writer.prod.plat.mydomain.net:5432/events"
```

For more details, review the following docs:

- [YQ pipe](https://mikefarah.gitbook.io/yq/operators/pipe)
- [YQ operators](https://mikefarah.gitbook.io/yq/operators)
- [YQ string concatenation](https://mikefarah.gitbook.io/yq/operators/add#string-concatenation)
- [YQ `add` function](https://mikefarah.gitbook.io/yq/operators/add)

## Examples

<File title="stack.yaml">
```yaml
components:
  terraform:
    my_lambda_component:
      vars:
        vpc_config:
          # Output of type string
          security_group_id: !terraform.state security-group/lambda id
          security_group_id2: !terraform.state security-group/lambda2 {{ .stack }} id
          security_group_id3: !terraform.state security-group/lambda3 {{ .atmos_stack }} id
          # Output of type list
          subnet_ids: !terraform.state vpc private_subnet_ids
          # Use a YQ expression to get an item from the list
          subnet_id1: !terraform.state vpc .private_subnet_ids[0]
          # Output of type map
          config_map: !terraform.state config {{ .stack }} config_map
          # Use a YQ expression to get a value from the map
          username: !terraform.state config .config_map.username
```
</File>

## Specifying Atmos `stack`

If you call the `!terraform.state` function with three parameters, you need to specify the stack as the second argument.

There are multiple ways you can specify the Atmos stack parameter in the `!terraform.state` function.

### Hardcoded Stack Name

Use it if you want to get an output from a component from a different (well-known and static) stack.
For example, you have a `tgw` component in a stack `plat-ue2-dev` that requires the `vpc_id` output from the `vpc` component from the stack `plat-ue2-prod`:

```yaml title="plat-ue2-dev"
  components:
    terraform:
      tgw:
        vars:
          vpc_id: !terraform.state vpc plat-ue2-prod vpc_id
```

### Reference the Current Stack Name

Use the `.stack` (or `.atmos_stack`) template identifier to specify the same stack as the current component is in
(for which the `!terraform.state` function is executed):

```yaml
  !terraform.state <component> {{ .stack }} <output>
  !terraform.state <component> {{ .atmos_stack }} <output>
```

For example, you have a `tgw` component that requires the `vpc_id` output from the `vpc` component in the same stack:

```yaml
  components:
    terraform:
      tgw:
        vars:
          vpc_id: !terraform.state vpc {{ .stack }} vpc_id
```

:::note
Using the `.stack` or `.atmos_stack` template identifiers to specify the stack is the same as calling the `!terraform.state`
function with two parameters without specifying the current stack, but without using `Go` templates.
If you need to get an output of a component in the current stack, using the `!terraform.state` function with two parameters
is preferred because it has a simpler syntax and executes faster.
:::

### Use a Format Function

Use the `printf` template function to construct stack names using static strings and dynamic identifiers.
This is convenient when you want to override some identifiers in the stack name:

```yaml
  !terraform.state <component> {{ printf "%s-%s-%s" .vars.tenant .vars.environment .vars.stage }} <output>

  !terraform.state <component> {{ printf "plat-%s-prod" .vars.environment }} <output>

  !terraform.state <component> {{ printf "%s-%s-%s" .settings.context.tenant .settings.context.region .settings.context.account }} <output>
```

<dl>
  <dt>`<component>`</dt>
  <dd>Placeholder for an actual component name (e.g. `vpc`)</dd>
  <dt>`<output>`</dt>
  <dd>Placeholder for an actual Terraform output (e.g. `subnet_ids`)</dd>
</dl>


For example, you have a `tgw` component deployed in the stack `plat-ue2-dev`. The `tgw` component requires the
`vpc_id` output from the `vpc` component from the same environment (`ue2`) and same stage (`dev`), but from a different
tenant `net` (instead of `plat`):

```yaml title="plat-ue2-dev"
  components:
    terraform:
      tgw:
        vars:
          vpc_id: !terraform.state vpc {{ printf "net-%s-%s" .vars.environment .vars.stage }} vpc_id
```

:::tip Important
    By using the `printf "%s-%s-%s"` function, you are constructing stack names using the stack context variables/identifiers.

    For more information on Atmos stack names and how to define them, refer to `stacks.name_pattern` and `stacks.name_template`
    sections in [`atmos.yaml` CLI config file](/cli/configuration/)
:::


## Caching the result of `!terraform.state` function

Atmos caches (in memory) the results of `!terraform.state` function.

The cache is per Atmos CLI command execution, e.g., each new execution of a command like `atmos terraform plan`,
`atmos terraform apply` or `atmos describe component` will create and use a new memory cache, which involves re-reading the remote state after reinitialisation.

If you define the function in stack manifests for the same component in a stack more than once, the first call will
produce the result and cache it, and all the consecutive calls will just use the cached data. This is useful when you use the
`!terraform.state` function for the same component in a stack in multiple places in Atmos stack manifests.
It will speed up the function execution and stack processing.

For example:

<File>
```yaml
components:
  terraform:
    test2:
      vars:
        tags:
          test: !terraform.state test id
          test2: !terraform.state test id
          test3: !terraform.state test {{ .stack }} id
```
</File>

In the example, the `test2` Atmos component uses the outputs (remote state) of the `test` Atmos component from the same stack.
The YAML function `!terraform.state` is executed three times (once for each tag).

After the first execution, Atmos caches the result in memory,
and reuses it in the next two calls to the function. The caching makes the stack processing much faster.
In a production environment where many components are used, the speedup can be significant.

## Using `!terraform.state` with GCS backend

The GCS backend support allows you to read Terraform state files stored in Google Cloud Storage buckets. Here's an example configuration:

<File title="stacks/gcp/dev.yaml">
```yaml
components:
  terraform:
    my_component:
      backend_type: gcs
      backend:
        gcs:
          bucket: "my-terraform-state"
          prefix: "terraform/state"
          credentials: "/path/to/service-account-key.json"
      vars:
        # Read state from another component
        vpc_id: !terraform.state vpc dev vpc_id
        subnet_ids: !terraform.state subnets dev subnet_ids
        # Use YQ expression to get specific subnet
        public_subnet_id: !terraform.state subnets dev .subnet_ids[0]
```
</File>

### GCS Backend Authentication

The GCS backend supports multiple authentication methods:

1. **Service Account Key File**: Specify the path to a service account JSON key file using the `credentials` parameter.
2. **Default Credentials**: When no credentials are specified, the Google Cloud SDK default credentials are used.
3. **Workload Identity** (GKE): Automatically uses the workload identity when running in GKE with Workload Identity enabled.

### GCS Backend Configuration Parameters

- `bucket`: The GCS bucket name where Terraform state files are stored
- `prefix`: Optional prefix for the state file path within the bucket
- `credentials`: Optional path to a service account JSON key file
- `state_file`: Optional custom name for the state file (defaults to `default.tfstate`)

:::note Current Limitations
The `impersonate_service_account` parameter is parsed but not yet implemented. This feature is planned for a future release.
:::

## Using `!terraform.state` with `static` remote state backend

Atmos supports [brownfield configuration by using the remote state of type `static`](/core-concepts/components/terraform/brownfield/#hacking-remote-state-with-static-backends).

For example:

<File title="stack.yaml">
```yaml
components:
  terraform:
    # Component `static-backend` is configured with the remote state backend of type `static`
    static-backend:
      remote_state_backend_type: static
      remote_state_backend:
        static:
          region: "us-west-2"
          cluster_name: "production-cluster"
          vpc_cidr: "10.0.0.0/16"
          database:
            type: "postgresql"
            version: "12.7"
            storage_gb: 100
          allowed_ips:
            - "192.168.1.0/24"
            - "10.1.0.0/16"
          tags:
            Environment: "production"
            Owner: "infra-team"

    eks-cluster:
      vars:
        region: !terraform.state static-backend region
        cluster_name: !terraform.state static-backend cluster_name
        vpc_cidr: !terraform.state static-backend vpc_cidr
        db_type: !terraform.state static-backend database.type
        db_storage: !terraform.state static-backend database.storage_gb
        allowed_ips: !terraform.state static-backend allowed_ips
        tags: !terraform.state static-backend tags
```
</File>

When the functions are executed, Atmos detects that the `static-backend` component has the `static` remote state configured,
and instead of executing `terraform output`, it just returns the static values from the `remote_state_backend.static` section.

Executing the command `atmos describe component eks-cluster -s <stack>` produces the following result:

<Terminal title="atmos describe component eks-cluster -s <stack>">
```yaml
vars:
  region: us-west-2
  cluster_name: production-cluster
  vpc_cidr: 10.0.0.0/16
  db_type: postgresql
  db_storage: 100
  allowed_ips:
    - 192.168.1.0/24
    - 10.1.0.0/16
  tags:
    Environment: production
    Owner: infra-team
```
</Terminal>

## Considerations

 - Using `!terraform.state` with secrets can expose sensitive data to standard output (stdout) in any commands that describe stacks or components.

 - When using `!terraform.state` with [`atmos describe affected`](/cli/commands/describe/affected), Atmos requires access to all referenced remote states.
  If you operate with limited permissions (e.g., scoped to `dev`) and reference production stacks, the command will fail.

 - Overusing the function within stacks to reference multiple components can impact performance.

 - Be mindful of disaster recovery (DR) implications when using it across regions.

 - Consider cold-start scenarios: if the referenced component's state file doesn't exist (e.g., not yet provisioned), `!terraform.state` returns `null`.
   Use the YQ `//` operator to provide default values for components that may not be provisioned yet (see [Using YQ Expressions to provide a default value](#using-yq-expressions-to-provide-a-default-value)).
