---
title: Atmos Components
sidebar_position: 2
sidebar_label: Build Components
description: Components are opinionated building blocks of infrastructure as code that solve one specific problem or use-case.
---

Components are opinionated, self-contained building blocks of Infrastructure-as-Code (IAC) that solve one specific problem or use-case. 
Examples of componets are things like VPCs, Clusters, Databases, Buckets, Load Balancers, etc. But it's not limited to this. They can be anything.
Those Components are then configured inside of one or more [Stacks](/core-concepts/stacks).

The most common use-case for Atmos is using [Terraform "root modules"](https://developer.hashicorp.com/terraform/language/modules#the-root-module)
as components that are configured in stacks. 
But since Atmos was designed to be tool-agnostic, and [custom commands](/core-concepts/custom-commands) can be made to work with Atmos.

:::tip
Components are things like [Terraform "root" modules](https://developer.hashicorp.com/terraform/language/modules#the-root-module), Helm Charts, Dockerfiles, or any fundamental building block of infrastructure.
:::

## Use-cases

Components offer a multitude of applications across various business scenarios. Cloud Posse publishes its AWS components for free, so you can see
some [technical use-cases for Terraform components](https://docs.cloudposse.com/components/category/aws/).

- **Accelerate Development Cycles:** By reusing components, development teams can significantly shorten the time from concept to deployment, facilitating faster product iterations and quicker responses to market changes.

- **Security policies and compliance controls** DevOps and SecOps teams implement components to uniformly apply security policies and compliance controls across all cloud environments, ensuring regulatory adherence.

- **Enhance Collaboration Across Teams:** Components foster a shared understanding and approach to infrastructure, promoting collaboration between development, operations, and security teams, leading to more cohesive and secure product development.

## Flavors of Components

Atmos natively supports two kinds of components, but using [custom commands](/core-concepts/custom-commands), the [CLI](/cli) can be extended to support anything (e.g. `docker`, `packer`, `ansible`, etc.)

1. **Terraform:** These are stand-alone "root modules" that implement some piece of your infrastructure. For example, typical components might be an
   EKS cluster, RDS cluster, EFS filesystem, S3 bucket, DynamoDB table, etc. You can find
   the [full library of SweetOps Terraform components on GitHub](https://github.com/cloudposse/terraform-aws-components). By convention, we store
   components in the `components/terraform/` directory within the infrastructure repository.

2. **Helmfiles**: These are stand-alone applications deployed using [`helmfile`](https://github.com/helmfile) to Kubernetes. For example, typical
   helmfiles might deploy the DataDog agent, `cert-manager` controller, `nginx-ingress` controller, etc. By convention, we store these types of components in the `components/helmfile/` directory within the infrastructure repository.

## Terraform Components

One important distinction about components that is worth noting about Terraform components is they should be opinionated Terraform "root" modules that typically call other child modules. Components are the building blocks of your infrastructure. This is where you define all the business logic for provisioning some common piece of infrastructure like ECR repos (with the [ecr](https://github.com/cloudposse/terraform-aws-components/tree/master/modules/ecr) component) or EKS clusters (with the [eks/cluster](https://github.com/cloudposse/terraform-aws-components/tree/master/modules/eks/cluster) component). Our convention is to stick Terraform components in the `components/terraform/` directory.

If your components rely on submodules, our convention is to use a `modules/` subfolder of the component to store them.

We do not recommend consuming one terraform component inside of another as that would defeat the purpose; each component is intended to be
a loosely coupled unit of IaC with its own lifecycle. Furthermore, since components define a state backend and providers, it's not advisable to call one root module from another root module.
