---
title: "!terraform.output"
sidebar_position: 3
sidebar_label: "!terraform.output"
description: Read the remote state of any Atmos component
---
import File from '@site/src/components/File'
import Intro from '@site/src/components/Intro'

<Intro>
The `!terraform.output` YAML function allows reading the outputs ([remote state](/core-concepts/components/terraform/remote-state))
of components directly in Atmos stack manifests.
</Intro>

## Usage

```yaml
  !terraform.output <component> <stack> <output>
```

## Arguments

<dl>
  <dt>`component`</dt>
  <dd>Atmos component name</dd>

  <dt>`stack`</dt>
  <dd>Atmos stack name</dd>

  <dt>`output`</dt>
  <dd>Terraform output</dd>
</dl>


:::tip
You can use [Atmos Stack Manifest Templating](/core-concepts/stacks/templates) in the `!terraform.output` YAML function expressions.
Atmos processes the templates first, and then executes the `!terraform.output` function, allowing you to provide the parameters to
the function dynamically.
:::

## Examples

<File title="stack.yaml">
```yaml
components:
  terraform:
    my_lambda_component:
      vars:
        vpc_config:
          # Output of type string
          security_group_id: !terraform.output security-group/lambda {{ .stack }} id
          # Output of type list
          subnet_ids: !terraform.output vpc {{ .stack }} private_subnet_ids
          # Output of type map
          config_map: !terraform.output config {{ .stack }} config_map
```
</File>

## Specifying Atmos `stack`

There are multiple ways you can specify the Atmos stack parameter in the `!terraform.output` function.

The `stack` argument is the second argument of the `!terraform.output` function, and it can be specified in a few different ways:

### Hardcoded Stack Name

Hardcoded stack name.
Use it if you want to get an output from a component from a different (well-known and static) stack.
For example, you have a `tgw` component in a stack `plat-ue2-dev` that requires the `vpc_id` output from the `vpc` component from the stack `plat-ue2-prod`:

```yaml title="plat-ue2-dev"
  components:
    terraform:
      tgw:
        vars:
          vpc_id: !terraform.output vpc plat-ue2-prod vpc_id
```

### Reference the Current Stack Name

Use the `.stack` (or `.atmos_stack`) template identifier to specify the same stack as the current component is in
(for which the `!terraform.output` function is executed):

```yaml
  !terraform.output <component> {{ .stack }} <output>
  !terraform.output <component> {{ .atmos_stack }} <output>
```

For example, you have a `tgw` component that requires the `vpc_id` output from the `vpc` component in the same stack:

```yaml
  components:
    terraform:
      tgw:
        vars:
          vpc_id: !terraform.output vpc {{ .stack }} vpc_id
```

### Use a Format Function

Use the `printf` template function to construct stack names using static strings and dynamic identifiers.
This is convenient when you want to override some identifiers in the stack name:

```yaml
  !terraform.output <component> {{ printf "%s-%s-%s" .vars.tenant .vars.environment .vars.stage }} <output>

  !terraform.output <component> {{ printf "plat-%s-prod" .vars.environment }} <output>

  !terraform.output <component> {{ printf "%s-%s-%s" .settings.context.tenant .settings.context.region .settings.context.account }} <output>
```

For example, you have a `tgw` component deployed in the stack `plat-ue2-dev`. The `tgw` component requires the
`vpc_id` output from the `vpc` component from the same environment (`ue2`) and same stage (`dev`), but from a different
tenant `net` (instead of `plat`):

```yaml title="plat-ue2-dev"
  components:
    terraform:
      tgw:
        vars:
          vpc_id: !terraform.output vpc {{ printf "net-%s-%s" .vars.environment .vars.stage }} vpc_id
```

:::tip Important
    By using the `printf "%s-%s-%s"` function, you are constructing stack names using the stack context variables/identifiers.

    For more information on Atmos stack names and how to define them, refer to `stacks.name_pattern` and `stacks.name_template`
    sections in [`atmos.yaml` CLI config file](/cli/configuration/#stacks)
:::


## Caching the result of `!terraform.output` function

Atmos caches (in memory) the results of `!terraform.output` function.

The cache is per Atmos CLI command execution, e.g. each new execution of a command like `atmos terraform plan`,
`atmos terraform apply` or `atmos describe component` will create and use a new memory cache.

If you define the function in stack manifests for the same component in a stack more than once, the first call will
produce the result and cache it, and all the consecutive calls will just use the cached data. This is useful when you use the
`!terraform.output` function for the same component in a stack in multiple places in Atmos stack manifests.
It will speed up the function execution and stack processing.

For example:

<File>
```yaml
components:
  terraform:
    test2:
      vars:
        tags:
          test: !terraform.output test {{ .stack }} id
          test2: !terraform.output test {{ .stack }} id
          test3: !terraform.output test {{ .stack }} id
```
</File>

In the example, the `test2` Atmos component uses the outputs (remote state) of the `test` Atmos component from the same stack.
The YAML function `!terraform.output` is executed three times (once for each tag).

After the first execution, Atmos caches the result in memory,
and reuses it in the next two calls to the function. The caching makes the stack processing much faster.
In a production environment where many components are used, the speedup can be significant.

## Security and Access Control Considerations

When using the `!terraform.output` function (and `terraform output` command in general),
addressing security and access control is critical to protect sensitive information.

 - **Restrict Terraform CLI Access**: Only authorized personnel should have access to the system where the Terraform CLI is installed.
   This prevents unauthorized users from running terraform output to retrieve sensitive data.

 - **Role-Based Access Control (RBAC)**: Implement RBAC policies to ensure only those with a legitimate need can interact with Terraform projects and access outputs.

 - **Audit Logs**: Maintain detailed logs of Terraform commands executed, including `terraform output`, to track who accessed sensitive information.

 - **Output Restrictions**: Where possible, limit sensitive data exposure by avoiding the use of `terraform output` for secrets.
   Store these values securely in dedicated secret management solutions (e.g., AWS Secrets Manager, HashiCorp Vault).

 - **Encrypt State Files**: Ensure that Terraform state files (e.g., `terraform.tfstate`) are encrypted both at rest and in transit.
   Use backend providers like AWS S3 with server-side encryption or other managed storage with encryption capabilities.

 - **Limit State File Access**: Restrict access to the state file storage backend using IAM policies or similar controls to only authorized users and processes.

 - **Remote State Locking**: Enable remote state locking to prevent accidental overwrites and ensure consistent state handling.
   This is supported by backends like AWS DynamoDB when using S3.

 - **Secrets in State Files**: Avoid exposing sensitive data in the state file whenever possible.
   Mark sensitive outputs with `sensitive = true` in Terraform configurations, which prevents them from appearing in plaintext in the output or logs.


## Best Practices for Handling Sensitive Outputs

 - **Use `sensitive = true` attribute**: For sensitive outputs, set `sensitive = true` in the Terraform configuration.
   This prevents accidental display in the CLI and other outputs.

 - **Environment-Specific Outputs**: Avoid hardcoding sensitive outputs. Instead, manage environment-specific configurations dynamically or through variables.

 - **Secure Storage**: Redirect sensitive outputs to a secure storage location rather than displaying them in plaintext
   (e.g., use a script to pipe outputs directly into a secure secrets management system).

 - **Review Before Sharing Outputs**: Before sharing outputs with teams, scrub or redact sensitive information.

 - **Avoid Logging Outputs**: Ensure sensitive outputs are not logged during automated CI/CD workflows by reviewing and sanitizing pipeline configurations.
