---
title: atmos.Store
sidebar_position: 3
sidebar_label: atmos.Store
description: Read a value from a store
---
import File from '@site/src/components/File'
import Intro from '@site/src/components/Intro'
import Terminal from '@site/src/components/Terminal'

<Intro>
The `atmos.Store` template function allows reading the values from a remote [store](/core-concepts/projects/configuration/stores)
(e.g. SSM Parameter Store, Artifactory, Redis, etc.) into Atmos stack manifests.
</Intro>

## Usage

The `atmos.Store` template function is called with four parameters:

```yaml
foo: '{{ (atmos.Store "<store_name>" "<stack>" "<component>" "<key>").<attribute> }}'
```

## Arguments

<dl>
    <dt>`store_name`</dt>
    <dd>The name of the store to read from (as defined in the `atmos.yaml` file)</dd>

    <dt>`stack`</dt>
    <dd>Atmos stack name</dd>

    <dt>`component`</dt>
    <dd>Atmos component name</dd>

    <dt>`key`</dt>
    <dd>The key to read from the store</dd>
</dl>


## Specifying Atmos `stack`

There are multiple ways you can specify the Atmos stack parameter in the `atmos.Store` function.

The `stack` argument is the second argument of the `atmos.Store` function, and it can be specified in a few different ways:

### Hardcoded Stack Name

Hardcoded stack name. Use it if you want to get an output from a component from a different (well-known and static) stack. For example, you have a `tgw` component in a stack `plat-ue2-dev` that requires the `vpc_id` output from the `vpc` component from the stack `plat-ue2-prod`:

```yaml title="plat-ue2-dev"
  components:
    terraform:
      tgw:
        vars:
          vpc_id: '{{ (atmos.Store "vpc" "plat-ue2-prod").outputs.vpc_id }}'
```

### Reference the Current Stack Name

Use the `.stack` (or `.atmos_stack`) template identifier to specify the same stack as the current component is in (for which the `atmos.Store` function is executed):

```yaml
  {{ (atmos.Store "<component>" .stack).<section>.<attribute> }}
  {{ (atmos.Store "<component>" .atmos_stack).<section>.<attribute> }}
```

For example, you have a `tgw` component that requires the `vpc_id` output from the `vpc` component in the same stack:

```yaml
  components:
    terraform:
      tgw:
        vars:
          vpc_id: '{{ (atmos.Store "vpc" .stack).outputs.vpc_id }}'
```

### Use a Format Function

Use the `printf` template function to construct stack names using static strings and dynamic identifiers. This is convenient when you want to override some identifiers in the stack name:

```yaml
  {{ (atmos.Store "<component>" (printf "%s-%s-%s" .vars.tenant .vars.environment .vars.stage)).<section>.<attribute> }}

  {{ (atmos.Store "<component>" (printf "plat-%s-prod" .vars.environment)).<section>.<attribute> }}

  {{ (atmos.Store "<component>" (printf "%s-%s-%s" .settings.context.tenant .settings.context.region .settings.context.account)).<section>.<attribute> }}
```

For example, you have a `tgw` component deployed in the stack `plat-ue2-dev`. The `tgw` component requires the
`vpc_id` output from the `vpc` component from the same environment (`ue2`) and same stage (`dev`), but from a different
tenant `net` (instead of `plat`):

```yaml title="plat-ue2-dev"
  components:
    terraform:
      tgw:
        vars:
          vpc_id: '{{ (atmos.Store "vpc" (printf "net-%s-%s" .vars.environment .vars.stage)).outputs.vpc_id }}'
```

:::tip Important
    By using the `printf "%s-%s-%s"` function, you are constructing stack names using the stack context variables/identifiers.

    For more information on Atmos stack names and how to define them, refer to `stacks.name_pattern` and `stacks.name_template`
    sections in [`atmos.yaml` CLI config file](/cli/configuration/#stacks)
:::

## Examples

The following configurations show different ways of using the `atmos.Store` template function to read values from
different Atmos sections directly in Atmos stack manifests, including the outputs of other
(already provisioned) components.

<File>
```yaml
# Global `settings` section
# It will be added and deep-merged to the `settings` section of all components
settings:
  test: true

components:
  terraform:
    test:
      metadata:
        # Point to the Terraform/OpenTofu component
        component: "test"
      vars:
        name: "test"

    test1:
      metadata:
        # Point to the Terraform/OpenTofu component
        component: "test1"
      vars:
        name: "test1"

    test2:
      metadata:
        # Point to the Terraform/OpenTofu component
        component: "test2"
      vars:
        name: "test2"
        # Use the `atmos.Store` function to get the outputs of the Atmos component `test1`
        # The `test1` component must be already provisioned and its outputs stored in the Terraform/OpenTofu state
        # Atmos will execute `terraform output` on the `test1` component in the same stack to read its outputs
        test1_id: '{{ (atmos.Store "test1" .stack).outputs.test1_id }}'
        tags:
          # Get the `settings.test` field from the `test` component in the same stack
          test: '{{ (atmos.Store "test" .stack).settings.test }}'
          # Get the `metadata.component` field from the `test` component in the same stack
          test_terraform_component: '{{ (atmos.Store "test" .stack).metadata.component }}'
          # Get the `vars.name` field from the `test1` component in the same stack
          test1_name: '{{ (atmos.Store "test1" .stack).vars.name }}'
```
</File>

## Caching the result of `atmos.Store` function

Atmos caches (in memory) the results of `atmos.Store` template function execution.
If you call the function for the same component in a stack more than once, the first call will produce the result
and cache it, and all the consecutive calls will just use the cached data. This is useful when you use the
`atmos.Store` function for the same component in a stack in multiple places in Atmos stack manifests.
It will speed up the function execution and stack processing.

For example:

<File>
```yaml
components:
  terraform:
    test2:
      vars:
        tags:
          test: '{{ (atmos.Store "test" .stack).outputs.id }}'
          test2: '{{ (atmos.Store "test" .stack).outputs.id }}'
          test3: '{{ (atmos.Store "test" .stack).outputs.id }}'
```
</File>

In the example, the `test2` Atmos component uses the outputs (remote state) of the `test` Atmos component from the same stack.
The template function `{{ atmos.Store "test" .stack }}` is executed three times (once for each tag).

After the first execution, Atmos caches the result in memory (all the component sections, including the `outputs`),
and reuses it in the next two calls to the function. The caching makes the stack processing about three times faster in this
particular example. In a production environment where many components are used, the speedup can be even more significant.
