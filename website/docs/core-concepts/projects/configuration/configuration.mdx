---
title: Configure Atmos CLI
sidebar_position: 3
sidebar_label: Configure Atmos
description: CLI configuration for Atmos to find your Terraform components and Atmos stacks
id: configuration
---
import EmbedFile from '@site/src/components/EmbedFile'
import KeyPoints from '@site/src/components/KeyPoints'
import Screengrab from '@site/src/components/Screengrab'
import Intro from '@site/src/components/Intro'
import ActionCard from '@site/src/components/ActionCard'
import PrimaryCTA from '@site/src/components/PrimaryCTA'

<Intro>
The `atmos.yaml` configuration file is used to control the behavior of the `atmos` CLI for your project. This is how Atmos knows where to find your stack configurations and components. Almost everything in Atmos is configurable via this file.
</Intro>

Because this file is crucial to the configuration of the project, it should live along side of it, with your Terraform components and Atmos stacks. It's also where you can [configure integrations](/integrations), like with our [GitHub Actions](/integrations/github-actions).

<KeyPoints>
- What are the different configuration files in Atmos
- How to configure `atmos.yaml` for your project's filesystem layout
- How Atmos finds the `atmos.yaml` file
- How Atmos identifies stack configurations using context variables and naming patterns
</KeyPoints>

To configure Atmos to work with your project, we'll create a file called `atmos.yaml` to tell Atmos where to find the
Terraform components and Atmos stacks. Almost everything in Atmos is configurable via this file.

## Types of Configuration Files

In Atmos, there are some different types of configuration files to be aware of. The most important one is the `atmos.yaml` file, which is used to configure the behavior of the `atmos` CLI. This file is used to control how Atmos finds your Terraform components and Atmos stacks.

<dl>
    <dt>`atmos.yaml`</dt>
    <dd>CLI configuration for Atmos to find your Terraform components and Atmos stacks. See [vendoring](/cli/configuration).</dd>

    <dt>`vendor.yaml`</dt>
    <dd>
        Vendoring manifest for any third-party dependencies. See [vendoring](/core-concepts/vendor/vendor-manifest).
        __NOTE__: The vendor manifest can import other vendor manifests, allowing you to compose them together.
    </dd>

    <dt>`stacks/**/*.yaml`</dt>
    <dd>
        Vendoring manifest for any third-party dependencies. See [vendoring](/core-concepts/vendor/vendor-manifest).
        __NOTE__: the actual path to the stacks directory is configurable in the `atmos.yaml` file, via the `stacks.base_path` setting.
    </dd>

    <dt>`workflows/**/*.yaml`</dt>
    <dd>
        Workflow definitions. See [workflows](/core-concepts/workflows).
        __NOTE__: the actual path to the workflows directory is configurable in the `atmos.yaml` file, via the `workflows.base_path` setting.
    </dd>

    <dt>`**/components/**/component.yaml`</dt>
    <dd>
        Component manifest for vendoring individual components. See [component manifest](/core-concepts/vendor/component-manifest).
        __NOTE__: the actual path to the components directory is configurable in the `atmos.yaml` file, via the `components.<toolchain>.base_path` setting.
    </dd>

    <dt>`schemas/*.schema.json`</dt>
    <dd>
        JSON Schema for validating Atmos manifests. See [validation](/core-concepts/validate/json-schema).
        __NOTE__, the actual path to the schemas directory is configurable in the `atmos.yaml` file, via the `schemas.atmos.manifest` setting.
    </dd>

    <dt>`schemas/*.rego`</dt>
    <dd>
        OPA Policy for validating Atmos manifests. See [validation](/core-concepts/validate/opa).
    </dd>
</dl>

## Atmos CLI Configuration Schema

Below is the minimum recommended configuration for Atmos to work with Terraform and to configure [Atmos components](/core-concepts/components) and [Atmos stacks](/core-concepts/stacks). Copy this YAML config below into your `atmos.yaml` file.

<EmbedFile filePath="examples/demo-stacks/atmos.yaml" />

__NOTE:__ For a detailed description of all the sections, refer to [CLI Configuration](/cli/configuration).

### Stack Names (Slugs)

Atmos uses “slugs” to refer to stacks, so you don't need to pass multiple arguments to identify a stack or a component in a stack.

It's a deliberate design decision of Atmos to rely strictly on configuration, rather than on file names and directory locations, which can change (and would thereby change your state).

For example, with the command `atmos terraform apply myapp -s dev`, Atmos interprets the slug `dev` using the pattern `{stage}` to locate the correct stack configuration in the stacks directory.

The format of this slug, is determined by one of the following settings.

<dl>
  <dt>`stacks.name_template` (newer format, more powerful)</dt>
  <dd>
    The name template allows you to define a custom Go template to format the stack name. This is useful when you want to use a different naming convention for your stacks.
  </dd>
  <dt>`stacks.name_pattern` (old format, still supported)</dt>
  <dd>
    The name pattern relies strictly on variables (`var.namespace`, `var.tenant`, `var.environment`, `var.stage`)
    to identify the stack.  It does not support any other variables.

    You'll still see this in many of the examples, but we recommend using the newer `name_template` format.
  </dd>
</dl>

### Logging

Atmos provides some simple settings to control how it emits events to standard error. By convention, Atmos uses standard error to communicate all events related to its own processing. We reserve standard output (stdout) for the intended output of the commands that Atmos executes. By following this convention, you can safely pipe the output from Atmos into other commands as part of a pipeline.

<dl>
  <dt>`logs.level`</dt>
  <dd>
    Set to `Info` to see the most helpful logs. You can also set it to `Trace` to see all the logs, which is helpful for debugging.
    Supported options are:
    <dl>
        <dt>`Info` _default_</dt>
        <dd>Emit standard messages that describe what Atmos is doing</dd>

        <dt>`Warn`</dt>
        <dd>Show all messages with a severity of "warning" or less</dd>

        <dt>`Error`</dt>
        <dd>Show all messages with a severity of "error" or less</dd>

        <dt>`Debug`</dt>
        <dd>Emit helpful debugging information, including all other severities. This is very verbose.</dd>

        <dt>`Trace`</dt>
        <dd>Turn off all filters, and just display every single message.</dd>
    </dl>
  </dd>

  <dt>`logs.file`</dt>
  <dd>
    Set to `/dev/stderr` to send all of Atmos output to the standard error stream. This is useful when running Atmos in a CI/CD pipeline.
  </dd>
</dl>

### Command Aliases

If you get tired of typing long commands in Atmos, you can alias them using the `aliases` section. This is especially useful for commands that you run frequently, like Terraform.  Aliases you define appear in the `atmos help`, so you can see them at a glance.

```yaml
# CLI command aliases
aliases:
  # Aliases for Atmos native commands
  tf: terraform
  tp: terraform plan
  up: terraform apply
  down: terraform destroy
  ds: describe stacks
  dc: describe component
  # Aliases for Atmos custom commands
  ls: list stacks
  lc: list components
```

<ActionCard title="Want to go deeper on this topic?">
    Aliases can make Atmos easier to use by allowing you to define shortcuts for frequently used commands.
    <PrimaryCTA to="/cli/configuration#aliases">Learn Aliases</PrimaryCTA>
</ActionCard>

### Path Configuration

Well-known paths are how Atmos knows how to find all your stack configurations, components and workflows. Here are the essential paths that you need to configure:

<dl>
  <dt>`base_path`</dt>
  <dd>The base path for components, stacks, and workflows configurations. We set it to `./` so it will use the current working directory. Alternatively, we can override this behavior by setting the ENV var `ATMOS_BASE_PATH` to point to another directory location.</dd>

  <dt>`components.terraform.base_path`</dt>
  <dd>The base path to the Terraform components (Terraform root modules). As described in [Configure Repository](/quick-start/advanced/configure-repository), we've decided to put the Terraform components into the `components/terraform` directory, and this setting tells Atmos where to find them. Atmos will join the base path (set in the `ATMOS_BASE_PATH` ENV var) with `components.terraform.base_path` to calculate the final path to the Terraform components</dd>

  <dt>`stacks.base_path`</dt>
  <dd>The base path to the Atmos stacks. As described in [Configure Repository](/quick-start/advanced/configure-repository), we've decided to put the stack configurations into the `stacks` directory, and this setting tells Atmos where to find them. Atmos will join the base path (set in the `ATMOS_BASE_PATH` ENV var) with `stacks.base_path` to calculate the final path to the stacks</dd>

  <dt>`stacks.included_paths`</dt>
  <dd>List of file paths to the top-level stacks in the `stacks` directory to include in search when Atmos searches for the stack where the component is defined when executing `atmos` commands</dd>

  <dt>`stacks.excluded_paths`</dt>
  <dd>List of file paths to the top-level stacks in the `stacks` directory to exclude from search when Atmos searches for the stack where the component is defined when executing `atmos` commands</dd>

  <dt>`workflows.base_path`</dt>
  <dd>The base path to Atmos [Workflows](/core-concepts/workflows) files</dd>
</dl>

:::tip Environment variables
Everything in the `atmos.yaml` file can be overridden by environment variables. This is useful for CI/CD pipelines where you might want to control the behavior of Atmos without changing the `atmos.yaml` file.
:::

### Using YAML Functions for Dynamic Paths

Atmos supports [YAML functions](/functions/yaml) like `!repo-root` and `!env` to dynamically configure paths. This makes your configuration more portable across different environments.

**Example: Using `!repo-root` for absolute paths**
```yaml
# atmos.yaml
base_path: "!repo-root"

components:
  terraform:
    base_path: "!repo-root/components/terraform"

stacks:
  base_path: "!repo-root/stacks"
```

With this configuration, paths are always relative to your Git repository root, regardless of where you run Atmos commands from.

**Example: Using `!env` for environment-specific paths**
```yaml
# atmos.yaml
base_path: "!env PROJECT_ROOT"

components:
  terraform:
    base_path: "!env TERRAFORM_COMPONENTS_PATH"
```

```bash
# Set environment variables
export PROJECT_ROOT="/path/to/infrastructure"
export TERRAFORM_COMPONENTS_PATH="/path/to/infrastructure/components/terraform"

# Run Atmos commands
atmos terraform plan vpc -s dev
```

**Example: Combining YAML functions with CLI flags**
```bash
# Override base_path dynamically using !repo-root
atmos terraform plan vpc -s dev --base-path="!repo-root"

# Override using !env function
export INFRA_PATH="/custom/path"
atmos terraform plan vpc -s dev --base-path="!env INFRA_PATH"
```

:::tip Use Case: Multi-Repository Setup
YAML functions are particularly useful when your infrastructure is spread across multiple repositories:

```yaml
# atmos.yaml in repository A
base_path: "!repo-root"
vendor:
  base_path: "!env SHARED_MODULES_PATH"
```

```bash
# Point to shared modules in another repository
export SHARED_MODULES_PATH="/path/to/repository-b/modules"
atmos terraform plan vpc -s dev
```

This eliminates hardcoded paths and makes configurations portable across teams and environments.
:::

## Custom Commands

<dl>
  <dt>`commands`</dt>
  <dd>configuration for [Atmos Custom Commands](/core-concepts/custom-commands)</dd>
</dl>

See our many [practical examples](https://github.com/cloudposse/atmos/tree/main/examples) of using Custom Commands in atmos.

<ActionCard title="Want to go deeper on this topic?">
    Custom Commands are a versatile and powerful feature of Atmos. They allow you to extend Atmos’s functionality to meet your specific needs without modifying its core.
    <PrimaryCTA to="/cli/configuration/commands">Learn Custom Commands</PrimaryCTA>
</ActionCard>

## Workflows

Workflows allow you to automate routine operations, such as orchestrating the startup behavior of a series of services. Very little about workflows is configured in the `atmos.yaml`. Only the base path to the workflows is defined here. The workflows themselves are defined in the `workflows.base_path` folder.

<ActionCard title="Want to go deeper on this topic?">
    Workflows allow you to orchestrate your components or any command. Unlike Custom Commands, Workflows focus on orchestration and are reentrant, allowing you to start at any step in the workflow.
    <PrimaryCTA to="/core-concepts/workflows">Learn Workflows</PrimaryCTA>
</ActionCard>

## Schema Validation

<dl>
  <dt>`schemas`</dt>
  <dd>
  [JSON Schema](https://json-schema.org/) and [OPA Policy](https://www.openpolicyagent.org/) configurations for:
  - [Atmos Manifests Validation](/cli/schemas)
  - [Atmos Stack Validation](/core-concepts/validate)
  </dd>
</dl>

## Atmos Search Paths

Atmos searches for the `atmos.yaml` file in several locations, stopping at the first successful match. The search order (from highest to lowest priority) is:

- Environment variable `ATMOS_CLI_CONFIG_PATH`
- Current working directory
- Home dir (`~/.atmos/atmos.yaml`)
- System dir (`/usr/local/etc/atmos/atmos.yaml` on Linux, `%LOCALAPPDATA%/atmos/atmos.yaml` on Windows)
- **Git repository root** (when `ATMOS_GIT_ROOT_ENABLED=true`, which is the default)

The Git root search is a fallback mechanism that enables you to run Atmos commands from anywhere within your repository. For example, you can run `atmos terraform plan vpc -s dev` from inside `components/terraform/vpc/` and Atmos will still find your `atmos.yaml` at the repository root.

:::tip Developer Workflow
The Git root fallback is particularly useful during development when working directly in component directories. It eliminates the need to constantly navigate back to the root directory to run Atmos commands.

**Example:** You're editing a Terraform component and want to test your changes:
```bash
# Navigate to the component directory
cd components/terraform/vpc

# Run Atmos commands directly - Atmos finds atmos.yaml in the repo root
atmos terraform plan vpc -s dev
atmos terraform apply vpc -s dev
```
:::

:::warning CI/CD Environments
In CI/CD pipelines, you may want to disable Git root search to ensure explicit configuration:
```bash
export ATMOS_GIT_ROOT_ENABLED=false
```
This makes your deployment pipelines more predictable by requiring the `atmos.yaml` to be in one of the standard locations.
:::

Initial Atmos configuration can be controlled by these environment variables:

<dl>
  <dt>`ATMOS_CLI_CONFIG_PATH`</dt>
  <dd>Directory that contains the `atmos.yaml` (just the folder without the file name). It's not possible to change the filename at this time.</dd>

  <dt>`ATMOS_GIT_ROOT_ENABLED`</dt>
  <dd>Enable or disable Git root configuration search (default: `true`). When enabled, Atmos will search for `atmos.yaml` in the Git repository root as a final fallback. Set to `false` in CI/CD for stricter configuration requirements.</dd>

  <dt>`ATMOS_BASE_PATH`</dt>
  <dd>Base path to the `components/` and `stacks/` folders.</dd>
</dl>

## Special Considerations for Terraform Components

If you are relying on Atmos discovering the `atmos.yaml` based on your current working directory (e.g. at the root of repository), it will work for the `atmos` CLI; however, it will **not work** for [Component Remote State](/core-concepts/share-data/remote-state) because it uses the [terraform-provider-utils](https://github.com/cloudposse/terraform-provider-utils) Terraform provider.

This is because Terraform executes provider from the component's folder (e.g. `components/terraform/vpc`), so it will no longer find the file in the root of the repository, since the working directory has changed.

Both the `atmos` CLI and [terraform-provider-utils](https://github.com/cloudposse/terraform-provider-utils) Terraform provider use the same `Go` code, which try to locate the [CLI config](/cli/configuration) `atmos.yaml` file before parsing and processing [Atmos stacks](/core-concepts/stacks).

This means that `atmos.yaml` file must be at a location in the file system where all processes can find it, such as by explicitly specifying the path in the `ATMOS_CLI_CONFIG_PATH` environment variable.

<ActionCard title="Want to go deeper on this topic?">
    For a deep-dive on configuring the Atmos CLI and all of the sections of the `atmos.yaml`, refer to CLI Configuration.
    <PrimaryCTA to="/cli/configuration">Advanced CLI Configuration</PrimaryCTA>
</ActionCard>
