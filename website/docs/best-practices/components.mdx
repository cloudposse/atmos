---
title: Component Best Practices
sidebar_position: 1
sidebar_label: Components
description: Learn the opinionated "Best Practices" for using Components with Atmos 
id: components
---

Here are some essential best practices to follow when designing architectures using infrastructure as code (IaC), focusing on optimizing
component design, reusability, and lifecycle management. These guidelines are designed to help developers and operators build efficient,
scalable, and reliable systems, ensuring a smooth and effective infrastructure management process.

### Keep Your Components Small to Reduce the Blast Radius of Changes

Focus on creating small, reusable components that adhere to the UNIX philosophy by doing one thing well. 
This strategy leads to simpler updates, more straightforward troubleshooting, quicker plan/apply cycles, and a
clearer separation of responsibilities.

### Split Components By Lifecycle

For instance, a VPC, which is rarely destroyed, should be managed separately from more dynamic resources like clusters
or databases that may frequently scale or undergo updates.

### Make Them Opinionated, But Not Too Opinionated

Ensure components are generalized to prevent the proliferation of similar components, thereby promoting easier testing, 
reuse, and maintenance.

- **Use Parameterization, But Avoid Over-Parameterization.** <br/> Good parameterization ensures components are reusable, but components become difficult to
  test and document with too many parameters.
- **Avoid Creating Factories Inside of Components.** <br/> Minimize the blast radius of changes and maintain fast plan/apply cycles by not embedding factories within components that provision lists of resources. Instead, leverage [Stack configurations to serve as factories](https://en.wikipedia.org/wiki/Factory_(object-oriented_programming)) for provisioning multiple component instances. This approach keeps the state isolated and scales efficiently with the increasing number of component instances.
- **Use Component Libraries & Vendoring** Utilize a centralized [component library](/core-concepts/components/library) to distribute and
  share components across the organization efficiently. This approach enhances discoverability by centralizing where components are stored, preventing sprawl and ensuring components are easily accessible to everyone. Employ vendoring to retrieve remote dependencies, like components, ensuring the practice of immutable infrastructure.
- **Enforce Standards using OPA Policies** <br/> Apply component validation within stacks to establish policies governing component usage. These policies can be tailored as needed, allowing the same component to be validated differently depending on its context of use.
- **Organize Related Components with Folders.** <br/> Organize multiple related components in a common folder. Use nested folders as necessary, to logically group components. For example, by grouping components by cloud provider and layer (e.g. `components/terraform/aws/network/<vpc>`)
- **Document Component Interfaces and Usage.** <br/> Utilize tools such as [terraform-docs](https://terraform-docs.io) to thoroughly document the input variables and outputs of your component. Include snippets of stack configuration to simplify understanding for developers on integrating the component into their stack configurations. Providing examples that cover common use-cases of the component is particularly effective.
- **Version Components for Breaking Changes.** <br/> Use versioned folders within the component to delineate major versions (e.g. `/components/terraform/<something>/v1/`)
- **Use a Monorepo for Your Components.** <br/> For streamlined development and simplified dependency management, smaller companies should consolidate stacks and components in a single monorepo, facilitating easier updates and unified versioning. Larger companies and enterprises with multiple monorepos can benefit from a central repository for upstream components, and then use vendoring to easily pull in these shared components to team-specific monorepos.
- **Maintain Loose Coupling Between Components.** <br/> Avoid directly invoking one component from within another to ensure components remain loosely coupled. Specifically for Terraform components (root modules), this practice is unsupported due to the inability to define a backend in a child module, potentially leading to unexpected outcomes. It's crucial to steer clear of this approach to maintain system integrity.
- **Reserve Code Generation for Emergencies.** <br/> We generally advise against using code generation for application logic (components), because it's challenging to ensure good test coverage (e.g. with `terratest`) and no one likes to code review machine-generated boilerplate in Pull Requests.

