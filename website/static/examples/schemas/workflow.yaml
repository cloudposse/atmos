# Comprehensive Atmos Workflow Example
# This file demonstrates all available workflow configuration options

# Basic workflow with minimal configuration
deploy-vpc:
  description: Deploy VPC infrastructure
  stack: dev
  steps:
    - command: terraform apply vpc

# Complex multi-step workflow
deploy-full-stack:
  description: Deploy complete infrastructure stack with all components
  stack: prod
  steps:
    # Step 1: Deploy network layer
    - name: deploy-vpc
      command: terraform apply vpc
      stack: prod
      type: terraform

    # Step 2: Deploy security groups with retry
    - name: deploy-security
      command: terraform apply security-groups
      stack: prod
      type: terraform
      retry:
        max_attempts: 3
        backoff_strategy: exponential
        initial_delay: "2s"
        max_delay: "30s"
        multiplier: 2.0
        random_jitter: 0.1
        max_elapsed_time: "5m"

    # Step 3: Deploy RDS database
    - name: deploy-database
      command: terraform apply rds
      stack: prod
      type: terraform
      retry:
        max_attempts: 5
        backoff_strategy: linear
        initial_delay: "5s"
        max_delay: "1m"

    # Step 4: Deploy EKS cluster
    - name: deploy-eks
      command: terraform apply eks
      stack: prod
      type: terraform

    # Step 5: Deploy Helm charts
    - name: deploy-ingress
      command: helmfile apply nginx-ingress
      stack: prod
      type: helmfile

    # Step 6: Deploy monitoring
    - name: deploy-monitoring
      command: helmfile apply monitoring
      stack: prod
      type: helmfile
      retry:
        max_attempts: 2
        backoff_strategy: constant
        initial_delay: "10s"

# Validation workflow
validate-infrastructure:
  description: Validate all infrastructure components before deployment
  stack: dev
  steps:
    - name: validate-syntax
      command: validate stacks
      type: atmos

    - name: validate-vpc
      command: terraform validate vpc
      stack: dev
      type: terraform

    - name: validate-eks
      command: terraform validate eks
      stack: dev
      type: terraform

    - name: validate-policies
      command: validate component vpc
      stack: dev
      type: atmos

# Plan workflow with conditional steps
plan-changes:
  description: Plan all infrastructure changes
  stack: staging
  steps:
    - name: plan-vpc
      command: terraform plan vpc
      stack: staging
      type: terraform

    - name: plan-security
      command: terraform plan security-groups
      stack: staging
      type: terraform
      retry:
        max_attempts: 2
        backoff_strategy: constant
        initial_delay: "1s"

    - name: plan-database
      command: terraform plan rds
      stack: staging
      type: terraform

    - name: plan-compute
      command: terraform plan eks
      stack: staging
      type: terraform

# Destroy workflow (in reverse order)
destroy-infrastructure:
  description: Destroy all infrastructure components in safe order
  stack: dev
  steps:
    # Destroy applications first
    - name: destroy-apps
      command: helmfile destroy monitoring
      stack: dev
      type: helmfile

    - name: destroy-ingress
      command: helmfile destroy nginx-ingress
      stack: dev
      type: helmfile

    # Destroy compute
    - name: destroy-eks
      command: terraform destroy eks
      stack: dev
      type: terraform

    # Destroy data layer
    - name: destroy-database
      command: terraform destroy rds
      stack: dev
      type: terraform

    # Destroy security
    - name: destroy-security
      command: terraform destroy security-groups
      stack: dev
      type: terraform

    # Destroy network last
    - name: destroy-vpc
      command: terraform destroy vpc
      stack: dev
      type: terraform

# Drift detection workflow
detect-drift:
  description: Detect configuration drift across all components
  stack: prod
  steps:
    - name: refresh-vpc
      command: terraform refresh vpc
      stack: prod
      type: terraform

    - name: refresh-security
      command: terraform refresh security-groups
      stack: prod
      type: terraform

    - name: refresh-database
      command: terraform refresh rds
      stack: prod
      type: terraform

    - name: refresh-compute
      command: terraform refresh eks
      stack: prod
      type: terraform

    - name: generate-drift-report
      command: describe affected
      type: atmos

# Backup workflow
backup-state:
  description: Backup Terraform state files
  stack: prod
  steps:
    - name: backup-vpc-state
      command: "aws s3 cp s3://terraform-state/vpc/terraform.tfstate s3://terraform-state-backup/vpc/terraform.tfstate.$(date +%Y%m%d)"
      type: shell

    - name: backup-eks-state
      command: "aws s3 cp s3://terraform-state/eks/terraform.tfstate s3://terraform-state-backup/eks/terraform.tfstate.$(date +%Y%m%d)"
      type: shell

    - name: backup-rds-state
      command: "aws s3 cp s3://terraform-state/rds/terraform.tfstate s3://terraform-state-backup/rds/terraform.tfstate.$(date +%Y%m%d)"
      type: shell

# Testing workflow
test-deployment:
  description: Run tests against deployed infrastructure
  stack: staging
  steps:
    - name: test-vpc-connectivity
      command: "pytest tests/integration/vpc_test.py"
      type: shell
      retry:
        max_attempts: 3
        backoff_strategy: linear
        initial_delay: "5s"
        max_delay: "30s"

    - name: test-eks-cluster
      command: "kubectl get nodes"
      type: shell

    - name: test-database-connection
      command: "psql -h $DB_HOST -U $DB_USER -c 'SELECT 1'"
      type: shell
      retry:
        max_attempts: 5
        backoff_strategy: exponential
        initial_delay: "2s"
        max_delay: "1m"
        multiplier: 2.0

    - name: test-application-health
      command: "curl -f http://app.staging.example.com/health"
      type: shell
      retry:
        max_attempts: 10
        backoff_strategy: constant
        initial_delay: "10s"

# Cost optimization workflow
optimize-costs:
  description: Optimize infrastructure costs
  stack: dev
  steps:
    - name: stop-non-prod-instances
      command: "aws ec2 stop-instances --instance-ids $(aws ec2 describe-instances --filters 'Name=tag:Environment,Values=dev' --query 'Reservations[].Instances[].InstanceId' --output text)"
      type: shell

    - name: delete-old-snapshots
      command: "python scripts/cleanup_old_snapshots.py --days 30"
      type: shell

    - name: resize-underutilized-instances
      command: "python scripts/rightsizing.py --environment dev"
      type: shell

# Multi-environment workflow
promote-to-production:
  description: Promote changes from staging to production
  steps:
    # First validate staging
    - name: validate-staging
      command: terraform plan vpc
      stack: staging
      type: terraform

    # Apply to production
    - name: deploy-prod-vpc
      command: terraform apply vpc
      stack: prod
      type: terraform
      retry:
        max_attempts: 3
        backoff_strategy: exponential
        initial_delay: "5s"
        max_delay: "1m"
        multiplier: 2.0

    - name: deploy-prod-eks
      command: terraform apply eks
      stack: prod
      type: terraform
      retry:
        max_attempts: 3
        backoff_strategy: exponential
        initial_delay: "5s"
        max_delay: "1m"
        multiplier: 2.0

    # Smoke tests
    - name: smoke-test
      command: "pytest tests/smoke/production_test.py"
      type: shell
      retry:
        max_attempts: 5
        backoff_strategy: linear
        initial_delay: "10s"
        max_delay: "1m"

# Maintenance workflow
maintenance-mode:
  description: Put application into maintenance mode
  stack: prod
  steps:
    - name: enable-maintenance-page
      command: "kubectl apply -f k8s/maintenance-page.yaml"
      type: shell

    - name: drain-load-balancer
      command: "aws elb deregister-instances-from-load-balancer --load-balancer-name prod-lb --instances $(kubectl get nodes -o jsonpath='{.items[*].spec.providerID}' | sed 's/aws:\/\/\/.*\///g')"
      type: shell

    - name: wait-for-connections
      command: "sleep 60"
      type: shell

    - name: backup-database
      command: "pg_dump -h $DB_HOST -U $DB_USER $DB_NAME | gzip > backup-$(date +%Y%m%d-%H%M%S).sql.gz"
      type: shell

# Rollback workflow with retries
rollback-deployment:
  description: Rollback to previous deployment version
  stack: prod
  steps:
    - name: retrieve-previous-version
      command: "terraform state pull | jq -r '.serial' > /tmp/previous-serial.txt"
      type: shell

    - name: rollback-eks
      command: "terraform apply -target=module.eks -var='image_tag=previous'"
      stack: prod
      type: terraform
      retry:
        max_attempts: 3
        backoff_strategy: exponential
        initial_delay: "10s"
        max_delay: "2m"
        multiplier: 2.0
        random_jitter: 0.2
        max_elapsed_time: "10m"

    - name: rollback-application
      command: "kubectl rollout undo deployment/app -n production"
      type: shell
      retry:
        max_attempts: 5
        backoff_strategy: linear
        initial_delay: "5s"
        max_delay: "30s"

    - name: verify-rollback
      command: "kubectl rollout status deployment/app -n production"
      type: shell
      retry:
        max_attempts: 10
        backoff_strategy: constant
        initial_delay: "10s"
        max_elapsed_time: "5m"
