# Native CI Integration

## Overview

Native CI integration brings first-class CI/CD support directly into the Atmos CLI. Run `atmos terraform plan` in GitHub Actions and get beautiful job summaries, status checks, and PR comments‚Äîno extra actions required.

## What You Get

### Rich Job Summaries

When you run `atmos terraform plan` in CI, Atmos automatically writes a detailed summary to `$GITHUB_STEP_SUMMARY`:

```markdown
## üîÑ Plan: `vpc` in `plat-ue2-dev`

[![create](https://shields.io/badge/CREATE-3-success?style=for-the-badge)](#)
[![change](https://shields.io/badge/CHANGE-1-warning?style=for-the-badge)](#)
[![destroy](https://shields.io/badge/DESTROY-2-critical?style=for-the-badge)](#)

> [!CAUTION]
> **Terraform will delete resources!**

<details>
<summary>üìã Plan: 3 to add, 1 to change, 2 to destroy</summary>

### ‚ûï Create
- `aws_vpc.main`
- `aws_subnet.public[0]`
- `aws_subnet.public[1]`

### ‚úèÔ∏è Change
- `aws_security_group.web`

### ‚ûñ Destroy
- `aws_security_group.deprecated`
- `aws_route.legacy`

</details>

<details>
<summary>üìù Full Plan Output</summary>

```hcl
# aws_vpc.main will be created
+ resource "aws_vpc" "main" {
    + cidr_block = "10.0.0.0/16"
    + tags       = {
        + "Name" = "main-vpc"
      }
  }
```

</details>

---
<sub>ü§ñ Generated by [Atmos](https://atmos.tools) ‚Ä¢ `abc123d` ‚Ä¢ 2025-01-15T10:30:00Z</sub>
```

### Live Status Checks

Atmos can post GitHub status checks when operations start and complete‚Äîjust like CodeRabbit:

```
2 pending checks ‚ñæ

‚óè Atmos  Plan in progress ‚Äî vpc in plat-ue2-dev
‚óè Atmos  Plan in progress ‚Äî eks in plat-ue2-dev
```

When complete:

```
2 checks passed ‚ñæ

‚úì Atmos  Plan complete ‚Äî 3 to add, 1 to change, 2 to destroy
‚úì Atmos  Plan complete ‚Äî No changes
```

Status checks require the `checks: write` permission and are enabled via configuration:

```yaml
ci:
  checks:
    enabled: true
```

### Terraform Outputs in $GITHUB_OUTPUT

After `terraform apply`, all outputs are exported for downstream jobs:

```bash
# Written to $GITHUB_OUTPUT
vpc_id=vpc-12345678
subnet_ids=["subnet-1","subnet-2","subnet-3"]
```

### Same Command Everywhere

The same command works identically in CI and locally:

```bash
# In GitHub Actions (auto-detected)
atmos terraform plan vpc -s plat-ue2-dev

# Local development (force CI mode)
atmos terraform plan vpc -s plat-ue2-dev --ci
```

### GitHub Actions Permissions

Different CI features require different GitHub Actions permissions. Add only what you need:

```yaml
permissions:
  id-token: write    # Required: OIDC authentication with AWS/cloud providers
  contents: read     # Required: Checkout repository
  checks: write      # Optional: Post status checks (ci.status_checks.enabled: true)
  pull-requests: write  # Optional: Post PR comments (ci.outputs.pr_comment.enabled: true)
```

| Permission | Required | Enables |
|------------|----------|---------|
| `id-token: write` | Yes | OIDC authentication via `atmos auth` for AWS, Azure, GCP |
| `contents: read` | Yes | Checkout repository code |
| `checks: write` | No | Status checks showing "Plan in progress" / "Plan complete" |
| `pull-requests: write` | No | PR comments with plan summaries |

**Minimal workflow** (job summaries only):

```yaml
permissions:
  id-token: write
  contents: read
```

**Full-featured workflow** (status checks + PR comments):

```yaml
permissions:
  id-token: write
  contents: read
  checks: write
  pull-requests: write
```

## Problem Statement

### Current State

Users running Atmos in CI/CD pipelines rely on external GitHub Actions maintained separately from the core CLI:

- **github-action-atmos-terraform-plan** - Wraps `atmos terraform plan` with CI-specific behaviors
- **github-action-atmos-terraform-apply** - Wraps `atmos terraform apply` with CI-specific behaviors

This creates several challenges:

1. **Inconsistent behavior** - Local runs differ from CI runs
2. **Maintenance burden** - Two codebases to maintain and keep in sync
3. **Limited portability** - Actions are GitHub-specific
4. **Complex scripting** - Users write bash to glue together plan files, PR comments, etc.
5. **Feature gaps** - Actions lag behind CLI capabilities
6. **Debugging difficulty** - Hard to reproduce CI behavior locally

### Desired State

Users can run `atmos terraform plan --ci` locally or in CI with **identical behavior**:

```bash
# Local development
atmos terraform plan vpc -s plat-ue2-dev --ci

# CI pipeline (same command)
atmos terraform plan vpc -s plat-ue2-dev --ci
```

Both produce:
- Plan output with consistent formatting
- Planfile uploaded to configured storage
- PR comments (when in PR context)
- Job summaries (when in CI)
- Status checks (when enabled)
- Outputs written to `$GITHUB_OUTPUT` (when in GitHub Actions)

## Key Design Decisions

### 1. Use Atmos Lifecycle Hooks

Integrate CI behaviors at existing hook points in `pkg/hooks/`:

```go
BeforeTerraformInit  = "before.terraform.init"   // Download planfiles here
AfterTerraformPlan   = "after.terraform.plan"    // Upload planfiles, PR comment, job summary
AfterTerraformApply  = "after.terraform.apply"   // Update PR comment, job summary, export outputs
```

This keeps CI behaviors modular and allows users to extend or replace them.

### 2. Eliminate DynamoDB Dependency

Current GitHub Actions use DynamoDB for planfile metadata. The native implementation stores metadata directly in the same storage backend as the planfile (S3, Azure Blob, GCS, GitHub Artifacts), using JSON sidecar files:

```
s3://bucket/prefix/plat-ue2-dev/vpc/abc123.tfplan           # Planfile
s3://bucket/prefix/plat-ue2-dev/vpc/abc123.metadata.json    # Metadata
```

### 3. Support All Plan-Storage Backends

Implement a registry pattern (following `pkg/store/`) for planfile storage:

- **S3** - AWS S3 bucket with metadata sidecar
- **Azure Blob** - Azure Blob Storage container
- **GCS** - Google Cloud Storage bucket
- **GitHub Artifacts** - GitHub Artifacts API v4
- **Local** - Local filesystem (for development/testing)

### 4. tfcmt-Inspired PR Comments

Create our own PR comment format heavily inspired by [tfcmt](https://github.com/suzuki-shunsuke/tfcmt):

```markdown
## :warning: Plan: `vpc` in `plat-ue2-dev`

| Change | Count |
|--------|-------|
| :heavy_plus_sign: Add | 5 |
| :pencil2: Change | 2 |
| :heavy_minus_sign: Destroy | 0 |

<details>
<summary>Plan Output</summary>

```hcl
# aws_vpc.main will be created
+ resource "aws_vpc" "main" {
    ...
  }
```

</details>

---
<sub>:robot: Generated by [Atmos](https://atmos.tools) ‚Ä¢ 2025-01-15T10:30:00Z</sub>
```

### 5. Use Existing Plan-Diff for Verification

The `--verify-plan` flag uses the existing plan-diff implementation (`internal/exec/terraform_plan_diff*.go`) for semantic comparison:

```bash
# Download planfile and verify it matches current plan
atmos terraform apply vpc -s plat-ue2-dev --download-planfile --verify-plan
```

### 6. Export Terraform Outputs After Apply

Leverage the `pkg/terraform/output/` package (from `osterman/tf-output-format` branch) to export terraform outputs after a successful apply:

```bash
# After apply, outputs are written to $GITHUB_OUTPUT
# Using the format options from pkg/terraform/output/
atmos terraform apply vpc -s plat-ue2-dev --ci
```

## Scope

### In Scope

- **GitHub Actions provider** - Full implementation
- **S3, Azure Blob, GCS, GitHub Artifacts storage** - All backends
- **PR comments** - Create, update, upsert behaviors
- **Job summaries** - `$GITHUB_STEP_SUMMARY` integration
- **Status checks** - Post check runs when operations start/complete (requires `checks: write`)
- **CI outputs** - `$GITHUB_OUTPUT` for both plan and apply
- **Terraform outputs export** - After successful apply
- **`--format=matrix`** - For `describe affected` command
- **`--verify-plan`** - Using existing plan-diff
- **`atmos ci status`** - Show PR/commit status like `gh pr status`

### Out of Scope (Phase 2+)

- **`--affected`/`--all` with artifacts** - Running across all affected components
- **Infracost integration** - Cost estimation
- **GitLab CI provider** - Architecture ready but not implemented
- **Other CI providers** - CircleCI, Azure DevOps, etc.

## Architecture

### Command Registry Pattern

All new commands use the command registry pattern (see `docs/prd/command-registry-pattern.md`):

```go
// cmd/ci/ci.go
package ci

import (
    "github.com/spf13/cobra"
    "github.com/cloudposse/atmos/cmd/internal"
)

func init() {
    internal.Register(&CICommandProvider{})
}

type CICommandProvider struct{}

func (c *CICommandProvider) GetCommand() *cobra.Command {
    return ciCmd
}

func (c *CICommandProvider) GetName() string {
    return "ci"
}

func (c *CICommandProvider) GetGroup() string {
    return "CI/CD Integration"
}

func (c *CICommandProvider) GetAliases() []internal.CommandAlias {
    return nil
}
```

Commands are registered via blank imports in `cmd/root.go`:

```go
import (
    _ "github.com/cloudposse/atmos/cmd/ci"
)
```

### Package Structure

```
pkg/ci/
  ‚îú‚îÄ‚îÄ check.go                 # CheckRun types and constants (‚úÖ implemented)
  ‚îú‚îÄ‚îÄ component_provider.go    # ComponentCIProvider interface (‚úÖ implemented)
  ‚îú‚îÄ‚îÄ component_registry.go    # Component provider registry (‚úÖ implemented)
  ‚îú‚îÄ‚îÄ context.go               # Context struct (run ID, PR, SHA, etc.) (‚úÖ implemented)
  ‚îú‚îÄ‚îÄ executor.go              # Execute() - unified action executor (‚úÖ implemented)
  ‚îú‚îÄ‚îÄ generic.go               # Generic CI provider fallback (‚úÖ implemented)
  ‚îú‚îÄ‚îÄ output.go                # OutputWriter interface (‚úÖ implemented)
  ‚îú‚îÄ‚îÄ provider.go              # Provider interface definition (‚úÖ implemented)
  ‚îú‚îÄ‚îÄ registry.go              # Provider registry (detect and select provider) (‚úÖ implemented)
  ‚îú‚îÄ‚îÄ status.go                # Status, BranchStatus, PRStatus, CheckStatus structs (‚úÖ implemented)
  ‚îú‚îÄ‚îÄ planfile/                # Planfile artifact storage
  ‚îÇ   ‚îú‚îÄ‚îÄ interface.go         # PlanfileStore interface (‚úÖ implemented)
  ‚îÇ   ‚îú‚îÄ‚îÄ registry.go          # Storage backend registry (‚úÖ implemented)
  ‚îÇ   ‚îú‚îÄ‚îÄ s3/
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ store.go         # S3 store (metadata in S3, no DynamoDB) (‚úÖ implemented)
  ‚îÇ   ‚îú‚îÄ‚îÄ github/
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ store.go         # GitHub Artifacts store (‚úÖ implemented)
  ‚îÇ   ‚îî‚îÄ‚îÄ local/
  ‚îÇ       ‚îî‚îÄ‚îÄ store.go         # Local filesystem (dev/testing) (‚úÖ implemented)
  ‚îú‚îÄ‚îÄ github/                  # Implements ci.Provider for GitHub Actions
  ‚îÇ   ‚îú‚îÄ‚îÄ provider.go          # GitHub Actions Provider (‚úÖ implemented)
  ‚îÇ   ‚îú‚îÄ‚îÄ client.go            # GitHub API client wrapper (‚úÖ implemented)
  ‚îÇ   ‚îú‚îÄ‚îÄ checks.go            # Check runs API (‚úÖ implemented)
  ‚îÇ   ‚îî‚îÄ‚îÄ status.go            # GetStatus, GetCombinedStatus (‚úÖ implemented)
  ‚îú‚îÄ‚îÄ terraform/               # Terraform-specific CI provider
  ‚îÇ   ‚îú‚îÄ‚îÄ provider.go          # Terraform CI provider (‚úÖ implemented)
  ‚îÇ   ‚îú‚îÄ‚îÄ parser.go            # Parse plan/apply output (‚úÖ implemented)
  ‚îÇ   ‚îú‚îÄ‚îÄ context.go           # Terraform template context (‚úÖ implemented)
  ‚îÇ   ‚îî‚îÄ‚îÄ templates/
  ‚îÇ       ‚îú‚îÄ‚îÄ plan.md          # Default plan template (‚úÖ implemented)
  ‚îÇ       ‚îî‚îÄ‚îÄ apply.md         # Default apply template (‚úÖ implemented)
  ‚îî‚îÄ‚îÄ templates/
      ‚îî‚îÄ‚îÄ loader.go            # Template loading with override support (‚úÖ implemented)
```

### Core Interfaces

#### Provider Interface

```go
// pkg/ci/provider.go

// Provider represents a CI/CD provider (GitHub Actions, GitLab CI, etc.).
type Provider interface {
    // Name returns the provider name (e.g., "github", "gitlab").
    Name() string

    // Detect returns true if this provider is active in the current environment.
    Detect() bool

    // Context returns CI metadata (run ID, PR info, etc.).
    Context() (*Context, error)

    // GetStatus returns PR/commit status for the current branch (read).
    GetStatus(ctx context.Context, opts StatusOptions) (*Status, error)

    // CreateCheckRun creates a new check run on a commit (write, like Atlantis).
    CreateCheckRun(ctx context.Context, opts CreateCheckRunOptions) (*CheckRun, error)

    // UpdateCheckRun updates an existing check run (write).
    UpdateCheckRun(ctx context.Context, opts UpdateCheckRunOptions) (*CheckRun, error)

    // OutputWriter returns a writer for CI outputs ($GITHUB_OUTPUT, etc.).
    OutputWriter() OutputWriter
}

// OutputWriter writes CI outputs (environment variables, job summaries, etc.).
type OutputWriter interface {
    // WriteOutput writes a key-value pair to CI outputs (e.g., $GITHUB_OUTPUT).
    WriteOutput(key, value string) error

    // WriteSummary writes content to the job summary (e.g., $GITHUB_STEP_SUMMARY).
    WriteSummary(content string) error
}
```

#### Context Struct

```go
// pkg/ci/context.go

// Context contains CI run metadata.
type Context struct {
    Provider    string
    RunID       string
    RunNumber   int
    Workflow    string
    Job         string
    Actor       string
    EventName   string  // "push", "pull_request"
    Ref         string  // Git ref
    SHA         string  // Git commit SHA
    Repository  string  // owner/repo
    RepoOwner   string
    RepoName    string
    PullRequest *PRInfo // nil if not PR
}

type PRInfo struct {
    Number  int
    HeadRef string
    BaseRef string
    URL     string
}
```

#### Status Structs

```go
// pkg/ci/status.go

// Status represents the CI status for display.
type Status struct {
    Repository     string
    CurrentBranch  *BranchStatus    // PR and checks for current branch
    CreatedByUser  []*PRStatus      // PRs created by current user
    ReviewRequests []*PRStatus      // PRs requesting review from user
}

type BranchStatus struct {
    Branch      string
    PullRequest *PRStatus          // nil if no PR for branch
    CommitSHA   string
    Checks      []*CheckStatus
}

type PRStatus struct {
    Number    int
    Title     string
    Branch    string
    Checks    []*CheckStatus
    AllPassed bool
}

type CheckStatus struct {
    Name       string
    Status     string  // "success", "failure", "pending", "skipped"
    Conclusion string
}
```

#### Planfile Store Interface

```go
// pkg/ci/planfile/interface.go

// Store interface for planfile storage backends.
type Store interface {
    // Upload stores planfile with metadata.
    Upload(ctx context.Context, opts UploadOptions) (*UploadResult, error)

    // Download retrieves planfile.
    Download(ctx context.Context, opts DownloadOptions) (*DownloadResult, error)

    // GetMetadata retrieves metadata only (for verification).
    GetMetadata(ctx context.Context, key string) (*Metadata, error)

    // List returns planfiles matching the filter.
    List(ctx context.Context, opts ListOptions) ([]*Metadata, error)

    // Delete removes a planfile.
    Delete(ctx context.Context, key string) error
}

// StoreFactory creates a Store from configuration options.
type StoreFactory func(options map[string]any) (Store, error)
```

#### Planfile Metadata

```go
// pkg/ci/planfile/metadata.go

type Metadata struct {
    Component    string            `json:"component"`
    Stack        string            `json:"stack"`
    SHA          string            `json:"sha"`
    PlanHash     string            `json:"plan_hash"`    // For verification
    CreatedAt    time.Time         `json:"created_at"`
    CreatedBy    string            `json:"created_by"`   // Actor
    RunID        string            `json:"run_id"`
    HasChanges   bool              `json:"has_changes"`
    Additions    int               `json:"additions"`
    Changes      int               `json:"changes"`
    Destructions int               `json:"destructions"`
    Labels       map[string]string `json:"labels,omitempty"`
}
```

## Configuration Schema

Configuration is split between `terraform` (planfile storage) and `ci` (output behavior) sections in `atmos.yaml`:

```yaml
# atmos.yaml

# Terraform settings including planfile storage
terraform:
  # Planfile storage backends (registry pattern)
  planfiles:
    # Default store to use (references named store below)
    default: "s3"

    # Key pattern for planfile naming (Go template)
    key_pattern: "{{ .Stack }}/{{ .Component }}/{{ .SHA }}.tfplan"

    # Named stores
    stores:
      s3:
        type: s3
        options:
          bucket: "my-terraform-planfiles"
          prefix: "atmos/"
          region: "us-east-1"

      github:
        type: github-artifacts
        options:
          retention_days: 7

      azure:
        type: azure-blob
        options:
          account: "mystorageaccount"
          container: "planfiles"

      gcs:
        type: gcs
        options:
          bucket: "my-gcs-bucket"
          prefix: "planfiles/"

      local:
        type: local
        options:
          path: ".atmos/planfiles"

# CI-specific settings (provider-agnostic naming)
ci:
  # Auto-enabled when CI detected, or explicit
  enabled: true

  # Output variables for downstream jobs
  # GitHub: $GITHUB_OUTPUT, GitLab: dotenv artifacts
  output:
    enabled: true
    variables:
      - has_changes
      - has_additions
      - has_destructions
      - artifact_key
      - plan_summary

  # Job summary with plan/apply results
  # GitHub: $GITHUB_STEP_SUMMARY, GitLab: job artifacts
  summary:
    enabled: true
    # template: "custom-summary.md"

  # Commit status checks
  # GitHub: Check Runs API, GitLab: Commit Status API
  checks:
    enabled: false  # Disabled by default (requires additional permissions)
    context_prefix: "atmos"

  # PR/MR comments
  # GitHub: PR comments, GitLab: MR notes
  comments:
    enabled: true
    behavior: upsert  # create, update, upsert
    # template: "custom-comment.md"

  # Template overrides (shared across all features)
  templates:
    base_path: ".atmos/ci/templates"
    terraform:
      plan: "plan.md"
      apply: "apply.md"
```

## CLI Commands and Flags

### New `atmos ci` Command Group

```bash
# Show CI status for current commit (like gh pr status, but using GitHub API directly)
atmos ci status
```

**Example Output (when on a PR branch):**

```
Relevant pull requests in cloudposse/infra-live

Current branch
  #123  Add VPC module [feature-branch]
    - ‚úì terraform-plan (success)
    - ‚úì terraform-validate (success)
    - ‚óã terraform-apply (pending)
    - ‚úó security-scan (failure)

Created by you
  #120  Update EKS cluster [eks-upgrade]
    - ‚úì All checks passing

Requesting a code review from you
  #118  Refactor networking [net-refactor]
    - ‚úì All checks passing
```

**Example Output (when not on a PR branch):**

```
Commit status for abc123d in cloudposse/infra-live

  ‚úì terraform-validate (success)
  ‚óã terraform-plan (pending)
  ‚úó lint (failure)

No open pull request for current branch.
```

### New `atmos terraform planfile` Subcommand Group

```bash
# Upload planfile to configured storage
atmos terraform planfile upload <component> -s <stack> [--store default]

# Download planfile from storage
atmos terraform planfile download <component> -s <stack> [--store default] [--run-id 123]

# List planfiles for a component/stack
atmos terraform planfile list <component> -s <stack> [--store default]

# Delete planfile from storage
atmos terraform planfile delete <component> -s <stack> [--sha abc123] [--store default]

# Show planfile metadata
atmos terraform planfile show <component> -s <stack> [--sha abc123] [--store default]
```

### Flag Changes

**Terraform (persistent):**

| Flag | Environment Variable | Description |
|------|---------------------|-------------|
| `--ci` | `CI` | Enable CI mode (auto-detected from `CI` env var) |

The `--ci` flag is bound to the `CI` environment variable, which is set by all major CI providers (GitHub Actions, GitLab CI, CircleCI, Jenkins, etc.). This means CI behaviors are automatically enabled when running in CI without requiring explicit flags.

```go
// pkg/flags binding
flags.WithBoolFlag("ci", "", false, "Enable CI mode"),
flags.WithEnvVars("ci", "ATMOS_CI", "CI"),  // ATMOS_CI takes precedence over CI
```

**Plan command:**

| Flag | Description |
|------|-------------|
| `--upload-planfile` | Upload planfile to configured storage |
| `--planfile-key` | Custom planfile key (overrides pattern) |

**Deploy command:**

| Flag | Description |
|------|-------------|
| `--download-planfile` | Download planfile from configured storage |
| `--planfile-key` | Planfile key to download |
| `--planfile-run-id` | Run ID to download from (GitHub Artifacts) |
| `--verify-plan` | Verify plan hasn't changed (uses plan-diff) |

**Describe Affected:**

| Flag | Description |
|------|-------------|
| `--format=matrix` | Output GitHub Actions matrix format |

## CI Output Variables

### After `terraform plan`

```bash
# Written to $GITHUB_OUTPUT
has_changes=true
has_additions=true
has_additions_count=5
has_changes_count=2
has_destructions=false
has_destructions_count=0
artifact_key=plat-ue2-dev/vpc/abc123.tfplan
plan_exit_code=2
```

### After `terraform apply`

```bash
# Written to $GITHUB_OUTPUT
apply_exit_code=0
success=true

# Terraform outputs (using pkg/terraform/output/ formats)
# All outputs are exported in the configured format
output_vpc_id=vpc-12345678
output_subnet_ids=["subnet-1","subnet-2"]
```

The terraform outputs use the format options from `pkg/terraform/output/`:
- `FormatEnv` - Default for `$GITHUB_OUTPUT` (key=value)
- Flattening support for nested outputs
- Uppercase conversion for environment variable compatibility

## Describe Affected Matrix Format

```bash
atmos describe affected --format=matrix
```

Output:

```json
{"include":[{"component":"vpc","stack":"plat-ue2-dev"},{"component":"eks","stack":"plat-ue2-dev"}]}
```

This format is directly consumable by GitHub Actions matrix strategy:

```yaml
jobs:
  plan:
    strategy:
      matrix: ${{ fromJson(needs.affected.outputs.matrix) }}
```

## Files to Create

| File | Purpose | Status |
|------|---------|--------|
| **pkg/ci/** | | |
| `pkg/ci/provider.go` | Provider interface definition | ‚úÖ Done |
| `pkg/ci/context.go` | Context struct (run ID, PR, SHA, etc.) | ‚úÖ Done |
| `pkg/ci/status.go` | Status, BranchStatus, PRStatus, CheckStatus structs | ‚úÖ Done |
| `pkg/ci/output.go` | OutputWriter interface | ‚úÖ Done |
| `pkg/ci/registry.go` | Provider registry (detect and select provider) | ‚úÖ Done |
| `pkg/ci/check.go` | CheckRun types and constants | ‚úÖ Done |
| `pkg/ci/executor.go` | Execute() - unified action executor | ‚úÖ Done |
| `pkg/ci/generic.go` | Generic CI provider fallback | ‚úÖ Done |
| `pkg/ci/component_provider.go` | ComponentCIProvider interface | ‚úÖ Done |
| `pkg/ci/component_registry.go` | Component provider registry | ‚úÖ Done |
| **pkg/ci/planfile/** | | |
| `pkg/ci/planfile/interface.go` | PlanfileStore interface | ‚úÖ Done |
| `pkg/ci/planfile/registry.go` | Store registry | ‚úÖ Done |
| `pkg/ci/planfile/s3/store.go` | S3 implementation | ‚úÖ Done |
| `pkg/ci/planfile/github/store.go` | GitHub Artifacts store | ‚úÖ Done |
| `pkg/ci/planfile/local/store.go` | Local filesystem store | ‚úÖ Done |
| `pkg/ci/planfile/azure/store.go` | Azure Blob implementation | ‚è≥ Phase 2 |
| `pkg/ci/planfile/gcs/store.go` | GCS implementation | ‚è≥ Phase 2 |
| **pkg/ci/github/** | Implements `ci.Provider` interface for GitHub Actions | |
| `pkg/ci/github/provider.go` | GitHub Actions Provider (implements ci.Provider) | ‚úÖ Done |
| `pkg/ci/github/client.go` | GitHub API client wrapper (uses go-github v59) | ‚úÖ Done |
| `pkg/ci/github/status.go` | GetStatus, GetCombinedStatus, GetCheckRuns | ‚úÖ Done |
| `pkg/ci/github/checks.go` | Check runs API | ‚úÖ Done |
| `pkg/ci/github/pulls.go` | GetPullRequestsForBranch, GetPullRequestsCreatedByUser, etc. | ‚è≥ Phase 4 |
| `pkg/ci/github/user.go` | GetAuthenticatedUser for current user info | ‚è≥ Phase 4 |
| `pkg/ci/github/output.go` | $GITHUB_OUTPUT, $GITHUB_STEP_SUMMARY writer | ‚è≥ Phase 4 |
| `pkg/ci/github/comment.go` | PR comment templates (tfcmt-inspired) | ‚è≥ Phase 4 |
| **pkg/ci/terraform/** | Terraform-specific CI provider | |
| `pkg/ci/terraform/provider.go` | Terraform CI provider | ‚úÖ Done |
| `pkg/ci/terraform/parser.go` | Parse plan/apply output | ‚úÖ Done |
| `pkg/ci/terraform/context.go` | Terraform template context | ‚úÖ Done |
| `pkg/ci/terraform/templates/plan.md` | Default plan template | ‚úÖ Done |
| `pkg/ci/terraform/templates/apply.md` | Default apply template | ‚úÖ Done |
| **pkg/ci/templates/** | Template loading system | |
| `pkg/ci/templates/loader.go` | Template loading with override support | ‚úÖ Done |
| **cmd/terraform/planfile/** | New subcommand group (added to existing terraform command) | |
| `cmd/terraform/planfile/planfile.go` | Planfile command group (exported for terraform.go to add) | ‚úÖ Done |
| `cmd/terraform/planfile/upload.go` | `atmos terraform planfile upload` | ‚úÖ Done |
| `cmd/terraform/planfile/download.go` | `atmos terraform planfile download` | ‚úÖ Done |
| `cmd/terraform/planfile/list.go` | `atmos terraform planfile list` | ‚úÖ Done |
| `cmd/terraform/planfile/delete.go` | `atmos terraform planfile delete` | ‚úÖ Done |
| `cmd/terraform/planfile/show.go` | `atmos terraform planfile show` | ‚úÖ Done |
| **cmd/ci/** | New command group (uses command registry pattern) | |
| `cmd/ci/ci.go` | CI command group + CICommandProvider (registers via init()) | ‚úÖ Done |
| `cmd/ci/status.go` | `atmos ci status` - show PR/commit status | ‚úÖ Done |
| **pkg/hooks/** | | |
| `pkg/hooks/ci_upload.go` | CI upload hook command | ‚è≥ Phase 3 |
| `pkg/hooks/ci_download.go` | CI download hook command | ‚è≥ Phase 3 |
| `pkg/hooks/ci_comment.go` | CI comment hook command | ‚è≥ Phase 3 |
| `pkg/hooks/ci_summary.go` | CI summary hook command | ‚è≥ Phase 3 |
| `pkg/hooks/ci_output.go` | CI output hook command | ‚è≥ Phase 3 |

## Files to Modify

| File | Changes |
|------|---------|
| `pkg/schema/schema.go` | Add top-level `CI CIConfig` field |
| `pkg/hooks/hooks.go` | Register new CI hook commands |
| `cmd/root.go` | Add blank import `_ "github.com/cloudposse/atmos/cmd/ci"` for registry |
| `cmd/terraform/terraform.go` | Add `--ci` persistent flag |
| `cmd/terraform/plan.go` | Add `--upload-planfile` flags |
| `cmd/terraform/deploy.go` | Add `--download-planfile`, `--verify-plan` flags |
| `cmd/describe/affected.go` | Add `--format=matrix` support |
| `internal/exec/describe_affected.go` | Implement matrix format output |
| `internal/exec/terraform.go` | Integrate CI hooks at lifecycle points |
| `errors/errors.go` | Add CI sentinel errors |
| `pkg/datafetcher/schema/atmos-manifest/*.json` | JSON schema updates |

## Sentinel Errors

```go
// CI errors
ErrCIProviderNotDetected      = errors.New("CI provider not detected")
ErrCIOutputWriteFailed        = errors.New("failed to write CI output")
ErrCIJobSummaryWriteFailed    = errors.New("failed to write job summary")
ErrCIPRCommentFailed          = errors.New("failed to write PR comment")

// Planfile storage errors
ErrPlanfileUploadFailed       = errors.New("planfile upload failed")
ErrPlanfileDownloadFailed     = errors.New("planfile download failed")
ErrPlanfileNotFound           = errors.New("planfile not found")
ErrPlanfileExpired            = errors.New("planfile has expired")
ErrPlanfileStoreNotConfigured = errors.New("planfile store not configured")
ErrPlanfileVerificationFailed = errors.New("planfile verification failed - plan has changed")

// GitHub errors
ErrGitHubTokenNotFound        = errors.New("GitHub token not found")
ErrGitHubRuntimeURLNotFound   = errors.New("GitHub runtime URL not found")
ErrGitHubArtifactAPIError     = errors.New("GitHub Artifacts API error")
```

## Implementation Phases

### Phase 1: Core Infrastructure

1. Create `pkg/ci/` package structure
2. Implement Provider interface and GitHub provider
3. Implement Context and detection
4. Add schema types to `pkg/schema/ci.go`
5. Add `--ci` flag to terraform commands
6. Implement `atmos ci status` command

### Phase 2: Planfile Storage

1. Implement PlanfileStore interface
2. Implement S3 store (no DynamoDB)
3. Implement Azure Blob store
4. Implement GCS store
5. Implement GitHub Artifacts store
6. Implement local filesystem store
7. Add `atmos terraform planfile` commands

### Phase 3: Hook Integration

1. Create CI hook commands
2. Register hooks in `pkg/hooks/hooks.go`
3. Integrate into `internal/exec/terraform.go`
4. Implement `--verify-plan` using plan-diff

### Phase 4: Outputs and Comments

1. Implement `$GITHUB_OUTPUT` writer
2. Implement `$GITHUB_STEP_SUMMARY` writer
3. Implement PR comment templates
4. Implement comment upsert behavior
5. Integrate terraform outputs export (using `pkg/terraform/output/`)

### Phase 5: Describe Affected Matrix

1. Add `--format=matrix` flag
2. Implement matrix JSON output
3. Update documentation

### Phase 6: Documentation

1. Archive old GitHub Actions docs
2. Write new CI integration docs
3. Update command reference docs

## GitHub API Endpoints

The GitHub provider uses the following API endpoints:

| Endpoint | Purpose |
|----------|---------|
| `GET /repos/{owner}/{repo}/commits/{ref}/status` | Combined commit status |
| `GET /repos/{owner}/{repo}/commits/{ref}/check-runs` | GitHub Actions check runs |
| `GET /repos/{owner}/{repo}/pulls?head={owner}:{branch}` | PRs for current branch |
| `GET /user` | Authenticated user info |
| `GET /search/issues?q=...` | Search for user's PRs |
| `POST /repos/{owner}/{repo}/issues/{number}/comments` | Create PR comment |
| `PATCH /repos/{owner}/{repo}/issues/comments/{id}` | Update PR comment |

## Testing Strategy

### Unit Tests

- Mock GitHub API client for provider tests
- Mock storage backends for planfile store tests
- Table-driven tests for output formatting
- Interface-based testing with generated mocks

### Integration Tests

- Test against real GitHub API (with test token)
- Test against real S3/Azure/GCS (with test credentials)
- Test CI detection in various environments

### End-to-End Tests

- Test full workflow in GitHub Actions
- Test planfile upload/download cycle
- Test PR comment creation/update

## Success Criteria

1. **Parity with GitHub Actions** - All features of existing actions work natively
2. **Local reproducibility** - `--ci` flag produces identical output locally and in CI
3. **No DynamoDB** - Planfile metadata stored in same backend as planfiles
4. **Multi-backend support** - S3, Azure, GCS, GitHub Artifacts all working
5. **Documentation** - Complete docs for migration from GitHub Actions
6. **Performance** - No significant overhead compared to direct terraform calls

## Migration Path

Users currently using the GitHub Actions can migrate incrementally:

1. **Install updated Atmos** - Ensure version with native CI support
2. **Configure `ci:` section** - Add planfile storage configuration
3. **Update workflows** - Replace action with `atmos terraform plan --ci`
4. **Test locally** - Verify behavior matches using `--ci` flag
5. **Remove action dependencies** - Clean up workflow files

## FAQ

### Q: Will this replace the GitHub Actions?

**A:** Yes, the goal is to deprecate the external GitHub Actions in favor of native CLI support. The actions will be archived with migration documentation.

### Q: Can I use different storage backends for different environments?

**A:** Yes, configure multiple named stores in `ci.planfiles` and specify which to use via `--store` flag or per-stack configuration.

### Q: How does authentication work?

**A:** Uses existing Atmos auth infrastructure (`atmos auth`). For GitHub API, uses `GITHUB_TOKEN` or `ATMOS_GITHUB_TOKEN`. For cloud storage, uses standard SDK credential chains.

### Q: What about GitLab CI?

**A:** The architecture supports multiple providers via the `Provider` interface. GitLab CI implementation is planned for Phase 2+.

### Q: How do terraform outputs get exported?

**A:** After a successful `terraform apply --ci`, all terraform outputs are exported to `$GITHUB_OUTPUT` using the format options from `pkg/terraform/output/`. This includes support for flattening nested outputs and uppercase conversion for environment variable compatibility.

## References

- [Existing CI Detection](pkg/telemetry/ci.go) - Detects 24+ CI providers
- [Lifecycle Hooks](pkg/hooks/) - Hook system for terraform events
- [Plan-Diff](internal/exec/terraform_plan_diff*.go) - Semantic plan comparison
- [Store Registry](pkg/store/registry.go) - Pattern for planfile stores
- [Terraform Output Package](pkg/terraform/output/) - Output formatting (tf-output-format branch)
- [tfcmt](https://github.com/suzuki-shunsuke/tfcmt) - Inspiration for PR comments
- [GitHub Artifacts API v4](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts)

## Implementation Status

| Phase | Description | Status | Completion |
|-------|-------------|--------|------------|
| **Phase 1** | Core Infrastructure | ‚úÖ Complete | 100% |
| | pkg/ci/ package structure | ‚úÖ Done | |
| | Provider interface and GitHub provider | ‚úÖ Done | |
| | Context and detection | ‚úÖ Done | |
| | Schema types in pkg/schema/ci.go | ‚úÖ Done | |
| | `atmos ci status` command | ‚úÖ Done | |
| **Phase 2** | Planfile Storage | üîÑ In Progress | ~70% |
| | PlanfileStore interface | ‚úÖ Done | |
| | S3 store | ‚úÖ Done | |
| | GitHub Artifacts store | ‚úÖ Done | |
| | Local filesystem store | ‚úÖ Done | |
| | Azure Blob store | ‚è≥ Not Started | |
| | GCS store | ‚è≥ Not Started | |
| | `atmos terraform planfile` commands | ‚úÖ Done | |
| **Phase 3** | Hook Integration | ‚è≥ Not Started | 0% |
| | CI hook commands | ‚è≥ Not Started | |
| | Register hooks in pkg/hooks/hooks.go | ‚è≥ Not Started | |
| | Integrate into internal/exec/terraform.go | ‚è≥ Not Started | |
| | `--verify-plan` using plan-diff | ‚è≥ Not Started | |
| **Phase 4** | Outputs and Comments | ‚è≥ Not Started | 0% |
| | $GITHUB_OUTPUT writer | ‚è≥ Not Started | |
| | $GITHUB_STEP_SUMMARY writer | ‚è≥ Not Started | |
| | PR comment templates | ‚è≥ Not Started | |
| | Comment upsert behavior | ‚è≥ Not Started | |
| | Terraform outputs export | ‚è≥ Not Started | |
| **Phase 5** | Describe Affected Matrix | ‚è≥ Not Started | 0% |
| | `--format=matrix` flag | ‚è≥ Not Started | |
| | Matrix JSON output | ‚è≥ Not Started | |
| **Phase 6** | Documentation | ‚è≥ Not Started | 0% |
| | Archive old GitHub Actions docs | ‚è≥ Not Started | |
| | Write new CI integration docs | ‚è≥ Not Started | |
| | Update command reference docs | ‚è≥ Not Started | |

### Additional Components Implemented (Beyond Original PRD)

| Component | File | Purpose |
|-----------|------|---------|
| Check types | `pkg/ci/check.go` | CheckRun types and constants |
| Generic provider | `pkg/ci/generic.go` | Fallback CI provider for non-GitHub environments |
| Component provider | `pkg/ci/component_provider.go` | ComponentCIProvider interface for terraform/helmfile |
| Component registry | `pkg/ci/component_registry.go` | Registry for component-type providers |
| Executor | `pkg/ci/executor.go` | Unified action executor |
| Terraform provider | `pkg/ci/terraform/` | Terraform-specific CI behavior |
| Template loader | `pkg/ci/templates/loader.go` | Template loading with override support |
| GitHub checks | `pkg/ci/github/checks.go` | GitHub check runs API |

## Changelog

| Version | Date | Changes |
|---------|------|---------|
| 1.1 | 2025-12-18 | Updated PRD with implementation status, documented additional components |
| 1.0 | 2025-12-17 | Initial PRD |
