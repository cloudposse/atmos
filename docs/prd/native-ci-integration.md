# Native CI Integration

## Overview

This document describes the native CI integration for Atmos, which provides first-class CI/CD support directly in the CLI. This eliminates the need for external GitHub Actions (github-action-atmos-terraform-plan and github-action-atmos-terraform-apply) while providing a consistent experience across local development and CI environments.

## Problem Statement

### Current State

Users running Atmos in CI/CD pipelines rely on external GitHub Actions maintained separately from the core CLI:

- **github-action-atmos-terraform-plan** - Wraps `atmos terraform plan` with CI-specific behaviors
- **github-action-atmos-terraform-apply** - Wraps `atmos terraform apply` with CI-specific behaviors

This creates several challenges:

1. **Inconsistent behavior** - Local runs differ from CI runs
2. **Maintenance burden** - Two codebases to maintain and keep in sync
3. **Limited portability** - Actions are GitHub-specific
4. **Complex scripting** - Users write bash to glue together plan files, PR comments, etc.
5. **Feature gaps** - Actions lag behind CLI capabilities
6. **Debugging difficulty** - Hard to reproduce CI behavior locally

### Desired State

Users can run `atmos terraform plan --ci` locally or in CI with **identical behavior**:

```bash
# Local development
atmos terraform plan vpc -s plat-ue2-dev --ci

# CI pipeline (same command)
atmos terraform plan vpc -s plat-ue2-dev --ci
```

Both produce:
- Plan output with consistent formatting
- Planfile uploaded to configured storage
- PR comments (when in PR context)
- Job summaries (when in CI)
- Outputs written to `$GITHUB_OUTPUT` (when in GitHub Actions)

## Key Design Decisions

### 1. Use Atmos Lifecycle Hooks

Integrate CI behaviors at existing hook points in `pkg/hooks/`:

```go
BeforeTerraformInit  = "before.terraform.init"   // Download planfiles here
AfterTerraformPlan   = "after.terraform.plan"    // Upload planfiles, PR comment, job summary
AfterTerraformApply  = "after.terraform.apply"   // Update PR comment, job summary, export outputs
```

This keeps CI behaviors modular and allows users to extend or replace them.

### 2. Eliminate DynamoDB Dependency

Current GitHub Actions use DynamoDB for planfile metadata. The native implementation stores metadata directly in the same storage backend as the planfile (S3, Azure Blob, GCS, GitHub Artifacts), using JSON sidecar files:

```
s3://bucket/prefix/plat-ue2-dev/vpc/abc123.tfplan           # Planfile
s3://bucket/prefix/plat-ue2-dev/vpc/abc123.metadata.json    # Metadata
```

### 3. Support All Plan-Storage Backends

Implement a registry pattern (following `pkg/store/`) for planfile storage:

- **S3** - AWS S3 bucket with metadata sidecar
- **Azure Blob** - Azure Blob Storage container
- **GCS** - Google Cloud Storage bucket
- **GitHub Artifacts** - GitHub Artifacts API v4
- **Local** - Local filesystem (for development/testing)

### 4. tfcmt-Inspired PR Comments

Create our own PR comment format heavily inspired by [tfcmt](https://github.com/suzuki-shunsuke/tfcmt):

```markdown
## :warning: Plan: `vpc` in `plat-ue2-dev`

| Change | Count |
|--------|-------|
| :heavy_plus_sign: Add | 5 |
| :pencil2: Change | 2 |
| :heavy_minus_sign: Destroy | 0 |

<details>
<summary>Plan Output</summary>

```hcl
# aws_vpc.main will be created
+ resource "aws_vpc" "main" {
    ...
  }
```

</details>

---
<sub>:robot: Generated by [Atmos](https://atmos.tools) • 2025-01-15T10:30:00Z</sub>
```

### 5. Use Existing Plan-Diff for Verification

The `--verify-plan` flag uses the existing plan-diff implementation (`internal/exec/terraform_plan_diff*.go`) for semantic comparison:

```bash
# Download planfile and verify it matches current plan
atmos terraform apply vpc -s plat-ue2-dev --download-planfile --verify-plan
```

### 6. Export Terraform Outputs After Apply

Leverage the `pkg/terraform/output/` package (from `osterman/tf-output-format` branch) to export terraform outputs after a successful apply:

```bash
# After apply, outputs are written to $GITHUB_OUTPUT
# Using the format options from pkg/terraform/output/
atmos terraform apply vpc -s plat-ue2-dev --ci
```

## Scope

### In Scope

- **GitHub Actions provider** - Full implementation
- **S3, Azure Blob, GCS, GitHub Artifacts storage** - All backends
- **PR comments** - Create, update, upsert behaviors
- **Job summaries** - `$GITHUB_STEP_SUMMARY` integration
- **CI outputs** - `$GITHUB_OUTPUT` for both plan and apply
- **Terraform outputs export** - After successful apply
- **`--format=matrix`** - For `describe affected` command
- **`--verify-plan`** - Using existing plan-diff
- **`atmos ci status`** - Show PR/commit status like `gh pr status`

### Out of Scope (Phase 2+)

- **`--affected`/`--all` with artifacts** - Running across all affected components
- **Infracost integration** - Cost estimation
- **GitLab CI provider** - Architecture ready but not implemented
- **Other CI providers** - CircleCI, Azure DevOps, etc.

## Architecture

### Command Registry Pattern

All new commands use the command registry pattern (see `docs/prd/command-registry-pattern.md`):

```go
// cmd/ci/ci.go
package ci

import (
    "github.com/spf13/cobra"
    "github.com/cloudposse/atmos/cmd/internal"
)

func init() {
    internal.Register(&CICommandProvider{})
}

type CICommandProvider struct{}

func (c *CICommandProvider) GetCommand() *cobra.Command {
    return ciCmd
}

func (c *CICommandProvider) GetName() string {
    return "ci"
}

func (c *CICommandProvider) GetGroup() string {
    return "CI/CD Integration"
}

func (c *CICommandProvider) GetAliases() []internal.CommandAlias {
    return nil
}
```

Commands are registered via blank imports in `cmd/root.go`:

```go
import (
    _ "github.com/cloudposse/atmos/cmd/ci"
)
```

### Package Structure

```
pkg/ci/
  ├── ci.go                    # Core Service orchestration
  ├── provider.go              # Provider interface definition
  ├── context.go               # Context struct (run ID, PR, SHA, etc.)
  ├── status.go                # Status, BranchStatus, PRStatus, CheckStatus structs
  ├── errors.go                # Sentinel errors
  ├── output.go                # OutputWriter interface
  ├── registry.go              # Provider registry (detect and select provider)
  ├── planfile/                # Planfile artifact storage
  │   ├── interface.go         # PlanfileStore interface
  │   ├── registry.go          # Storage backend registry
  │   ├── metadata.go          # Metadata struct (stored with planfile)
  │   ├── s3/
  │   │   └── store.go         # S3 store (metadata in S3, no DynamoDB)
  │   ├── azure/
  │   │   └── store.go         # Azure Blob store
  │   ├── gcs/
  │   │   └── store.go         # GCS store
  │   ├── github/
  │   │   ├── client.go        # GitHub Artifacts API v4 client
  │   │   └── store.go         # GitHub Artifacts store
  │   └── local/
  │       └── store.go         # Local filesystem (dev/testing)
  └── github/                  # Implements ci.Provider for GitHub Actions
      ├── provider.go          # GitHub Actions Provider
      ├── client.go            # GitHub API client wrapper (uses go-github v59)
      ├── status.go            # GetStatus, GetCombinedStatus, GetCheckRuns
      ├── pulls.go             # GetPullRequestsForBranch, etc.
      ├── user.go              # GetAuthenticatedUser
      ├── output.go            # $GITHUB_OUTPUT, $GITHUB_STEP_SUMMARY writer
      └── comment.go           # PR comment templates (tfcmt-inspired)
```

### Core Interfaces

#### Provider Interface

```go
// pkg/ci/provider.go

// Provider represents a CI/CD provider (GitHub Actions, GitLab CI, etc.).
type Provider interface {
    // Name returns the provider name (e.g., "github", "gitlab").
    Name() string

    // Detect returns true if this provider is active in the current environment.
    Detect() bool

    // Context returns CI metadata (run ID, PR info, etc.).
    Context() (*Context, error)

    // GetStatus returns PR/commit status for the current branch (read).
    GetStatus(ctx context.Context, opts StatusOptions) (*Status, error)

    // CreateCheckRun creates a new check run on a commit (write, like Atlantis).
    CreateCheckRun(ctx context.Context, opts CreateCheckRunOptions) (*CheckRun, error)

    // UpdateCheckRun updates an existing check run (write).
    UpdateCheckRun(ctx context.Context, opts UpdateCheckRunOptions) (*CheckRun, error)

    // OutputWriter returns a writer for CI outputs ($GITHUB_OUTPUT, etc.).
    OutputWriter() OutputWriter
}

// OutputWriter writes CI outputs (environment variables, job summaries, etc.).
type OutputWriter interface {
    // WriteOutput writes a key-value pair to CI outputs (e.g., $GITHUB_OUTPUT).
    WriteOutput(key, value string) error

    // WriteSummary writes content to the job summary (e.g., $GITHUB_STEP_SUMMARY).
    WriteSummary(content string) error
}
```

#### Context Struct

```go
// pkg/ci/context.go

// Context contains CI run metadata.
type Context struct {
    Provider    string
    RunID       string
    RunNumber   int
    Workflow    string
    Job         string
    Actor       string
    EventName   string  // "push", "pull_request"
    Ref         string  // Git ref
    SHA         string  // Git commit SHA
    Repository  string  // owner/repo
    RepoOwner   string
    RepoName    string
    PullRequest *PRInfo // nil if not PR
}

type PRInfo struct {
    Number  int
    HeadRef string
    BaseRef string
    URL     string
}
```

#### Status Structs

```go
// pkg/ci/status.go

// Status represents the CI status for display.
type Status struct {
    Repository     string
    CurrentBranch  *BranchStatus    // PR and checks for current branch
    CreatedByUser  []*PRStatus      // PRs created by current user
    ReviewRequests []*PRStatus      // PRs requesting review from user
}

type BranchStatus struct {
    Branch      string
    PullRequest *PRStatus          // nil if no PR for branch
    CommitSHA   string
    Checks      []*CheckStatus
}

type PRStatus struct {
    Number    int
    Title     string
    Branch    string
    Checks    []*CheckStatus
    AllPassed bool
}

type CheckStatus struct {
    Name       string
    Status     string  // "success", "failure", "pending", "skipped"
    Conclusion string
}
```

#### Planfile Store Interface

```go
// pkg/ci/planfile/interface.go

// Store interface for planfile storage backends.
type Store interface {
    // Upload stores planfile with metadata.
    Upload(ctx context.Context, opts UploadOptions) (*UploadResult, error)

    // Download retrieves planfile.
    Download(ctx context.Context, opts DownloadOptions) (*DownloadResult, error)

    // GetMetadata retrieves metadata only (for verification).
    GetMetadata(ctx context.Context, key string) (*Metadata, error)

    // List returns planfiles matching the filter.
    List(ctx context.Context, opts ListOptions) ([]*Metadata, error)

    // Delete removes a planfile.
    Delete(ctx context.Context, key string) error
}

// StoreFactory creates a Store from configuration options.
type StoreFactory func(options map[string]any) (Store, error)
```

#### Planfile Metadata

```go
// pkg/ci/planfile/metadata.go

type Metadata struct {
    Component    string            `json:"component"`
    Stack        string            `json:"stack"`
    SHA          string            `json:"sha"`
    PlanHash     string            `json:"plan_hash"`    // For verification
    CreatedAt    time.Time         `json:"created_at"`
    CreatedBy    string            `json:"created_by"`   // Actor
    RunID        string            `json:"run_id"`
    HasChanges   bool              `json:"has_changes"`
    Additions    int               `json:"additions"`
    Changes      int               `json:"changes"`
    Destructions int               `json:"destructions"`
    Labels       map[string]string `json:"labels,omitempty"`
}
```

## Configuration Schema

Add top-level `ci` section to `atmos.yaml`:

```yaml
# atmos.yaml

ci:
  # Auto-enabled when CI detected, or explicit
  enabled: true

  # Planfile storage backends (registry pattern)
  planfiles:
    # Named stores
    default:
      type: s3
      options:
        bucket: "my-terraform-planfiles"
        prefix: "atmos/"
        region: "us-east-1"

    github:
      type: github-artifacts
      options:
        retention_days: 7

    azure:
      type: azure-blob
      options:
        account: "mystorageaccount"
        container: "planfiles"

    gcs:
      type: gcs
      options:
        bucket: "my-gcs-bucket"
        prefix: "planfiles/"

    local:
      type: local
      options:
        path: ".atmos/planfiles"

  # Default store to use (references named store above)
  default_planfile_store: default

  # Key pattern for planfile naming (Go template)
  planfile_key_pattern: "{{ .Stack }}/{{ .Component }}/{{ .SHA }}.tfplan"

  # Output configuration
  outputs:
    # Write to $GITHUB_OUTPUT
    github_output: true

    # Write job summary to $GITHUB_STEP_SUMMARY
    job_summary: true

    # PR comment
    pr_comment:
      enabled: true
      behavior: upsert  # create, update, upsert
      # Custom template file (optional)
      template: ""

  # Variables to output to $GITHUB_OUTPUT
  variables:
    - has_changes
    - has_additions
    - has_destructions
    - artifact_key
    - plan_summary
```

## CLI Commands and Flags

### New `atmos ci` Command Group

```bash
# Show CI status for current commit (like gh pr status, but using GitHub API directly)
atmos ci status
```

**Example Output (when on a PR branch):**

```
Relevant pull requests in cloudposse/infra-live

Current branch
  #123  Add VPC module [feature-branch]
    - ✓ terraform-plan (success)
    - ✓ terraform-validate (success)
    - ○ terraform-apply (pending)
    - ✗ security-scan (failure)

Created by you
  #120  Update EKS cluster [eks-upgrade]
    - ✓ All checks passing

Requesting a code review from you
  #118  Refactor networking [net-refactor]
    - ✓ All checks passing
```

**Example Output (when not on a PR branch):**

```
Commit status for abc123d in cloudposse/infra-live

  ✓ terraform-validate (success)
  ○ terraform-plan (pending)
  ✗ lint (failure)

No open pull request for current branch.
```

### New `atmos terraform planfile` Subcommand Group

```bash
# Upload planfile to configured storage
atmos terraform planfile upload <component> -s <stack> [--store default]

# Download planfile from storage
atmos terraform planfile download <component> -s <stack> [--store default] [--run-id 123]

# List planfiles for a component/stack
atmos terraform planfile list <component> -s <stack> [--store default]

# Delete planfile from storage
atmos terraform planfile delete <component> -s <stack> [--sha abc123] [--store default]

# Show planfile metadata
atmos terraform planfile show <component> -s <stack> [--sha abc123] [--store default]
```

### Flag Changes

**Terraform (persistent):**

| Flag | Environment Variable | Description |
|------|---------------------|-------------|
| `--ci` | `CI` | Enable CI mode (auto-detected from `CI` env var) |

The `--ci` flag is bound to the `CI` environment variable, which is set by all major CI providers (GitHub Actions, GitLab CI, CircleCI, Jenkins, etc.). This means CI behaviors are automatically enabled when running in CI without requiring explicit flags.

```go
// pkg/flags binding
flags.WithBoolFlag("ci", "", false, "Enable CI mode"),
flags.WithEnvVars("ci", "ATMOS_CI", "CI"),  // ATMOS_CI takes precedence over CI
```

**Plan command:**

| Flag | Description |
|------|-------------|
| `--upload-planfile` | Upload planfile to configured storage |
| `--planfile-key` | Custom planfile key (overrides pattern) |

**Deploy command:**

| Flag | Description |
|------|-------------|
| `--download-planfile` | Download planfile from configured storage |
| `--planfile-key` | Planfile key to download |
| `--planfile-run-id` | Run ID to download from (GitHub Artifacts) |
| `--verify-plan` | Verify plan hasn't changed (uses plan-diff) |

**Describe Affected:**

| Flag | Description |
|------|-------------|
| `--format=matrix` | Output GitHub Actions matrix format |

## CI Output Variables

### After `terraform plan`

```bash
# Written to $GITHUB_OUTPUT
has_changes=true
has_additions=true
has_additions_count=5
has_changes_count=2
has_destructions=false
has_destructions_count=0
artifact_key=plat-ue2-dev/vpc/abc123.tfplan
plan_exit_code=2
```

### After `terraform apply`

```bash
# Written to $GITHUB_OUTPUT
apply_exit_code=0
success=true

# Terraform outputs (using pkg/terraform/output/ formats)
# All outputs are exported in the configured format
output_vpc_id=vpc-12345678
output_subnet_ids=["subnet-1","subnet-2"]
```

The terraform outputs use the format options from `pkg/terraform/output/`:
- `FormatEnv` - Default for `$GITHUB_OUTPUT` (key=value)
- Flattening support for nested outputs
- Uppercase conversion for environment variable compatibility

## Describe Affected Matrix Format

```bash
atmos describe affected --format=matrix
```

Output:

```json
{"include":[{"component":"vpc","stack":"plat-ue2-dev"},{"component":"eks","stack":"plat-ue2-dev"}]}
```

This format is directly consumable by GitHub Actions matrix strategy:

```yaml
jobs:
  plan:
    strategy:
      matrix: ${{ fromJson(needs.affected.outputs.matrix) }}
```

## Files to Create

| File | Purpose |
|------|---------|
| **pkg/ci/** | |
| `pkg/ci/ci.go` | Core Service orchestration |
| `pkg/ci/provider.go` | Provider interface definition |
| `pkg/ci/context.go` | Context struct (run ID, PR, SHA, etc.) |
| `pkg/ci/status.go` | Status, BranchStatus, PRStatus, CheckStatus structs |
| `pkg/ci/errors.go` | Sentinel errors |
| `pkg/ci/output.go` | OutputWriter interface |
| `pkg/ci/registry.go` | Provider registry (detect and select provider) |
| **pkg/ci/planfile/** | |
| `pkg/ci/planfile/interface.go` | PlanfileStore interface |
| `pkg/ci/planfile/metadata.go` | Metadata struct |
| `pkg/ci/planfile/registry.go` | Store registry |
| `pkg/ci/planfile/s3/store.go` | S3 implementation |
| `pkg/ci/planfile/azure/store.go` | Azure Blob implementation |
| `pkg/ci/planfile/gcs/store.go` | GCS implementation |
| `pkg/ci/planfile/github/client.go` | GitHub Artifacts API client |
| `pkg/ci/planfile/github/store.go` | GitHub Artifacts store |
| `pkg/ci/planfile/local/store.go` | Local filesystem store |
| **pkg/ci/github/** | Implements `ci.Provider` interface for GitHub Actions |
| `pkg/ci/github/provider.go` | GitHub Actions Provider (implements ci.Provider) |
| `pkg/ci/github/client.go` | GitHub API client wrapper (uses go-github v59) |
| `pkg/ci/github/status.go` | GetStatus, GetCombinedStatus, GetCheckRuns |
| `pkg/ci/github/pulls.go` | GetPullRequestsForBranch, GetPullRequestsCreatedByUser, etc. |
| `pkg/ci/github/user.go` | GetAuthenticatedUser for current user info |
| `pkg/ci/github/output.go` | $GITHUB_OUTPUT, $GITHUB_STEP_SUMMARY writer |
| `pkg/ci/github/comment.go` | PR comment templates (tfcmt-inspired) |
| **cmd/terraform/planfile/** | New subcommand group (added to existing terraform command) |
| `cmd/terraform/planfile/planfile.go` | Planfile command group (exported for terraform.go to add) |
| `cmd/terraform/planfile/upload.go` | `atmos terraform planfile upload` |
| `cmd/terraform/planfile/download.go` | `atmos terraform planfile download` |
| `cmd/terraform/planfile/list.go` | `atmos terraform planfile list` |
| `cmd/terraform/planfile/delete.go` | `atmos terraform planfile delete` |
| `cmd/terraform/planfile/show.go` | `atmos terraform planfile show` |
| **cmd/ci/** | New command group (uses command registry pattern) |
| `cmd/ci/ci.go` | CI command group + CICommandProvider (registers via init()) |
| `cmd/ci/status.go` | `atmos ci status` - show PR/commit status |
| **pkg/hooks/** | |
| `pkg/hooks/ci_upload.go` | CI upload hook command |
| `pkg/hooks/ci_download.go` | CI download hook command |
| `pkg/hooks/ci_comment.go` | CI comment hook command |
| `pkg/hooks/ci_summary.go` | CI summary hook command |
| `pkg/hooks/ci_output.go` | CI output hook command |

## Files to Modify

| File | Changes |
|------|---------|
| `pkg/schema/schema.go` | Add top-level `CI CIConfig` field |
| `pkg/hooks/hooks.go` | Register new CI hook commands |
| `cmd/root.go` | Add blank import `_ "github.com/cloudposse/atmos/cmd/ci"` for registry |
| `cmd/terraform/terraform.go` | Add `--ci` persistent flag |
| `cmd/terraform/plan.go` | Add `--upload-planfile` flags |
| `cmd/terraform/deploy.go` | Add `--download-planfile`, `--verify-plan` flags |
| `cmd/describe/affected.go` | Add `--format=matrix` support |
| `internal/exec/describe_affected.go` | Implement matrix format output |
| `internal/exec/terraform.go` | Integrate CI hooks at lifecycle points |
| `errors/errors.go` | Add CI sentinel errors |
| `pkg/datafetcher/schema/atmos-manifest/*.json` | JSON schema updates |

## Sentinel Errors

```go
// CI errors
ErrCIProviderNotDetected      = errors.New("CI provider not detected")
ErrCIOutputWriteFailed        = errors.New("failed to write CI output")
ErrCIJobSummaryWriteFailed    = errors.New("failed to write job summary")
ErrCIPRCommentFailed          = errors.New("failed to write PR comment")

// Planfile storage errors
ErrPlanfileUploadFailed       = errors.New("planfile upload failed")
ErrPlanfileDownloadFailed     = errors.New("planfile download failed")
ErrPlanfileNotFound           = errors.New("planfile not found")
ErrPlanfileExpired            = errors.New("planfile has expired")
ErrPlanfileStoreNotConfigured = errors.New("planfile store not configured")
ErrPlanfileVerificationFailed = errors.New("planfile verification failed - plan has changed")

// GitHub errors
ErrGitHubTokenNotFound        = errors.New("GitHub token not found")
ErrGitHubRuntimeURLNotFound   = errors.New("GitHub runtime URL not found")
ErrGitHubArtifactAPIError     = errors.New("GitHub Artifacts API error")
```

## Implementation Phases

### Phase 1: Core Infrastructure

1. Create `pkg/ci/` package structure
2. Implement Provider interface and GitHub provider
3. Implement Context and detection
4. Add schema types to `pkg/schema/ci.go`
5. Add `--ci` flag to terraform commands
6. Implement `atmos ci status` command

### Phase 2: Planfile Storage

1. Implement PlanfileStore interface
2. Implement S3 store (no DynamoDB)
3. Implement Azure Blob store
4. Implement GCS store
5. Implement GitHub Artifacts store
6. Implement local filesystem store
7. Add `atmos terraform planfile` commands

### Phase 3: Hook Integration

1. Create CI hook commands
2. Register hooks in `pkg/hooks/hooks.go`
3. Integrate into `internal/exec/terraform.go`
4. Implement `--verify-plan` using plan-diff

### Phase 4: Outputs and Comments

1. Implement `$GITHUB_OUTPUT` writer
2. Implement `$GITHUB_STEP_SUMMARY` writer
3. Implement PR comment templates
4. Implement comment upsert behavior
5. Integrate terraform outputs export (using `pkg/terraform/output/`)

### Phase 5: Describe Affected Matrix

1. Add `--format=matrix` flag
2. Implement matrix JSON output
3. Update documentation

### Phase 6: Documentation

1. Archive old GitHub Actions docs
2. Write new CI integration docs
3. Update command reference docs

## GitHub API Endpoints

The GitHub provider uses the following API endpoints:

| Endpoint | Purpose |
|----------|---------|
| `GET /repos/{owner}/{repo}/commits/{ref}/status` | Combined commit status |
| `GET /repos/{owner}/{repo}/commits/{ref}/check-runs` | GitHub Actions check runs |
| `GET /repos/{owner}/{repo}/pulls?head={owner}:{branch}` | PRs for current branch |
| `GET /user` | Authenticated user info |
| `GET /search/issues?q=...` | Search for user's PRs |
| `POST /repos/{owner}/{repo}/issues/{number}/comments` | Create PR comment |
| `PATCH /repos/{owner}/{repo}/issues/comments/{id}` | Update PR comment |

## Testing Strategy

### Unit Tests

- Mock GitHub API client for provider tests
- Mock storage backends for planfile store tests
- Table-driven tests for output formatting
- Interface-based testing with generated mocks

### Integration Tests

- Test against real GitHub API (with test token)
- Test against real S3/Azure/GCS (with test credentials)
- Test CI detection in various environments

### End-to-End Tests

- Test full workflow in GitHub Actions
- Test planfile upload/download cycle
- Test PR comment creation/update

## Success Criteria

1. **Parity with GitHub Actions** - All features of existing actions work natively
2. **Local reproducibility** - `--ci` flag produces identical output locally and in CI
3. **No DynamoDB** - Planfile metadata stored in same backend as planfiles
4. **Multi-backend support** - S3, Azure, GCS, GitHub Artifacts all working
5. **Documentation** - Complete docs for migration from GitHub Actions
6. **Performance** - No significant overhead compared to direct terraform calls

## Migration Path

Users currently using the GitHub Actions can migrate incrementally:

1. **Install updated Atmos** - Ensure version with native CI support
2. **Configure `ci:` section** - Add planfile storage configuration
3. **Update workflows** - Replace action with `atmos terraform plan --ci`
4. **Test locally** - Verify behavior matches using `--ci` flag
5. **Remove action dependencies** - Clean up workflow files

## FAQ

### Q: Will this replace the GitHub Actions?

**A:** Yes, the goal is to deprecate the external GitHub Actions in favor of native CLI support. The actions will be archived with migration documentation.

### Q: Can I use different storage backends for different environments?

**A:** Yes, configure multiple named stores in `ci.planfiles` and specify which to use via `--store` flag or per-stack configuration.

### Q: How does authentication work?

**A:** Uses existing Atmos auth infrastructure (`atmos auth`). For GitHub API, uses `GITHUB_TOKEN` or `ATMOS_GITHUB_TOKEN`. For cloud storage, uses standard SDK credential chains.

### Q: What about GitLab CI?

**A:** The architecture supports multiple providers via the `Provider` interface. GitLab CI implementation is planned for Phase 2+.

### Q: How do terraform outputs get exported?

**A:** After a successful `terraform apply --ci`, all terraform outputs are exported to `$GITHUB_OUTPUT` using the format options from `pkg/terraform/output/`. This includes support for flattening nested outputs and uppercase conversion for environment variable compatibility.

## References

- [Existing CI Detection](pkg/telemetry/ci.go) - Detects 24+ CI providers
- [Lifecycle Hooks](pkg/hooks/) - Hook system for terraform events
- [Plan-Diff](internal/exec/terraform_plan_diff*.go) - Semantic plan comparison
- [Store Registry](pkg/store/registry.go) - Pattern for planfile stores
- [Terraform Output Package](pkg/terraform/output/) - Output formatting (tf-output-format branch)
- [tfcmt](https://github.com/suzuki-shunsuke/tfcmt) - Inspiration for PR comments
- [GitHub Artifacts API v4](https://docs.github.com/en/actions/using-workflows/storing-workflow-data-as-artifacts)

## Changelog

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2025-12-17 | Initial PRD |
