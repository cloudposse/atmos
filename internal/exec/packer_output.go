package exec

import (
	"context"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"time"

	errUtils "github.com/cloudposse/atmos/errors"
	cfg "github.com/cloudposse/atmos/pkg/config"
	log "github.com/cloudposse/atmos/pkg/logger"
	"github.com/cloudposse/atmos/pkg/perf"
	provSource "github.com/cloudposse/atmos/pkg/provisioner/source"
	provWorkdir "github.com/cloudposse/atmos/pkg/provisioner/workdir"
	"github.com/cloudposse/atmos/pkg/schema"
	u "github.com/cloudposse/atmos/pkg/utils"
)

// ExecutePackerOutput executes `atmos packer output` commands.
func ExecutePackerOutput(
	info *schema.ConfigAndStacksInfo,
	packerFlags *PackerFlags,
) (any, error) {
	defer perf.Track(nil, "exec.ExecutePackerOutput")()

	atmosConfig, err := cfg.InitCliConfig(*info, true)
	if err != nil {
		return nil, err
	}

	// Validate packer configuration.
	if err := checkPackerConfig(&atmosConfig); err != nil {
		return nil, err
	}

	*info, err = ProcessStacks(&atmosConfig, *info, true, true, true, nil, nil)
	if err != nil {
		return nil, err
	}

	if len(info.Stack) < 1 {
		return nil, errUtils.ErrMissingStack
	}

	if !info.ComponentIsEnabled {
		log.Info("Component is not enabled and skipped", "component", info.ComponentFromArg)
		return nil, nil
	}

	// Check if the component exists as a Packer component.
	componentPath, err := u.GetComponentPath(&atmosConfig, "packer", info.ComponentFolderPrefix, info.FinalComponent)
	if err != nil {
		return nil, fmt.Errorf("failed to resolve component path: %w", err)
	}

	componentPathExists, err := u.IsDirectory(componentPath)
	if err != nil || !componentPathExists {
		// JIT source provisioning: vendor remote component if source is configured.
		if provSource.HasSource(info.ComponentSection) {
			ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
			defer cancel()
			if err := provSource.AutoProvisionSource(ctx, &atmosConfig, cfg.PackerComponentType, info.ComponentSection, info.AuthContext); err != nil {
				return nil, fmt.Errorf("failed to auto-provision component source: %w", err)
			}

			// Check if source provisioner set a workdir path (source + workdir case).
			if workdirPath, ok := info.ComponentSection[provWorkdir.WorkdirPathKey].(string); ok {
				componentPath = workdirPath
				componentPathExists = true
				err = nil
			} else {
				// Re-check if component path now exists after provisioning.
				componentPathExists, err = u.IsDirectory(componentPath)
			}
		}
	}

	// If component path still doesn't exist, return the error.
	if err != nil || !componentPathExists {
		basePath, _ := u.GetComponentBasePath(&atmosConfig, "packer")
		return nil, fmt.Errorf("%w: '%s' points to the Packer component '%s', but it does not exist in '%s'",
			errUtils.ErrInvalidComponent,
			info.ComponentFromArg,
			info.FinalComponent,
			basePath,
		)
	}

	// Find Packer manifest filename.
	manifestFilename, err := GetPackerManifestFromVars(&info.ComponentVarsSection)
	if err != nil {
		return nil, err
	}

	if manifestFilename == "" {
		manifestFilename = "manifest.json"
	}

	manifestPath := filepath.Join(componentPath, manifestFilename)
	if !u.FileExists(manifestPath) {
		return nil, fmt.Errorf("%w: '%s' (generated by 'atmos packer build', filename configured via 'manifest_file_name' variable)",
			errUtils.ErrMissingPackerManifest,
			filepath.Join(atmosConfig.Components.Packer.BasePath, info.ComponentFolderPrefix, info.FinalComponent, manifestFilename),
		)
	}

	manifestContent, err := os.ReadFile(manifestPath)
	if err != nil {
		return nil, errors.Join(errUtils.ErrReadFile, err)
	}

	data, err := u.ConvertFromJSON(string(manifestContent))
	if err != nil {
		return nil, err
	}

	if packerFlags.Query != "" {
		data, err = u.EvaluateYqExpression(&atmosConfig, data, packerFlags.Query)
		if err != nil {
			return nil, err
		}
	}

	return data, nil
}
