package exec

import (
	"fmt"
	"os"
	"path/filepath"

	log "github.com/charmbracelet/log"

	errUtils "github.com/cloudposse/atmos/errors"
	cfg "github.com/cloudposse/atmos/pkg/config"
	"github.com/cloudposse/atmos/pkg/schema"
	u "github.com/cloudposse/atmos/pkg/utils"
)

// ExecutePackerOutput executes `atmos packer output` commands.
func ExecutePackerOutput(
	info *schema.ConfigAndStacksInfo,
) error {
	atmosConfig, err := cfg.InitCliConfig(*info, true)
	if err != nil {
		return err
	}

	*info, err = ProcessStacks(&atmosConfig, *info, true, true, true, nil)
	if err != nil {
		return err
	}

	if len(info.Stack) < 1 {
		return errUtils.ErrMissingStack
	}

	if !info.ComponentIsEnabled {
		log.Info("Component is not enabled and skipped", "component", info.ComponentFromArg)
		return nil
	}

	// Check if the component exists as a Packer component.
	componentPath := filepath.Join(atmosConfig.PackerDirAbsolutePath, info.ComponentFolderPrefix, info.FinalComponent)
	componentPathExists, err := u.IsDirectory(componentPath)
	if err != nil || !componentPathExists {
		return fmt.Errorf("%w: Atmos component `%s` points to the Packer component `%s`, but it does not exist in `%s`",
			errUtils.ErrInvalidComponent,
			info.ComponentFromArg,
			info.FinalComponent,
			filepath.Join(atmosConfig.Components.Packer.BasePath, info.ComponentFolderPrefix),
		)
	}

	// Find Packer manifest filename.
	manifestFilename, err := GetPackerManifestFromVars(&info.ComponentVarsSection)
	if err != nil {
		return err
	}

	if manifestFilename == "" {
		manifestFilename = "manifest.json"
	}

	manifestPath := filepath.Join(componentPath, manifestFilename)
	if !u.FileExists(manifestPath) {
		return fmt.Errorf("%w: `%s`.\nIt's generated by Packer when executing `atmos packer build`.\nThe manifest filename is specified in the `manifest_file_name` variable of the Atmos component.",
			errUtils.ErrMissingPackerManifest,
			filepath.Join(atmosConfig.Components.Packer.BasePath, info.ComponentFolderPrefix, info.FinalComponent, manifestFilename),
		)
	}

	manifestContent, err := os.ReadFile(manifestPath)
	if err != nil {
		return fmt.Errorf(errUtils.ErrWrappingFormat, errUtils.ErrReadFile, err)
	}

	data, err := u.ConvertFromJSON(string(manifestContent))
	if err != nil {
		return err
	}

	err = u.PrintAsJSON(&atmosConfig, data)
	if err != nil {
		return err
	}

	return nil
}
