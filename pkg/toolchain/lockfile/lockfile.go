package lockfile

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"time"

	"gopkg.in/yaml.v3"

	"github.com/cloudposse/atmos/pkg/perf"
	"github.com/cloudposse/atmos/pkg/version"
)

// Error definitions for the lockfile package.
var (
	// ErrInvalidLockFile indicates the lock file is malformed or missing required fields.
	ErrInvalidLockFile = errors.New("invalid lock file")

	// ErrLockFileNil indicates the lock file is nil.
	ErrLockFileNil = errors.New("lock file is nil")

	// ErrToolMissingVersion indicates a tool entry is missing the version field.
	ErrToolMissingVersion = errors.New("tool missing version")

	// ErrToolNoPlatforms indicates a tool entry has no platform entries.
	ErrToolNoPlatforms = errors.New("tool has no platform entries")

	// ErrPlatformNoURL indicates a platform entry is missing the URL field.
	ErrPlatformNoURL = errors.New("platform entry missing URL")

	// ErrPlatformNoChecksum indicates a platform entry is missing the checksum field.
	ErrPlatformNoChecksum = errors.New("platform entry missing checksum")
)

// LockFile represents the toolchain.lock.yaml structure.
type LockFile struct {
	Version  int              `yaml:"version"`
	Tools    map[string]*Tool `yaml:"tools"`
	Metadata LockFileMetadata `yaml:"metadata"`
}

// Tool represents a locked tool entry.
type Tool struct {
	Version     string                    `yaml:"version"`
	Source      string                    `yaml:"source,omitempty"`
	Platforms   map[string]*PlatformEntry `yaml:"platforms"`
	BinaryName  string                    `yaml:"binary_name,omitempty"`
	InstalledAt string                    `yaml:"installed_at"` // RFC3339
}

// PlatformEntry represents platform-specific download information.
type PlatformEntry struct {
	URL      string `yaml:"url"`
	Checksum string `yaml:"checksum"`
	Size     int64  `yaml:"size"`
}

// LockFileMetadata contains metadata about the lock file.
type LockFileMetadata struct {
	GeneratedAt     string `yaml:"generated_at"` // RFC3339
	AtmosVersion    string `yaml:"atmos_version"`
	Platform        string `yaml:"platform"` // GOOS_GOARCH
	LockFileVersion int    `yaml:"lock_file_version"`
}

// New creates a new empty lock file.
func New() *LockFile {
	defer perf.Track(nil, "lockfile.New")()

	return &LockFile{
		Version: 1,
		Tools:   make(map[string]*Tool),
		Metadata: LockFileMetadata{
			GeneratedAt:     time.Now().UTC().Format(time.RFC3339),
			AtmosVersion:    version.Version,
			LockFileVersion: 1,
		},
	}
}

// Load loads a lock file from disk.
func Load(filePath string) (*LockFile, error) {
	defer perf.Track(nil, "lockfile.Load")()

	data, err := os.ReadFile(filePath)
	if err != nil {
		return nil, fmt.Errorf("failed to read lock file: %w", err)
	}

	var lockFile LockFile
	if err := yaml.Unmarshal(data, &lockFile); err != nil {
		return nil, fmt.Errorf("failed to parse lock file: %w", err)
	}

	// Validate
	if lockFile.Version == 0 {
		return nil, fmt.Errorf("%w: missing version", ErrInvalidLockFile)
	}

	return &lockFile, nil
}

// Save writes the lock file to disk.
func Save(filePath string, lockFile *LockFile) error {
	defer perf.Track(nil, "lockfile.Save")()

	if lockFile == nil {
		return ErrLockFileNil
	}

	// Update metadata
	lockFile.Metadata.GeneratedAt = time.Now().UTC().Format(time.RFC3339)
	lockFile.Metadata.AtmosVersion = version.Version

	data, err := yaml.Marshal(lockFile)
	if err != nil {
		return fmt.Errorf("failed to marshal lock file: %w", err)
	}

	// Ensure directory exists
	dir := filepath.Dir(filePath)
	if err := os.MkdirAll(dir, 0o755); err != nil {
		return fmt.Errorf("failed to create directory: %w", err)
	}

	// Add header comment
	header := `# Generated by Atmos Toolchain
# This file locks tool versions and checksums for reproducible installations
# Do not edit manually - run 'atmos toolchain lock' to update

`
	content := header + string(data)

	//nolint:gosec // G306: Lock file needs to be readable by other processes/users
	if err := os.WriteFile(filePath, []byte(content), 0o644); err != nil {
		return fmt.Errorf("failed to write lock file: %w", err)
	}

	return nil
}

// GetOrCreateTool gets or creates a tool entry in the lock file.
func (lf *LockFile) GetOrCreateTool(tool string) *Tool {
	defer perf.Track(nil, "lockfile.LockFile.GetOrCreateTool")()

	if lf.Tools == nil {
		lf.Tools = make(map[string]*Tool)
	}

	if entry, exists := lf.Tools[tool]; exists {
		return entry
	}

	entry := &Tool{
		Platforms:   make(map[string]*PlatformEntry),
		InstalledAt: time.Now().UTC().Format(time.RFC3339),
	}
	lf.Tools[tool] = entry
	return entry
}

// RemoveTool removes a tool from the lock file.
func (lf *LockFile) RemoveTool(tool string) {
	defer perf.Track(nil, "lockfile.LockFile.RemoveTool")()

	delete(lf.Tools, tool)
}

// Verify verifies the integrity of the lock file.
func Verify(filePath string) error {
	defer perf.Track(nil, "lockfile.Verify")()

	lockFile, err := Load(filePath)
	if err != nil {
		return err
	}

	// Basic validation
	if lockFile.Version == 0 {
		return fmt.Errorf("%w: version is 0", ErrInvalidLockFile)
	}

	if lockFile.Metadata.LockFileVersion == 0 {
		return fmt.Errorf("%w: metadata version is 0", ErrInvalidLockFile)
	}

	// Validate each tool entry
	for toolName, tool := range lockFile.Tools {
		// Guard against nil entries.
		if tool == nil {
			return fmt.Errorf("nil tool entry: %s", toolName)
		}

		if tool.Version == "" {
			return fmt.Errorf("%w: %s", ErrToolMissingVersion, toolName)
		}

		if len(tool.Platforms) == 0 {
			return fmt.Errorf("%w: %s", ErrToolNoPlatforms, toolName)
		}

		for platform, entry := range tool.Platforms {
			if entry.URL == "" {
				return fmt.Errorf("%w: %s/%s", ErrPlatformNoURL, toolName, platform)
			}
			if entry.Checksum == "" {
				return fmt.Errorf("%w: %s/%s", ErrPlatformNoChecksum, toolName, platform)
			}
		}
	}

	return nil
}
