package lockfile

import (
	"errors"
	"os"
	"path/filepath"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestNew(t *testing.T) {
	lf := New()

	assert.NotNil(t, lf)
	assert.Equal(t, 1, lf.Version)
	assert.NotNil(t, lf.Tools)
	assert.Equal(t, 1, lf.Metadata.LockFileVersion)
	assert.NotEmpty(t, lf.Metadata.GeneratedAt)
	assert.NotEmpty(t, lf.Metadata.AtmosVersion)

	// Verify GeneratedAt is valid RFC3339
	_, err := time.Parse(time.RFC3339, lf.Metadata.GeneratedAt)
	assert.NoError(t, err)
}

func TestSave_And_Load(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.lock.yaml")

	// Create a lock file
	lf := New()
	tool := lf.GetOrCreateTool("hashicorp/terraform")
	tool.Version = "1.13.4"
	tool.BinaryName = "terraform"
	tool.Source = "https://github.com/aquaproj/aqua-registry"

	platform := &PlatformEntry{
		URL:      "https://example.com/terraform.zip",
		Checksum: "sha256:abc123def456",
		Size:     95842304,
	}
	tool.Platforms["darwin_arm64"] = platform

	// Save
	err := Save(tmpFile, lf)
	require.NoError(t, err)

	// Verify file exists
	_, err = os.Stat(tmpFile)
	assert.NoError(t, err)

	// Read file contents
	content, err := os.ReadFile(tmpFile)
	require.NoError(t, err)

	// Verify header comment
	assert.Contains(t, string(content), "# Generated by Atmos Toolchain")
	assert.Contains(t, string(content), "Do not edit manually")

	// Verify content
	assert.Contains(t, string(content), "hashicorp/terraform")
	assert.Contains(t, string(content), "1.13.4")
	assert.Contains(t, string(content), "sha256:abc123def456")

	// Load back
	loaded, err := Load(tmpFile)
	require.NoError(t, err)

	assert.Equal(t, 1, loaded.Version)
	assert.Len(t, loaded.Tools, 1)

	loadedTool := loaded.Tools["hashicorp/terraform"]
	require.NotNil(t, loadedTool)
	assert.Equal(t, "1.13.4", loadedTool.Version)
	assert.Equal(t, "terraform", loadedTool.BinaryName)
	assert.Equal(t, "https://github.com/aquaproj/aqua-registry", loadedTool.Source)

	loadedPlatform := loadedTool.Platforms["darwin_arm64"]
	require.NotNil(t, loadedPlatform)
	assert.Equal(t, "https://example.com/terraform.zip", loadedPlatform.URL)
	assert.Equal(t, "sha256:abc123def456", loadedPlatform.Checksum)
	assert.Equal(t, int64(95842304), loadedPlatform.Size)
}

func TestSave_CreatesDirectory(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "subdir", "nested", "test.lock.yaml")

	lf := New()
	err := Save(tmpFile, lf)
	require.NoError(t, err)

	// Verify file and directories were created
	_, err = os.Stat(tmpFile)
	assert.NoError(t, err)
}

func TestSave_NilLockFile(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.lock.yaml")

	err := Save(tmpFile, nil)
	require.Error(t, err)
	assert.True(t, errors.Is(err, ErrLockFileNil))
}

func TestSave_UpdatesMetadata(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "test.lock.yaml")

	lf := New()

	// Save once
	err := Save(tmpFile, lf)
	require.NoError(t, err)

	// Load back
	loaded, err := Load(tmpFile)
	require.NoError(t, err)
	firstTime := loaded.Metadata.GeneratedAt

	// Wait to ensure time difference (RFC3339 is second-precision)
	time.Sleep(1100 * time.Millisecond)

	// Save again
	err = Save(tmpFile, loaded)
	require.NoError(t, err)

	// Load again and verify metadata was updated
	reloaded, err := Load(tmpFile)
	require.NoError(t, err)

	// GeneratedAt should be updated on second save
	assert.NotEqual(t, firstTime, reloaded.Metadata.GeneratedAt)
}

func TestLoad_FileNotFound(t *testing.T) {
	tmpDir := t.TempDir()
	nonExistentFile := filepath.Join(tmpDir, "does-not-exist.yaml")

	_, err := Load(nonExistentFile)
	require.Error(t, err)
	assert.Contains(t, err.Error(), "failed to read lock file")
}

func TestLoad_InvalidYAML(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "invalid.yaml")

	// Write invalid YAML
	err := os.WriteFile(tmpFile, []byte("invalid: yaml: content: {{{"), 0o644)
	require.NoError(t, err)

	_, err = Load(tmpFile)
	require.Error(t, err)
	assert.Contains(t, err.Error(), "failed to parse lock file")
}

func TestLoad_MissingVersion(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "missing-version.yaml")

	// Write lock file without version
	content := `tools:
  terraform:
    version: "1.13.4"
metadata:
  generated_at: "2025-01-01T00:00:00Z"
`
	err := os.WriteFile(tmpFile, []byte(content), 0o644)
	require.NoError(t, err)

	_, err = Load(tmpFile)
	require.Error(t, err)
	assert.True(t, errors.Is(err, ErrInvalidLockFile))
}

func TestGetOrCreateTool_CreateNew(t *testing.T) {
	lf := New()

	tool := lf.GetOrCreateTool("hashicorp/terraform")

	assert.NotNil(t, tool)
	assert.NotNil(t, tool.Platforms)
	assert.NotEmpty(t, tool.InstalledAt)

	// Verify it was added to the lock file
	assert.Len(t, lf.Tools, 1)
	assert.Equal(t, tool, lf.Tools["hashicorp/terraform"])

	// Verify InstalledAt is valid RFC3339
	_, err := time.Parse(time.RFC3339, tool.InstalledAt)
	assert.NoError(t, err)
}

func TestGetOrCreateTool_GetExisting(t *testing.T) {
	lf := New()

	// Create first
	tool1 := lf.GetOrCreateTool("hashicorp/terraform")
	tool1.Version = "1.13.4"
	originalInstalledAt := tool1.InstalledAt

	// Get existing
	tool2 := lf.GetOrCreateTool("hashicorp/terraform")

	// Should return same instance
	assert.Equal(t, tool1, tool2)
	assert.Equal(t, "1.13.4", tool2.Version)
	assert.Equal(t, originalInstalledAt, tool2.InstalledAt)

	// Should still have only one tool
	assert.Len(t, lf.Tools, 1)
}

func TestGetOrCreateTool_NilTools(t *testing.T) {
	lf := &LockFile{
		Version: 1,
		Tools:   nil, // Explicitly nil
	}

	tool := lf.GetOrCreateTool("hashicorp/terraform")

	assert.NotNil(t, tool)
	assert.NotNil(t, lf.Tools)
	assert.Len(t, lf.Tools, 1)
}

func TestRemoveTool(t *testing.T) {
	lf := New()

	// Add multiple tools
	tool1 := lf.GetOrCreateTool("hashicorp/terraform")
	tool1.Version = "1.13.4"

	tool2 := lf.GetOrCreateTool("kubernetes/kubectl")
	tool2.Version = "1.34.1"

	assert.Len(t, lf.Tools, 2)

	// Remove one
	lf.RemoveTool("hashicorp/terraform")

	assert.Len(t, lf.Tools, 1)
	assert.Nil(t, lf.Tools["hashicorp/terraform"])
	assert.NotNil(t, lf.Tools["kubernetes/kubectl"])
}

func TestRemoveTool_NonExistent(t *testing.T) {
	lf := New()

	tool := lf.GetOrCreateTool("hashicorp/terraform")
	tool.Version = "1.13.4"

	// Remove non-existent tool (should not error)
	lf.RemoveTool("does-not-exist")

	// Original tool should still be there
	assert.Len(t, lf.Tools, 1)
	assert.NotNil(t, lf.Tools["hashicorp/terraform"])
}

func TestVerify_ValidLockFile(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "valid.lock.yaml")

	lf := New()
	tool := lf.GetOrCreateTool("hashicorp/terraform")
	tool.Version = "1.13.4"
	tool.Platforms["darwin_arm64"] = &PlatformEntry{
		URL:      "https://example.com/terraform.zip",
		Checksum: "sha256:abc123",
		Size:     123456,
	}

	err := Save(tmpFile, lf)
	require.NoError(t, err)

	err = Verify(tmpFile)
	assert.NoError(t, err)
}

func TestVerify_InvalidVersion(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "invalid-version.yaml")

	content := `version: 0
tools:
  terraform:
    version: "1.13.4"
metadata:
  generated_at: "2025-01-01T00:00:00Z"
  lock_file_version: 1
`
	err := os.WriteFile(tmpFile, []byte(content), 0o644)
	require.NoError(t, err)

	err = Verify(tmpFile)
	require.Error(t, err)
	assert.True(t, errors.Is(err, ErrInvalidLockFile))
}

func TestVerify_InvalidMetadataVersion(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "invalid-metadata.yaml")

	content := `version: 1
tools:
  terraform:
    version: "1.13.4"
    platforms:
      darwin_arm64:
        url: "https://example.com/terraform.zip"
        checksum: "sha256:abc123"
metadata:
  generated_at: "2025-01-01T00:00:00Z"
  lock_file_version: 0
`
	err := os.WriteFile(tmpFile, []byte(content), 0o644)
	require.NoError(t, err)

	err = Verify(tmpFile)
	require.Error(t, err)
	require.True(t, errors.Is(err, ErrInvalidLockFile))
}

func TestVerify_MissingToolVersion(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "missing-tool-version.yaml")

	lf := New()
	tool := lf.GetOrCreateTool("hashicorp/terraform")
	tool.Version = "" // Missing version
	tool.Platforms["darwin_arm64"] = &PlatformEntry{
		URL:      "https://example.com/terraform.zip",
		Checksum: "sha256:abc123",
	}

	err := Save(tmpFile, lf)
	require.NoError(t, err)

	err = Verify(tmpFile)
	require.Error(t, err)
	require.True(t, errors.Is(err, ErrToolMissingVersion))
}

func TestVerify_NoPlatforms(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "no-platforms.yaml")

	lf := New()
	tool := lf.GetOrCreateTool("hashicorp/terraform")
	tool.Version = "1.13.4"
	// No platforms added

	err := Save(tmpFile, lf)
	require.NoError(t, err)

	err = Verify(tmpFile)
	require.Error(t, err)
	require.True(t, errors.Is(err, ErrToolNoPlatforms))
}

func TestVerify_MissingPlatformURL(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "missing-url.yaml")

	lf := New()
	tool := lf.GetOrCreateTool("hashicorp/terraform")
	tool.Version = "1.13.4"
	tool.Platforms["darwin_arm64"] = &PlatformEntry{
		URL:      "", // Missing URL
		Checksum: "sha256:abc123",
	}

	err := Save(tmpFile, lf)
	require.NoError(t, err)

	err = Verify(tmpFile)
	require.Error(t, err)
	require.True(t, errors.Is(err, ErrPlatformNoURL))
}

func TestVerify_MissingPlatformChecksum(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "missing-checksum.yaml")

	lf := New()
	tool := lf.GetOrCreateTool("hashicorp/terraform")
	tool.Version = "1.13.4"
	tool.Platforms["darwin_arm64"] = &PlatformEntry{
		URL:      "https://example.com/terraform.zip",
		Checksum: "", // Missing checksum
	}

	err := Save(tmpFile, lf)
	require.NoError(t, err)

	err = Verify(tmpFile)
	require.Error(t, err)
	require.True(t, errors.Is(err, ErrPlatformNoChecksum))
}

func TestVerify_NilPlatformEntry(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "nil-platform.yaml")

	lf := New()
	tool := lf.GetOrCreateTool("hashicorp/terraform")
	tool.Version = "1.13.4"
	tool.Platforms["darwin_arm64"] = nil // Nil platform entry

	err := Save(tmpFile, lf)
	require.NoError(t, err)

	err = Verify(tmpFile)
	require.Error(t, err)
	assert.ErrorIs(t, err, ErrPlatformEntryNil)
	assert.Contains(t, err.Error(), "hashicorp/terraform/darwin_arm64")
}

func TestVerify_FileNotFound(t *testing.T) {
	tmpDir := t.TempDir()
	nonExistentFile := filepath.Join(tmpDir, "does-not-exist.yaml")

	err := Verify(nonExistentFile)
	require.Error(t, err)
}

func TestLockFile_MultiplePlatforms(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "multi-platform.yaml")

	lf := New()
	tool := lf.GetOrCreateTool("hashicorp/terraform")
	tool.Version = "1.13.4"
	tool.BinaryName = "terraform"

	// Add multiple platforms
	platforms := map[string]*PlatformEntry{
		"darwin_arm64": {
			URL:      "https://example.com/terraform-darwin-arm64.zip",
			Checksum: "sha256:darwin_arm64_checksum",
			Size:     95842304,
		},
		"darwin_amd64": {
			URL:      "https://example.com/terraform-darwin-amd64.zip",
			Checksum: "sha256:darwin_amd64_checksum",
			Size:     98765432,
		},
		"linux_amd64": {
			URL:      "https://example.com/terraform-linux-amd64.zip",
			Checksum: "sha256:linux_amd64_checksum",
			Size:     87654321,
		},
		"windows_amd64": {
			URL:      "https://example.com/terraform-windows-amd64.zip",
			Checksum: "sha256:windows_amd64_checksum",
			Size:     99123456,
		},
	}

	for platform, entry := range platforms {
		tool.Platforms[platform] = entry
	}

	// Save and load
	err := Save(tmpFile, lf)
	require.NoError(t, err)

	loaded, err := Load(tmpFile)
	require.NoError(t, err)

	loadedTool := loaded.Tools["hashicorp/terraform"]
	require.NotNil(t, loadedTool)
	assert.Len(t, loadedTool.Platforms, 4)

	// Verify each platform
	for platform, expectedEntry := range platforms {
		actualEntry := loadedTool.Platforms[platform]
		require.NotNil(t, actualEntry, "platform %s should exist", platform)
		assert.Equal(t, expectedEntry.URL, actualEntry.URL)
		assert.Equal(t, expectedEntry.Checksum, actualEntry.Checksum)
		assert.Equal(t, expectedEntry.Size, actualEntry.Size)
	}
}

func TestLockFile_MultipleTools(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "multi-tools.yaml")

	lf := New()

	// Add terraform
	tf := lf.GetOrCreateTool("hashicorp/terraform")
	tf.Version = "1.13.4"
	tf.Platforms["darwin_arm64"] = &PlatformEntry{
		URL:      "https://example.com/terraform.zip",
		Checksum: "sha256:terraform_checksum",
		Size:     95842304,
	}

	// Add kubectl
	kubectl := lf.GetOrCreateTool("kubernetes/kubectl")
	kubectl.Version = "1.34.1"
	kubectl.Platforms["darwin_arm64"] = &PlatformEntry{
		URL:      "https://example.com/kubectl",
		Checksum: "sha256:kubectl_checksum",
		Size:     45678901,
	}

	// Add opentofu
	tofu := lf.GetOrCreateTool("opentofu/opentofu")
	tofu.Version = "1.10.6"
	tofu.Platforms["darwin_arm64"] = &PlatformEntry{
		URL:      "https://example.com/tofu.zip",
		Checksum: "sha256:tofu_checksum",
		Size:     89123456,
	}

	// Save and load
	err := Save(tmpFile, lf)
	require.NoError(t, err)

	loaded, err := Load(tmpFile)
	require.NoError(t, err)

	assert.Len(t, loaded.Tools, 3)
	assert.NotNil(t, loaded.Tools["hashicorp/terraform"])
	assert.NotNil(t, loaded.Tools["kubernetes/kubectl"])
	assert.NotNil(t, loaded.Tools["opentofu/opentofu"])

	assert.Equal(t, "1.13.4", loaded.Tools["hashicorp/terraform"].Version)
	assert.Equal(t, "1.34.1", loaded.Tools["kubernetes/kubectl"].Version)
	assert.Equal(t, "1.10.6", loaded.Tools["opentofu/opentofu"].Version)
}
