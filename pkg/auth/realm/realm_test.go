package realm

import (
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestGetRealm_EnvVarPrecedence(t *testing.T) {
	// Environment variable should have highest priority.
	t.Setenv(EnvVarName, "env-realm")

	info, err := GetRealm("config-realm", "/path/to/config")
	require.NoError(t, err)
	assert.Equal(t, "env-realm", info.Value)
	assert.Equal(t, SourceEnv, info.Source)
}

func TestGetRealm_ConfigPrecedence(t *testing.T) {
	// Config should be used when env var is not set.
	info, err := GetRealm("config-realm", "/path/to/config")
	require.NoError(t, err)
	assert.Equal(t, "config-realm", info.Value)
	assert.Equal(t, SourceConfig, info.Source)
}

func TestGetRealm_AutoGenerated(t *testing.T) {
	// Auto-generated realm from path hash when no explicit config.
	info, err := GetRealm("", "/path/to/config")
	require.NoError(t, err)
	assert.Equal(t, SourceAuto, info.Source)
	assert.Len(t, info.Value, hashLength)
	// Should be hex characters only.
	for _, c := range info.Value {
		assert.True(t, (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f'),
			"auto-generated realm should only contain hex characters, got %c", c)
	}
}

func TestGetRealm_AutoGeneratedConsistency(t *testing.T) {
	// Same path should always produce the same hash.
	path := "/Users/dev/customer-acme/infrastructure"
	info1, err1 := GetRealm("", path)
	info2, err2 := GetRealm("", path)
	require.NoError(t, err1)
	require.NoError(t, err2)
	assert.Equal(t, info1.Value, info2.Value)
}

func TestGetRealm_DifferentPathsDifferentRealms(t *testing.T) {
	// Different paths should produce different hashes.
	info1, err1 := GetRealm("", "/path/to/customer-a")
	info2, err2 := GetRealm("", "/path/to/customer-b")
	require.NoError(t, err1)
	require.NoError(t, err2)
	assert.NotEqual(t, info1.Value, info2.Value)
}

func TestGetRealm_EmptyPath(t *testing.T) {
	// Empty path should still produce a valid hash.
	info, err := GetRealm("", "")
	require.NoError(t, err)
	assert.Equal(t, SourceAuto, info.Source)
	assert.Len(t, info.Value, hashLength)
}

func TestGetRealm_InvalidEnvVar(t *testing.T) {
	t.Setenv(EnvVarName, "Invalid/Realm")

	_, err := GetRealm("", "/path/to/config")
	require.Error(t, err)
	assert.Contains(t, err.Error(), EnvVarName)
	assert.Contains(t, err.Error(), "path traversal")
}

func TestGetRealm_InvalidConfig(t *testing.T) {
	_, err := GetRealm("My Realm", "/path/to/config")
	require.Error(t, err)
	assert.Contains(t, err.Error(), "auth.realm")
	assert.Contains(t, err.Error(), "invalid characters")
}

func TestValidate_ValidRealms(t *testing.T) {
	validRealms := []string{
		"customer-acme",
		"customer_acme",
		"customer123",
		"a",
		"ab",
		"a1b2c3d4",
		"my-project_v2",
		strings.Repeat("a", MaxLength),
	}

	for _, realm := range validRealms {
		t.Run(realm, func(t *testing.T) {
			err := Validate(realm)
			assert.NoError(t, err, "realm %q should be valid", realm)
		})
	}
}

func TestValidate_Empty(t *testing.T) {
	err := Validate("")
	require.Error(t, err)
	assert.Contains(t, err.Error(), "cannot be empty")
}

func TestValidate_TooLong(t *testing.T) {
	longRealm := strings.Repeat("a", MaxLength+1)
	err := Validate(longRealm)
	require.Error(t, err)
	assert.Contains(t, err.Error(), "exceeds maximum length")
}

func TestValidate_InvalidCharacters(t *testing.T) {
	tests := []struct {
		name     string
		realm    string
		contains string
	}{
		{"uppercase", "Customer", "invalid characters"},
		{"space", "my realm", "invalid characters"},
		{"dot", "my.realm", "invalid characters"},
		{"at sign", "my@realm", "invalid characters"},
		{"colon", "my:realm", "invalid characters"},
		{"forward slash", "my/realm", "path traversal"},
		{"backslash", "my\\realm", "path traversal"},
		{"double dot", "my..realm", "path traversal"},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			err := Validate(tc.realm)
			require.Error(t, err)
			assert.Contains(t, err.Error(), tc.contains)
		})
	}
}

func TestValidate_StartsWithHyphenOrUnderscore(t *testing.T) {
	tests := []string{"-realm", "_realm"}
	for _, realm := range tests {
		t.Run(realm, func(t *testing.T) {
			err := Validate(realm)
			require.Error(t, err)
			assert.Contains(t, err.Error(), "cannot start with")
		})
	}
}

func TestValidate_EndsWithHyphenOrUnderscore(t *testing.T) {
	tests := []string{"realm-", "realm_"}
	for _, realm := range tests {
		t.Run(realm, func(t *testing.T) {
			err := Validate(realm)
			require.Error(t, err)
			assert.Contains(t, err.Error(), "cannot end with")
		})
	}
}

func TestValidate_ConsecutiveHyphensOrUnderscores(t *testing.T) {
	tests := []string{"my--realm", "my__realm", "my-_realm", "my_-realm"}
	for _, realm := range tests {
		t.Run(realm, func(t *testing.T) {
			err := Validate(realm)
			require.Error(t, err)
			assert.Contains(t, err.Error(), "consecutive")
		})
	}
}

func TestRealmInfo_SourceDescription(t *testing.T) {
	tests := []struct {
		name          string
		info          RealmInfo
		cliConfigPath string
		contains      string
	}{
		{
			name:     "env source",
			info:     RealmInfo{Value: "test", Source: SourceEnv},
			contains: EnvVarName,
		},
		{
			name:     "config source",
			info:     RealmInfo{Value: "test", Source: SourceConfig},
			contains: "atmos.yaml",
		},
		{
			name:          "auto source with path",
			info:          RealmInfo{Value: "a1b2c3d4", Source: SourceAuto},
			cliConfigPath: "/path/to/config",
			contains:      "auto-generated from /path/to/config",
		},
		{
			name:          "auto source without path",
			info:          RealmInfo{Value: "a1b2c3d4", Source: SourceAuto},
			cliConfigPath: "",
			contains:      "auto-generated",
		},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			desc := tc.info.SourceDescription(tc.cliConfigPath)
			assert.Contains(t, desc, tc.contains)
		})
	}
}

func TestComputeHash(t *testing.T) {
	// Test that hash is consistent.
	hash1 := computeHash("/path/to/config")
	hash2 := computeHash("/path/to/config")
	assert.Equal(t, hash1, hash2)

	// Test that hash length is correct.
	assert.Len(t, hash1, hashLength)

	// Test that different inputs produce different hashes.
	hash3 := computeHash("/different/path")
	assert.NotEqual(t, hash1, hash3)
}
