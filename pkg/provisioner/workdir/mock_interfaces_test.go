// Code generated by MockGen. DO NOT EDIT.
// Source: interfaces.go
//
// Generated by this command:
//
//	mockgen -source=interfaces.go -destination=mock_interfaces_test.go -package=workdir
//

// Package workdir is a generated GoMock package.
package workdir

import (
	fs "io/fs"
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockFileSystem is a mock of FileSystem interface.
type MockFileSystem struct {
	ctrl     *gomock.Controller
	recorder *MockFileSystemMockRecorder
	isgomock struct{}
}

// MockFileSystemMockRecorder is the mock recorder for MockFileSystem.
type MockFileSystemMockRecorder struct {
	mock *MockFileSystem
}

// NewMockFileSystem creates a new mock instance.
func NewMockFileSystem(ctrl *gomock.Controller) *MockFileSystem {
	mock := &MockFileSystem{ctrl: ctrl}
	mock.recorder = &MockFileSystemMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockFileSystem) EXPECT() *MockFileSystemMockRecorder {
	return m.recorder
}

// CopyDir mocks base method.
func (m *MockFileSystem) CopyDir(src, dst string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CopyDir", src, dst)
	ret0, _ := ret[0].(error)
	return ret0
}

// CopyDir indicates an expected call of CopyDir.
func (mr *MockFileSystemMockRecorder) CopyDir(src, dst any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CopyDir", reflect.TypeOf((*MockFileSystem)(nil).CopyDir), src, dst)
}

// Exists mocks base method.
func (m *MockFileSystem) Exists(path string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exists", path)
	ret0, _ := ret[0].(bool)
	return ret0
}

// Exists indicates an expected call of Exists.
func (mr *MockFileSystemMockRecorder) Exists(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exists", reflect.TypeOf((*MockFileSystem)(nil).Exists), path)
}

// MkdirAll mocks base method.
func (m *MockFileSystem) MkdirAll(path string, perm fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MkdirAll", path, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// MkdirAll indicates an expected call of MkdirAll.
func (mr *MockFileSystemMockRecorder) MkdirAll(path, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MkdirAll", reflect.TypeOf((*MockFileSystem)(nil).MkdirAll), path, perm)
}

// ReadFile mocks base method.
func (m *MockFileSystem) ReadFile(path string) ([]byte, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadFile", path)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ReadFile indicates an expected call of ReadFile.
func (mr *MockFileSystemMockRecorder) ReadFile(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadFile", reflect.TypeOf((*MockFileSystem)(nil).ReadFile), path)
}

// RemoveAll mocks base method.
func (m *MockFileSystem) RemoveAll(path string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RemoveAll", path)
	ret0, _ := ret[0].(error)
	return ret0
}

// RemoveAll indicates an expected call of RemoveAll.
func (mr *MockFileSystemMockRecorder) RemoveAll(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RemoveAll", reflect.TypeOf((*MockFileSystem)(nil).RemoveAll), path)
}

// Stat mocks base method.
func (m *MockFileSystem) Stat(path string) (fs.FileInfo, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Stat", path)
	ret0, _ := ret[0].(fs.FileInfo)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Stat indicates an expected call of Stat.
func (mr *MockFileSystemMockRecorder) Stat(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stat", reflect.TypeOf((*MockFileSystem)(nil).Stat), path)
}

// Walk mocks base method.
func (m *MockFileSystem) Walk(root string, fn fs.WalkDirFunc) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Walk", root, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// Walk indicates an expected call of Walk.
func (mr *MockFileSystemMockRecorder) Walk(root, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Walk", reflect.TypeOf((*MockFileSystem)(nil).Walk), root, fn)
}

// WriteFile mocks base method.
func (m *MockFileSystem) WriteFile(path string, data []byte, perm fs.FileMode) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteFile", path, data, perm)
	ret0, _ := ret[0].(error)
	return ret0
}

// WriteFile indicates an expected call of WriteFile.
func (mr *MockFileSystemMockRecorder) WriteFile(path, data, perm any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteFile", reflect.TypeOf((*MockFileSystem)(nil).WriteFile), path, data, perm)
}

// MockHasher is a mock of Hasher interface.
type MockHasher struct {
	ctrl     *gomock.Controller
	recorder *MockHasherMockRecorder
	isgomock struct{}
}

// MockHasherMockRecorder is the mock recorder for MockHasher.
type MockHasherMockRecorder struct {
	mock *MockHasher
}

// NewMockHasher creates a new mock instance.
func NewMockHasher(ctrl *gomock.Controller) *MockHasher {
	mock := &MockHasher{ctrl: ctrl}
	mock.recorder = &MockHasherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockHasher) EXPECT() *MockHasherMockRecorder {
	return m.recorder
}

// HashDir mocks base method.
func (m *MockHasher) HashDir(path string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HashDir", path)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HashDir indicates an expected call of HashDir.
func (mr *MockHasherMockRecorder) HashDir(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HashDir", reflect.TypeOf((*MockHasher)(nil).HashDir), path)
}

// HashFile mocks base method.
func (m *MockHasher) HashFile(path string) (string, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "HashFile", path)
	ret0, _ := ret[0].(string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// HashFile indicates an expected call of HashFile.
func (mr *MockHasherMockRecorder) HashFile(path any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "HashFile", reflect.TypeOf((*MockHasher)(nil).HashFile), path)
}

// MockPathFilter is a mock of PathFilter interface.
type MockPathFilter struct {
	ctrl     *gomock.Controller
	recorder *MockPathFilterMockRecorder
	isgomock struct{}
}

// MockPathFilterMockRecorder is the mock recorder for MockPathFilter.
type MockPathFilterMockRecorder struct {
	mock *MockPathFilter
}

// NewMockPathFilter creates a new mock instance.
func NewMockPathFilter(ctrl *gomock.Controller) *MockPathFilter {
	mock := &MockPathFilter{ctrl: ctrl}
	mock.recorder = &MockPathFilterMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockPathFilter) EXPECT() *MockPathFilterMockRecorder {
	return m.recorder
}

// Match mocks base method.
func (m *MockPathFilter) Match(path string, includedPaths, excludedPaths []string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Match", path, includedPaths, excludedPaths)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Match indicates an expected call of Match.
func (mr *MockPathFilterMockRecorder) Match(path, includedPaths, excludedPaths any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Match", reflect.TypeOf((*MockPathFilter)(nil).Match), path, includedPaths, excludedPaths)
}
