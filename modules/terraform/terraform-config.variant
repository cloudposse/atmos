#!/usr/bin/env variant
# vim: filetype=hcl

job "terraform config" {
  concurrency = 1
  description = "Show config in YAML or JSON format for a terraform component, environment and stage"

  parameter "component" {
    type        = string
    description = "Component"
  }

  # Use either `environment-stage` or `stack` to specify the configuration file for the component
  option "environment" {
    type        = string
    description = "Environment"
    short       = "e"
    default     = ""
  }

  option "stage" {
    type        = string
    description = "Stage"
    short       = "s"
    default     = ""
  }

  # Use either `environment-stage` or `stack` to specify the configuration file for the component
  option "stack" {
    type        = string
    description = "Stack"
    short       = "st"
    default     = ""
  }

  option "format" {
    default     = "yaml"
    type        = string
    description = "Format, YAML or JSON"
  }

  option "merge" {
    default     = true
    type        = bool
    description = "Whether to merge global and component configs into a flat map"
  }

  config "stack-config" {
    source file {
      path = opt.stack != "" && opt.stack != null ? "${opt.config-dir}/${opt.stack}.yaml" : "${opt.config-dir}/${opt.environment}-${opt.stage}.yaml"
    }
  }

  variable "component-config" {
    value = conf.stack-config.components.terraform[param.component]
  }

  variable "component-vars" {
    value = lookup(var.component-config, "vars", {})
  }

  variable "import-config" {
    value = try(conf.stack-config.import, null) != null ? conf.stack-config.import : []
  }

  dynamic config "imports" {
    for_each = toset(var.import-config)
    content {
      source file {
        path = "${opt.config-dir}/${each.value}.yaml"
      }
    }
  }

  variable "imports-globals-vars" {
    value = merge(conf.imports, conf.stack-config.components.globals, var.component-vars)
  }

  variable "imports-globals-config" {
    value = merge(conf.imports, conf.stack-config.components.globals, var.component-config)
  }

  exec {
    command = "echo"
    args = [
      opt.merge ?
        (opt.format == "json" ? jsonencode(var.imports-globals-vars) : yamlencode(var.imports-globals-vars))
        :
        (opt.format == "json" ? jsonencode(var.imports-globals-config) : yamlencode(var.imports-globals-config))
    ]
  }
}

# Find 'terraform' binary to execute.
# It could come from the config file 'command' attribute, or from the '--command=' command line argument.
# Otherwise, the default 'terraform' binary will be used (from the PATH)
job "terraform-command" {
  concurrency = 1
  description = "Find 'terraform' binary to execute"
  private     = true

  parameter "component" {
    type        = string
    description = "Component"
  }

  option "environment" {
    type        = string
    description = "Environment"
    short       = "e"
    default     = ""
  }

  option "stage" {
    type        = string
    description = "Stage"
    short       = "s"
    default     = ""
  }

  option "stack" {
    type        = string
    description = "Stack"
    short       = "st"
    default     = ""
  }

  option "command" {
    default     = "terraform"
    type        = string
    description = "Command to execute, e.g. 'terraform', or path to the command, e.g. '/usr/local/terraform/0.13/bin/terraform'"
  }

  config "stack-config" {
    source job {
      name = "terraform config"
      args = {
        component   = param.component
        environment = opt.environment
        stage       = opt.stage
        stack       = opt.stack
        format      = "json"
        merge       = false
      }
    }
  }

  variable "command" {
    value = coalesce(lookup(conf.stack-config, "command", null), opt.command)
  }

  exec {
    command = "echo"
    args    = list("command: ${var.command}")
  }
}
