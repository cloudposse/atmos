#!/usr/bin/env variant
# vim: filetype=hcl

job "stack config" {
  concurrency = 1
  description = "Generate stack config in YAML or JSON format"
  private     = true

  parameter "component" {
    type        = string
    description = "Component"
    default     = ""
  }

  option "stack" {
    type        = string
    description = "Stack"
    short       = "s"
  }

  option "type" {
    type        = string
    description = "Type (`terraform`, `helmfile`)"
  }

  option "format" {
    default     = "yaml"
    type        = string
    description = "Output format (`yaml`, `json`)"
  }

  option "merge" {
    default     = true
    type        = bool
    description = "Whether to merge global and component configs into a flat map"
  }

  config "stack-config" {
    source file {
      path = "${opt.config-dir}/${opt.stack}.yaml"
    }
  }

  # 1st level of imports
  variable "import-paths-1" {
    value = try(conf.stack-config.import, null) != null ? conf.stack-config.import : []
  }

  variable "imports-1" {
    value = merge(
    [
      for p in var.import-paths-1 : {
        for k, v in yamldecode(file(format("%s/%s.yaml", opt.config-dir, p))) : k => v
      }
    ]
    ...)
  }

  # 2nd level of imports
  variable "import-paths-2" {
    value = try(var.imports-1.import, null) != null ? var.imports-1.import : []
  }

  variable "imports-2" {
    value = merge(
    [
      for p in var.import-paths-2 : {
        for k, v in yamldecode(file(format("%s/%s.yaml", opt.config-dir, p))) : k => v
      }
    ]
    ...)
  }

  # 3rd level of imports
  variable "import-paths-3" {
    value = try(var.imports-2.import, null) != null ? var.imports-2.import : []
  }

  variable "imports-3" {
    value = merge(
    [
      for p in var.import-paths-3 : {
        for k, v in yamldecode(file(format("%s/%s.yaml", opt.config-dir, p))) : k => v
      }
    ]
    ...)
  }

  # 4th level of imports
  variable "import-paths-4" {
    value = try(var.imports-3.import, null) != null ? var.imports-3.import : []
  }

  variable "imports-4" {
    value = merge(
    [
      for p in var.import-paths-4 : {
        for k, v in yamldecode(file(format("%s/%s.yaml", opt.config-dir, p))) : k => v
      }
    ]
    ...)
  }

  # 5th level of imports
  variable "import-paths-5" {
    value = try(var.imports-4.import, null) != null ? var.imports-4.import : []
  }

  variable "imports-5" {
    value = merge(
    [
      for p in var.import-paths-5 : {
        for k, v in yamldecode(file(format("%s/%s.yaml", opt.config-dir, p))) : k => v
      }
    ]
    ...)
  }

  variable "all-imports" {
    value = merge(var.imports-1, var.imports-2, var.imports-3, var.imports-4, var.imports-5)
  }

  variable "components-config" {
    value = conf.stack-config.components
  }

  variable "components-globals" {
    value = lookup(var.components-config, "globals", {})
  }

  variable "component-config" {
    value = try(var.components-config[opt.type][param.component], {})
  }

  variable "component-vars" {
    value = lookup(var.component-config, "vars", {})
  }

  variable "imports-components-globals-component-vars" {
    value = merge(var.all-imports, var.components-globals, var.component-vars)
  }

  variable "imports-components-globals-component-config" {
    value = merge(var.all-imports, var.components-globals, var.component-config)
  }

  exec {
    command = "echo"
    args = [
      opt.merge ?
        (opt.format == "json" ? jsonencode(var.imports-components-globals-component-vars) : yamlencode(var.imports-components-globals-component-vars))
        :
        (opt.format == "json" ? jsonencode(var.imports-components-globals-component-config) : yamlencode(var.imports-components-globals-component-config))
    ]
  }
}
